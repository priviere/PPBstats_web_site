[
["index.html", "PPBstats : An R package for Participatory Plant Breeding statisticial analyses Preface", " PPBstats : An R package for Participatory Plant Breeding statisticial analyses Pierre Rivière 2021-07-05 Preface PPBstats is an R package that performs analysis found within PPB programmes regarding network of seeds circulation, agronomic trials, organoleptic tests and molecular experiments. Be aware that this package is under development and test: do not 100% trust the functions!!! You’re welcome to contribute: see here for more informations. Figure 0.1: Wheat trials on farm within our participatory plant breeding programme, summer 2012, Auvergne, France. CC-BY-NC-SA. Pierre Rivière. (Rivière 2012b) References "],
["authors-and-contributors-of-ppbstats-and-the-book.html", "Authors and contributors of PPBstats and the book", " Authors and contributors of PPBstats and the book Pierre Rivière1 coordinated the package development, wrote the R functions and the present book Gaelle Van Frank2 tested the package and updated the code regarding sections 3.6.3, 3.6.4, 3.5.6, 3.6.5, 3.8.2.2, 3.8.2.3 and 3.8.3 Baptiste Rouger2 tested the package, updated and wrote code regarding sections 3.8.2.2 and 3.8.2.3. Olivier David3 wrote the JAGS code and reviewed the R code and the book regarding sections 3.5.6, 3.6.5, 3.5.6 and 3.8.3. Facundo Muñoz4 reformated and improved all the code regarding S3 methods, format figures with Tikz, improve section regarding contributions. Camille Vindras5 wrote text to present method description in sensory analysis in section 4. Mathieu Thomas6,7 proposed the data format as well as the descriptive analysis regarding network section 2. Isabelle Goldringer2 reviewed and improved all the text of the book 1 Réseau Semences Paysannes, 3 avenue de la gare, F-47190 Aiguillon, France Le Réseau Semences Paysannes (the French Farmers’ Seeds Network (RSP)), created in 2003, brings together a great diversity of collectives and people who preserve farmers’ seeds in fields, orchards, vineyards and gardens. They are involved in supporting the consolidation of local initiatives to maintain and renew cultivated biodiversity through Community Seeds Systems. Over 90 organizations have come together to promote and develop farmers’ seeds, and to protect farmers’ rights over their seeds. http://www.semencespaysannes.org 2 INRA, UMR 0320, Génétique Quantitative et Evolution, Ferme du Moulon F-91190 Gif sur Yvette, France The Diversity, Evolution and Adaptation of Populations (DEAP) team led by Isabelle Goldringer is part of INRA UMR 0320 Quantitative Genetic and Evolution. Its work is based on the analysis of the genetic and evolutionary mechanisms underlying evolution and adaptation of crop populations. DEAP develops strategies for on farm management of crop genetic diversity and for plant breeding (evolutionary and/or participatory) adated to organic and low input agriculture. Assessing the benefits of in-field genetic diversity (variety mixtures, populations) and designing / breeding optimized mixtures adapted to local conditions are also key research objectives. http://moulon.inra.fr/index.php/en/team/deap 3 INRA, UR 1404 Unité Mathématiques et Informatique Appliquées du Génome à l’Environnement, F-78352 Jouy-en-Josas, France The INRA UR1404 MaIAGE research laboratory gathers mathematicians, computer scientists, bioinformaticians and biologists to tackle problems coming from biology, agronomy and ecology; The addressed questions may concern processes at very different levels: molecular, cellular or multicellular, individual, populations, ecosystems oy landscapes. MaIAGE develops original methods in mathematics, statistics and computer science which are generic or driven by specific biological problems. A particular attention is paid to develop and make available softwares, databases, ontologies and web services so that biologists can use them easily to analyze their data or to mine the scientific literature. http://maiage.jouy.inra.fr/?q=en/home 4 INRA, Centre Val de Loire, Unité Amélioration, Génétique et Physiologie Forestières, F-45075 Orléans, France 5 ITAB, Ferme Expérimentale, 2485 Route des Pécolets, F-26800 Etoile-sur-Rhône, France 6 CIRAD, UMR AGAP, F-34398 Montpellier, France 7 AGAP, Univ Montpellier, CIRAD, INRA, Montpellier SupAgro, Montpellier, France "],
["copyright-licence-citation.html", "Copyright, Licence, citation", " Copyright, Licence, citation Copyright Réseau Semences Paysannes and Institut National de la Recherche Agronomique The R code is under licence GPL-3. The book is under licence creative commons BY-NC-SA 4.0 To cite the package : citation(&quot;PPBstats&quot;) ## ## To cite the PPBstats package in publications use: ## ## Pierre Riviere and al, 2019, PPBstats: An R package to perform ## analysis found within PPB programmes. Version 0.26, URL: ## https://github.com/priviere/PPBstats_web_site ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {PPBstats: An R package to perform analysis found within PPB programmes ## regarding network of seeds circulation, agronomic trials, organoleptic tests and ## molecular experiments. Version 0.26}, ## author = {{Pierre Riviere and Gaelle {Van Franck} and Olivier David and Facundo Muñoz and Baptiste Rouger and Camille Vindras and Mathieu Thomas and Isabelle Goldringer}}, ## organisation = {{Reseau Semences Paysannes}, {INRA}, {CIRAD}, {ITAB}}, ## year = {2020}, ## url = {https://github.com/priviere/PPBstats_web_site}, ## note = {R code is under licence GPL-3. ## Vignette is under licence creative commons BY-NC-SA 4.0.}, ## } To cite the book : bibtex entry @book{ppbstats_book_2020, title = &quot;{PPBstats : An R package for Participatory Plant Breeding statisticial analyses.}&quot;, author = &quot;{Pierre Riviere and Gaelle {Van Franck} and Olivier David and Baptiste Rouger and Camille Vindras and Mathieu Thomas and Isabelle Goldringer}&quot;, year = &quot;2020&quot;, version = &quot;0.26&quot;, licence = &quot;CC BY NC SA&quot;, url = &quot;https://priviere.github.io/PPBstats_web_site/book/index.html&quot; } "],
["philo.html", "Chapter 1 Philosophy of PPBstats", " Chapter 1 Philosophy of PPBstats This chapter describes what is participatory plant breeding, the objectives of PPBstats, the design and statistical methods according to the objectives and how to install PPBstats. "],
["what-is-participatory-plant-bredding.html", "1.1 What is Participatory Plant Bredding ?", " 1.1 What is Participatory Plant Bredding ? 1.1.1 Decentralize the selection The following development is adapted from Rex (2002) and Gallais (1990). When considering multiple environments for evaluation and selection, the phenotypic value of a trait of any individual in a given environment can be written as the sum of its random genetic effect (or overall genetic potential, \\(G\\) ), the random environmental effect (\\(E\\)) and the random interaction (\\(G \\times E\\)), i.e. : \\(P = G + E + G \\times E + e\\) with \\(e\\) the random residual effect within each environment following a normal distribution \\(N(0, \\sigma^2)\\). In classical centralized breeding, the objective is to predict the overall genetic potential (\\(G\\)) of the candidates for selection to detect the highest values assuming that this potential would express in all farmers’ fields. These genetic potentials are predicted based on the average phenotypic values over all testing environments (usually experimental stations) and therefore the broad sense heritability for prediction is : \\(h^2_{sl} = \\frac{var(G)}{var(G) + \\frac{1}{nE} (var(E) + var(G \\times E)) + \\frac{1}{nEnR} (var(e))}\\) with \\(nE\\) (resp. \\(nR\\)) the number of environments (resp. the number of replicates in each environment). As environmental effect and \\(G \\times E\\) interactions limit prediction accuracy, the option is to increase the number of environments and to use environments that are homogeneous and similar and that minimize \\(G \\times E\\) interactions. On the contrary, in decentralized on farm breeding, it has been shown that the environments are very contrasted due to diverse pedo-climatic conditions associated to various agroecological farming practices, and that \\(G \\times E\\) interactions can be strong (Desclaux et al. 2008). Therefore, the prediction of the overall genotypic value (\\(G\\)) is not interesting and the objective is rather to predict the «local» genetic value of genotype \\(i\\) in environment \\(j\\), \\(Gloc_{ij}\\) which also includes the interaction with the local environment, i.e.: \\(Gloc_{ij} = G_i + (G \\times E)_{ij}\\) Then, the genetic variance in each local environment can be written as: \\(var(Gloc) = var(G) + var(G \\times E)\\) and the heritability to predict the local genetic values based on the phenotypic values observed in the local environments is: \\(h^2_{sl} = \\frac{var(Gloc)}{var(Gloc) + \\frac{1}{nR} var(e)} = \\frac{var(G) + var(G \\times E)}{var(G) + var(G \\times E) + \\frac{1}{nR} var(e)}\\) It can be noted that the \\(G \\times E\\) interactions contributes to both denominator and numerator therefore leading to no limiting effect on prediction accuracy. Hence, when facing a wide diversity of agroecological environment and practices, decentralized breeding is a key point to select adapted varieties to local agro-systems. 1.1.2 Involve all actors in the breeding decision process All actors are part of the breeding programme : farmers, technicians, researchers, facilitators, consumers … Such involvements empower all actors and may better answer the real needs of actors (Sperling et al. 2001). References "],
["objectives-of-ppbstats.html", "1.2 Objectives of PPBstats", " 1.2 Objectives of PPBstats PPBstats is a freely available package based on the R software [R_Core_Team] that performs analyses on the data collected during PPB programs at four levels: network of seed management (section 2), agronomic trials (section 3) in order to set, describe and analyse balanced and unbalanced trials in decentralized participatory plant breeding programmes. Nutritional data are also dealt here as it is the same data structure as agronomic data. The statistical procedures are based on frequentist and bayesian approaches. organoleptic tests (section 4) molecular experiments (section 5) Within a PPB programme, it is important to give results back to the farmers in order to discuss results and accompagny them in their selection. This can be done through the creation of reports with results coming from the analysis (section 6). The objectives of PPBstats are to have a single package capable of performing all analyses required for PPB programmes with comprehensive documentation, and to create a community working on PPB programmes in order to improve the package, exchange on how to process data from PPB programmes and develop good practices. "],
["contribute.html", "1.3 Contribute", " 1.3 Contribute Contributions to PPBstats are very welcome and can be made in four different ways: testing the package and reporting bugs, improving the code, improving the documentation and translating More information can be found here. "],
["design-and-statistical-methods-according-to-the-objectives.html", "1.4 Design and statistical methods according to the objectives", " 1.4 Design and statistical methods according to the objectives The analyses of data from PPB programmes aim to address the following main objectives: To study networks of seed circulation through analysis of network topology (section 2). To improve the prediction of a target variable for selection through analysis of agronomic and nutritional traits but this is not done in PPBstats. To compare different varieties or populations (hereafter called germplasms) evaluated for selection in different locations through analysis of agronomic and nutritional traits (section 3) and sensory analysis (section 4). To study the response of germplasms under selection over several environments through analysis of agronomic traits (section 3). To study diversity structure and identify parents to cross based on either good complementarity or similarity for some traits through analysis of agronomic traits (section 3) and molecular data (section 5). For each objective, there are severals method based on different experimental designs based on number of plots per location, the number of locations, the number of replicated germplasms within and between locations (section 3.2) … all being dependant to the amount of seeds available. Figure 1.1 and 1.2 present a decision tree with all objectives, experimental constraints, designs (D) and methods (M) of analysis carry out in PPBstats. Each branch is explained through an example for each experimental design and analysis in the corresponding section. Figure 1.1: Decision tree with objectives and type of analysis carry out in PPBstats. Figure 1.2: Decision tree with objectives, experimental constraints, designs and methods of analysis carry out in PPBstats. D refers to designs and M to methods. "],
["lets-go-install-ppbstats-and-the-data-used-in-the-book.html", "1.5 Let’s go: install PPBstats and the data used in the book!", " 1.5 Let’s go: install PPBstats and the data used in the book! To install the package, follow the instructions here. Once it is install, load the package library(PPBstats) and download the data used in this tutorial (this is useful to earn lots of time!) here. The following examples have been performed with the following R version : unlist(sessionInfo()$R.version) ## platform arch ## &quot;x86_64-pc-linux-gnu&quot; &quot;x86_64&quot; ## os system ## &quot;linux-gnu&quot; &quot;x86_64, linux-gnu&quot; ## status major ## &quot;&quot; &quot;3&quot; ## minor year ## &quot;6.1&quot; &quot;2019&quot; ## month day ## &quot;07&quot; &quot;05&quot; ## svn rev language ## &quot;76782&quot; &quot;R&quot; ## version.string nickname ## &quot;R version 3.6.1 (2019-07-05)&quot; &quot;Action of the Toes&quot; "],
["network.html", "Chapter 2 Analysis of network seed circulation (M8)", " Chapter 2 Analysis of network seed circulation (M8) "],
["introduction.html", "2.1 Introduction", " 2.1 Introduction Describing the topology of networks of seed circulation is interesting since it gives insight on how exchanges are organized within a PPB programme or a Community Seed Bank(Vernooy, Shrestha, and Sthapit 2015)(Pautasso et al. 2013). Analysis can be done at several geographical or organizing scales, for example local, regional or national. Two types of network are handled within PPBstats : unipart network where nodes are: seed lots (i.e. a combinaison of a germplasm in a given location a given year) and edges are relationships such as diffusion, mixture, reproduction, crosses or selection for example. locations and edges are diffusion events between locations bipart network where nodes are either location or germplasm 2.1.1 Workflow and function relations in PPBstats regarding network analysis The workflow is very simple as only descriptive analysis can be done based on network format (Figure 2.1). Figure 2.1: Decision tree with objectives and analysis carry out in PPBstats regarding network analysis. M refers to methods. Figure 2.2 displays the functions and their relationships. Table 2.1 describes each of the functions. You can have more information for each function by typing ?function_name in your R session. Note that plot() is S3 method. Therefore, you should type ?plot.PPBstats to have general features and then see in details for specific functions. Figure 2.2: Main functions used in the workflow. Table 2.1: Main function descriptions. function name description format_data_PPBstats Check and format the data to be used in PPBstats functions plot Build ggplot objects to visualize output References "],
["unipart-network-for-seed-lots-analysis.html", "2.2 Unipart network for seed lots analysis", " 2.2 Unipart network for seed lots analysis This section deals with unipart network that represents the relationships between seed lots. 2.2.1 Steps with PPBstats Format the data with format_data_PPBstats() get descriptive plot with plot() 2.2.2 Format the data The format required is a data frame with the following compulsory columns as factor: &quot;seed_lot_parent&quot; : name of the parent seed lot in the relationship &quot;seed_lot_child&quot; ; name of the child seed lots in the relationship &quot;relation_type&quot; : the type of relationship between the seed lots &quot;relation_year_start&quot; : the year when the relationship starts &quot;relation_year_end&quot; : the year when the relationship stops &quot;germplasm_parent&quot; : the germplasm associated to the parent seed lot &quot;location_parent&quot; : the location associated to the parent seed lot &quot;year_parent&quot; : the year of the last relationship of the parent seed lot &quot;germplasm_child&quot; : the germplasm associated to the child seed lot &quot;location_child&quot; : the location associated to the child seed lot &quot;year_child&quot; : represents the year of the last relation event of the child seed lot Possible options are : &quot;long_parent&quot;, &quot;lat_parent&quot;, &quot;long_child&quot;, &quot;lat_child&quot; to get map representation, supplementary variables with tags: &quot;_parent&quot;, &quot;_child&quot; or &quot;_relation&quot;. The format of the data are checked by the function format_data_PPBstats() with the following arguments : type : &quot;data_network&quot; network_part : &quot;unipart&quot; vertex_type : &quot;seed_lots&quot; The function returns list of igraph object1 coming from igraph::graph_from_data_frame(). data(data_network_unipart_sl) head(data_network_unipart_sl) ## seed_lot_parent seed_lot_child relation_type ## 1 germ-8_loc-1_2007_0001 germ-8_loc-1_2008_0001 selection ## 2 germ-8_loc-1_2008_0001 germ-8_loc-1_2009_0001 reproduction ## 3 germ-8_loc-1_2009_0001 germ-8_loc-2_2009_0001 diffusion ## 4 germ-8_loc-1_2008_0001 germ-8_loc-1_2009_0001 selection ## 5 germ-1_loc-1_2005_0001 germ-8_loc-1_2006_0001 reproduction ## 6 germ-6_loc-1_2005_0001 germ-8_loc-1_2006_0001 reproduction ## relation_year_start relation_year_end germplasm_parent location_parent ## 1 2007 2008 germ-8 loc-1 ## 2 2008 2009 germ-8 loc-1 ## 3 2009 2009 germ-8 loc-1 ## 4 2008 2009 germ-8 loc-1 ## 5 2005 2006 germ-1 loc-1 ## 6 2005 2006 germ-6 loc-1 ## year_parent alt_parent long_parent lat_parent germplasm_child ## 1 2007 50 0.616363 44.20314 germ-8 ## 2 2008 50 0.616363 44.20314 germ-8 ## 3 2009 50 0.616363 44.20314 germ-8 ## 4 2008 50 0.616363 44.20314 germ-8 ## 5 2005 50 0.616363 44.20314 germ-8 ## 6 2005 50 0.616363 44.20314 germ-8 ## location_child year_child alt_child long_child lat_child ## 1 loc-1 2008 50 0.616363 44.20314 ## 2 loc-1 2009 50 0.616363 44.20314 ## 3 loc-2 2009 360 3.087025 45.77722 ## 4 loc-1 2009 50 0.616363 44.20314 ## 5 loc-1 2006 50 0.616363 44.20314 ## 6 loc-1 2006 50 0.616363 44.20314 net_unipart_sl = format_data_PPBstats( type = &quot;data_network&quot;, data = data_network_unipart_sl, network_part = &quot;unipart&quot;, vertex_type = &quot;seed_lots&quot;) ## data has been formated for PPBstats functions. length(net_unipart_sl) ## [1] 1 head(net_unipart_sl) ## $all_data ## IGRAPH 421a099 DN-- 81 94 -- ## + attr: name (v/c), germplasm (v/c), location (v/c), year (v/c), ## | alt (v/c), long (v/c), lat (v/c), relation_year (v/c), format ## | (v/c), relation_type (e/c) ## + edges from 421a099 (vertex names): ## [1] germ-8_loc-1_2007_0001-&gt;germ-8_loc-1_2008_0001 ## [2] germ-8_loc-1_2008_0001-&gt;germ-8_loc-1_2009_0001 ## [3] germ-8_loc-1_2009_0001-&gt;germ-8_loc-2_2009_0001 ## [4] germ-8_loc-1_2008_0001-&gt;germ-8_loc-1_2009_0001 ## [5] germ-1_loc-1_2005_0001-&gt;germ-8_loc-1_2006_0001 ## [6] germ-6_loc-1_2005_0001-&gt;germ-8_loc-1_2006_0001 ## + ... omitted several edges 2.2.3 Describe the data The different representations are done with the plot() function. The name of the list is all_data as representation takes all data (and not only a given year or location as unipart network for location or bipart network). For network representation, set plot_type = &quot;network&quot; diffusion event are displayed with a curve. in_col can be settled to customize color of vertex. p_net = plot(net_unipart_sl, plot_type = &quot;network&quot;, in_col = &quot;location&quot;) p_net ## $all_data ## $all_data$network In order to get the network organized in a chronologiical order and by location, set organize_sl = TRUE. This representation is possible if the seed lots are under the following format : GERMPLASM_LOCATION_YEAR_DIGIT. p_net_org = plot(net_unipart_sl, plot_type = &quot;network&quot;, organize_sl = TRUE) p_net_org ## $all_data ## $all_data$network To have information on the seed lots that are represented, plot_type = &quot;barplot&quot; can be used. Choose what to represent on the x axis and in color as well as the number of parameter per plot. p_bar = plot(net_unipart_sl, plot_type = &quot;barplot&quot;, in_col = &quot;location&quot;, x_axis = &quot;germplasm&quot;, nb_parameters_per_plot_x_axis = 5, nb_parameters_per_plot_in_col = 5) p_bar$all_data$barplot$`germplasm-1|location-1` # first element of the plot Barplot can also be use to study the relation within the network. The name of the relation must be put in the argument vec_variables. The results is a list of two elements for each variable: nb_received: number of seed lots that end the relation nb_given: number of seed lots that start the relation p_bar = plot(net_unipart_sl, plot_type = &quot;barplot&quot;, vec_variables = &quot;diffusion&quot;, nb_parameters_per_plot_x_axis = 100, x_axis = &quot;location&quot;, in_col = &quot;year&quot;) p_bar ## $all_data ## $all_data$diffusion ## $all_data$diffusion$nb_received ## $all_data$diffusion$nb_received$`location-1|year-1` ## ## ## $all_data$diffusion$nb_given ## $all_data$diffusion$nb_given$`location-1|year-1` Location present on the network can be displayed on a map with plot_type = &quot;map&quot;. When using map, do not forget to use credit : Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL. p_map = plot(net_unipart_sl, plot_type = &quot;map&quot;, labels_on = &quot;location&quot;) p_map ## $all_data ## $all_data$map It can be interesting to plot information regarding a variable on map with a pie with plot_type = &quot;map&quot; and by setting arguments data_to_pie and variable: nb_values = 30 data_to_pie = data.frame( seed_lot = rep(c(&quot;germ-4_loc-4_2009_0001&quot;, &quot;germ-9_loc-4_2009_0001&quot;, &quot;germ-10_loc-3_2009_0001&quot;, &quot;germ-12_loc-3_2007_0001&quot;, &quot;germ-11_loc-2_2009_0001&quot;, &quot;germ-10_loc-2_2009_0001&quot;), each = nb_values), location = rep(c(&quot;loc-1&quot;, &quot;loc-1&quot;, &quot;loc-3&quot;, &quot;loc-3&quot;, &quot;loc-2&quot;, &quot;loc-2&quot;), each = nb_values), year = rep(c(&quot;2009&quot;, &quot;2008&quot;, &quot;2007&quot;, &quot;2007&quot;, &quot;2009&quot;, &quot;2009&quot;), each = nb_values), germplasm = rep(c(&quot;germ-7&quot;, &quot;germ-2&quot;, &quot;germ-6&quot;, &quot;germ-4&quot;, &quot;germ-5&quot;, &quot;germ-13&quot;), each = nb_values), block = 1, X = 1, Y = 1, y1 = rnorm(nb_values*6, 10, 2), # quanti y2 = rep(c(&quot;cat1&quot;, &quot;cat1&quot;, &quot;cat2&quot;, &quot;cat3&quot;, &quot;cat3&quot;, &quot;cat4&quot;), each = nb_values) # quali ) data_to_pie$seed_lot = as.factor(as.character(data_to_pie$seed_lot)) data_to_pie$location = as.factor(as.character(data_to_pie$location)) data_to_pie$year = as.factor(as.character(data_to_pie$year)) data_to_pie$germplasm = as.factor(as.character(data_to_pie$germplasm)) data_to_pie$block = as.factor(as.character(data_to_pie$block)) data_to_pie$X = as.factor(as.character(data_to_pie$X)) data_to_pie$Y = as.factor(as.character(data_to_pie$Y)) data_to_pie = format_data_PPBstats(data_to_pie, type = &quot;data_agro&quot;) ## data has been formated for PPBstats functions. # y1 is a quantitative variable p_map_pies_y1 = plot(net_unipart_sl, data_to_pie, plot_type = &quot;map&quot;, vec_variables = &quot;y1&quot;) p_map_pies_y1 ## $all_data ## $all_data$y1_map_with_pies # y2 is a qualitative variable p_map_pies_y2 = plot(net_unipart_sl, data_to_pie, plot_type = &quot;map&quot;, vec_variables = &quot;y2&quot;) p_map_pies_y2 ## $all_data ## $all_data$y2_map_with_pies or on the network with a pie with plot_type = &quot;network&quot; and by setting arguments data_to_pie and vec_variables: # y1 is a quantitative variable p_net_pies_y1 = plot(net_unipart_sl, data_to_pie, plot_type = &quot;network&quot;, vec_variables = &quot;y1&quot;) p_net_pies_y1 ## $all_data ## $all_data$y1_network_with_pies # y2 is a qualitative variable p_net_pies_y2 = plot(net_unipart_sl, data_to_pie, plot_type = &quot;network&quot;, vec_variables = &quot;y2&quot;) p_net_pies_y2 ## $all_data ## $all_data$y2_network_with_pies The same can be done regarding relation type of the network. This can be displayed on a map but not on a network. p_map_pies_diff = plot(net_unipart_sl, plot_type = &quot;map&quot;, vec_variables = &quot;diffusion&quot;) p_map_pies_diff ## $all_data ## $all_data$diffusion_nb_received_map_with_pies ## ## $all_data$diffusion_nb_given_map_with_pies Here the pies represent the repartition of the number of seed lots. http://igraph.org/r/↩ "],
["unipart-network-for-location-analysis.html", "2.3 Unipart network for location analysis", " 2.3 Unipart network for location analysis This section deals with unipart network that represent relationship of germplasm diffusion between locations. The representation can be done for each germplasm or for each year. 2.3.1 Steps with PPBstats Format the data with format_data_PPBstats() get descriptive plot with plot() 2.3.2 Format the data The format required is a data frame with the following compulsory columns as factor: &quot;location_parent&quot; : the location associated to the parent seed lot &quot;location_child&quot; : the location associated to the child seed lot &quot;relation_year_start&quot; : the year when the relationship starts &quot;relation_year_end&quot; : the year when the relationship stops Possible column options are : &quot;germplasm_parent&quot; : the germplasm associated to the parent seed lot &quot;year_parent&quot; : the year of the last relationship of the parent seed lot &quot;germplasm_child&quot; : the germplasm associated to the child seed lot &quot;year_child&quot; : represents the year of the last relation event of the child seed lot Other possibles column option are : &quot;long_parent&quot;, &quot;lat_parent&quot;, &quot;long_child&quot;, &quot;lat_child&quot; to get map representation. Note that data frame with unipart network for seed lots format can also be used. The format of the data are checked by the function format_data_PPBstats() with the following arguments : type : &quot;data_network&quot; network_part : &quot;unipart&quot; vertex_type : &quot;location&quot; network_split : &quot;germplasm&quot; or &quot;relation_year_start&quot;. The function returns list of igraph object2 coming from igraph::graph_from_data_frame(). data(data_network_unipart_sl) head(data_network_unipart_sl) ## seed_lot_parent seed_lot_child relation_type ## 1 germ-8_loc-1_2007_0001 germ-8_loc-1_2008_0001 selection ## 2 germ-8_loc-1_2008_0001 germ-8_loc-1_2009_0001 reproduction ## 3 germ-8_loc-1_2009_0001 germ-8_loc-2_2009_0001 diffusion ## 4 germ-8_loc-1_2008_0001 germ-8_loc-1_2009_0001 selection ## 5 germ-1_loc-1_2005_0001 germ-8_loc-1_2006_0001 reproduction ## 6 germ-6_loc-1_2005_0001 germ-8_loc-1_2006_0001 reproduction ## relation_year_start relation_year_end germplasm_parent location_parent ## 1 2007 2008 germ-8 loc-1 ## 2 2008 2009 germ-8 loc-1 ## 3 2009 2009 germ-8 loc-1 ## 4 2008 2009 germ-8 loc-1 ## 5 2005 2006 germ-1 loc-1 ## 6 2005 2006 germ-6 loc-1 ## year_parent alt_parent long_parent lat_parent germplasm_child ## 1 2007 50 0.616363 44.20314 germ-8 ## 2 2008 50 0.616363 44.20314 germ-8 ## 3 2009 50 0.616363 44.20314 germ-8 ## 4 2008 50 0.616363 44.20314 germ-8 ## 5 2005 50 0.616363 44.20314 germ-8 ## 6 2005 50 0.616363 44.20314 germ-8 ## location_child year_child alt_child long_child lat_child ## 1 loc-1 2008 50 0.616363 44.20314 ## 2 loc-1 2009 50 0.616363 44.20314 ## 3 loc-2 2009 360 3.087025 45.77722 ## 4 loc-1 2009 50 0.616363 44.20314 ## 5 loc-1 2006 50 0.616363 44.20314 ## 6 loc-1 2006 50 0.616363 44.20314 2.3.3 Format and describe the data for each germplasm For network_split = &quot;germplasm&quot;, it returns a list with as many elements as germplam in the data as well as all germplasms merged in the first element of the list. net_unipart_location_g = format_data_PPBstats( type = &quot;data_network&quot;, data = data_network_unipart_sl, network_part = &quot;unipart&quot;, vertex_type = &quot;location&quot;, network_split = &quot;germplasm&quot;) ## data has been formated for PPBstats functions. names(net_unipart_location_g) ## [1] &quot;germ-10 / germ-11 / germ-12 / germ-13 / germ-2 / germ-3 / germ-4 / germ-5 / germ-8 / germ-9&quot; ## [2] &quot;germ-10&quot; ## [3] &quot;germ-11&quot; ## [4] &quot;germ-12&quot; ## [5] &quot;germ-13&quot; ## [6] &quot;germ-2&quot; ## [7] &quot;germ-3&quot; ## [8] &quot;germ-4&quot; ## [9] &quot;germ-5&quot; ## [10] &quot;germ-8&quot; ## [11] &quot;germ-9&quot; The different representations are done with the plot() function. For network representation, set plot_type = &quot;network&quot; diffusion event are display with curve. in_col can be settle to customize color of vertex. The curve between location represent the diffusion, the number of diffusion is displayed on a color scale. p_net = plot(net_unipart_location_g, plot_type = &quot;network&quot;, labels_on = &quot;location&quot;, labels_size = 4) names(p_net) # one element per germplasm, the first element with all the data ## [1] &quot;germ-10 / germ-11 / germ-12 / germ-13 / germ-2 / germ-3 / germ-4 / germ-5 / germ-8 / germ-9&quot; ## [2] &quot;germ-10&quot; ## [3] &quot;germ-11&quot; ## [4] &quot;germ-12&quot; ## [5] &quot;germ-13&quot; ## [6] &quot;germ-8&quot; ## [7] &quot;germ-9&quot; p_net$`germ-2` ## NULL 2.3.4 Format and describe the data for each year For network_split = &quot;relation_year_start&quot;, it returns a list with as many elements as year in the data as well as all years merged in the first element of the list. net_unipart_location_y = format_data_PPBstats( type = &quot;data_network&quot;, data = data_network_unipart_sl, network_part = &quot;unipart&quot;, vertex_type = &quot;location&quot;, network_split = &quot;relation_year_start&quot;) ## data has been formated for PPBstats functions. names(net_unipart_location_y) ## [1] &quot;2007-2008-2009&quot; &quot;2007&quot; &quot;2008&quot; &quot;2009&quot; The different representations are done with the plot() function. For network representation, set plot_type = &quot;network&quot; diffusion event are display with curve. in_col can be settle to customize color of vertex. The curve between location represent the diffusion, the number of diffusion is displayed on a color scale. p_net = plot(net_unipart_location_y, plot_type = &quot;network&quot;, labels_on = &quot;location&quot;, labels_size = 4) names(p_net) # one element per year, the first element with all the data ## [1] &quot;2007-2008-2009&quot; &quot;2007&quot; &quot;2008&quot; &quot;2009&quot; p_net$`2007-2008-2009` ## $network With barplots, it represents the number of germplasm received or given. p_bar = plot(net_unipart_location_y, plot_type = &quot;barplot&quot;, x_axis = &quot;location&quot;, in_col = &quot;germplasm&quot;) names(p_bar) # one element per year, the first element with all the data ## [1] &quot;2007-2008-2009&quot; &quot;2007&quot; &quot;2008&quot; &quot;2009&quot; p_bar = p_bar$`2007-2008-2009` p_bar$barplot$received p_bar$barplot$given Location present on the network can be displayed on a map with plot_type = &quot;map&quot;. When using map, do not forget to use credit : Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL. p_map = PPBstats:::plot.data_network(net_unipart_location_y[1], plot_type = &quot;map&quot;, labels_on = &quot;location&quot;) # Note if you want to do it on all element of the list, you should use # plot(net_unipart_location_y, plot_type = &quot;map&quot;, labels_on = &quot;location&quot;) # Here we use PPBstats:::plot.data_network only not to ask to often the map server that may bug if there are too many query # We use ::: because the function is not exported as it is an S3 method p_map$`2007-2008-2009` ## $map As well as plot information regarding a variable on map with a pie with plot_type = &quot;map&quot; and by setting arguments data_to_pie and vec_variables: # y1 is a quantitative variable p_map_pies_y1 = PPBstats:::plot.data_network(net_unipart_location_y[1], data_to_pie, plot_type = &quot;map&quot;, vec_variables = &quot;y1&quot;) p_map_pies_y1$`2007-2008-2009` ## $y1_map_with_pies # y2 is a qualitative variable p_map_pies_y2 = PPBstats:::plot.data_network(net_unipart_location_y[1], data_to_pie, plot_type = &quot;map&quot;, vec_variables = &quot;y2&quot;) p_map_pies_y2$`2007-2008-2009` ## $y2_map_with_pies http://igraph.org/r/↩ "],
["bipart-network-analysis.html", "2.4 Bipart network analysis", " 2.4 Bipart network analysis This section deals with bipart network that represents “which location has which germplasm which year”. 2.4.1 Steps with PPBstats Format the data with format_data_PPBstats() get descriptive plot with plot() 2.4.2 Format the data The format required is a data frame with the following compulsory columns as factor: &quot;germplasm&quot;, &quot;location&quot;, &quot;year&quot;. Possible options are : &quot;long&quot;, &quot;lat&quot; to get map representation Note that data frame with unipart network for seed lots format can also be used. The format of the data are checked by the function format_data_PPBstats() with the following arguments : type : &quot;data_network&quot; network_part : &quot;bipart&quot; vertex_type : c(&quot;germplasm&quot;, &quot;location&quot;) The function returns list of igraph object3 coming from igraph::graph_from_data_frame(). data(data_network_unipart_sl) head(data_network_unipart_sl) ## seed_lot_parent seed_lot_child relation_type ## 1 germ-8_loc-1_2007_0001 germ-8_loc-1_2008_0001 selection ## 2 germ-8_loc-1_2008_0001 germ-8_loc-1_2009_0001 reproduction ## 3 germ-8_loc-1_2009_0001 germ-8_loc-2_2009_0001 diffusion ## 4 germ-8_loc-1_2008_0001 germ-8_loc-1_2009_0001 selection ## 5 germ-1_loc-1_2005_0001 germ-8_loc-1_2006_0001 reproduction ## 6 germ-6_loc-1_2005_0001 germ-8_loc-1_2006_0001 reproduction ## relation_year_start relation_year_end germplasm_parent location_parent ## 1 2007 2008 germ-8 loc-1 ## 2 2008 2009 germ-8 loc-1 ## 3 2009 2009 germ-8 loc-1 ## 4 2008 2009 germ-8 loc-1 ## 5 2005 2006 germ-1 loc-1 ## 6 2005 2006 germ-6 loc-1 ## year_parent alt_parent long_parent lat_parent germplasm_child ## 1 2007 50 0.616363 44.20314 germ-8 ## 2 2008 50 0.616363 44.20314 germ-8 ## 3 2009 50 0.616363 44.20314 germ-8 ## 4 2008 50 0.616363 44.20314 germ-8 ## 5 2005 50 0.616363 44.20314 germ-8 ## 6 2005 50 0.616363 44.20314 germ-8 ## location_child year_child alt_child long_child lat_child ## 1 loc-1 2008 50 0.616363 44.20314 ## 2 loc-1 2009 50 0.616363 44.20314 ## 3 loc-2 2009 360 3.087025 45.77722 ## 4 loc-1 2009 50 0.616363 44.20314 ## 5 loc-1 2006 50 0.616363 44.20314 ## 6 loc-1 2006 50 0.616363 44.20314 net_bipart = format_data_PPBstats( type = &quot;data_network&quot;, data = data_network_unipart_sl, network_part = &quot;bipart&quot;, vertex_type = c(&quot;germplasm&quot;, &quot;location&quot;) ) ## data has been formated for PPBstats functions. For bipart network, it returns a list with as many elements as year in the data as well as all years merged in the first element of the list. If no year are provided into the data, all information are merged. names(net_bipart) ## [1] &quot;2005-2006-2007-2008-2009&quot; &quot;2005&quot; ## [3] &quot;2006&quot; &quot;2007&quot; ## [5] &quot;2008&quot; &quot;2009&quot; 2.4.3 Describe the data The different representations are done with the plot() function. p_net = plot(net_bipart, plot_type = &quot;network&quot;, labels_on = TRUE, labels_size = 4) names(p_net) # one element per year, the first element with all the data ## [1] &quot;2005-2006-2007-2008-2009&quot; &quot;2005&quot; ## [3] &quot;2006&quot; &quot;2007&quot; ## [5] &quot;2008&quot; &quot;2009&quot; p_net$`2009` ## $network With barplots, it represents the number of edges per vertex for each germplasm and each location. p_bar = plot(net_bipart, plot_type = &quot;barplot&quot;) names(p_bar) # one element per year, the first element with all the data ## [1] &quot;2005-2006-2007-2008-2009&quot; &quot;2005&quot; ## [3] &quot;2006&quot; &quot;2007&quot; ## [5] &quot;2008&quot; &quot;2009&quot; p_bar = p_bar$`2005-2006-2007-2008-2009`$barplot p_bar$germplasm p_bar$location Location present on the network can be displayed on a map with plot_type = &quot;map&quot;. When using map, do not forget to use credit : Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL. p_map = PPBstats:::plot.data_network(net_bipart[1], plot_type = &quot;map&quot;, labels_on = &quot;location&quot;) p_map$`2005-2006-2007-2008-2009` ## $map As well as plot information regarding a variable on map with a pie with plot_type = &quot;map&quot; and by setting arguments data_to_pie and vec_variables: # y1 is a quantitative variable p_map_pies_y1 = PPBstats:::plot.data_network(net_bipart[1], data_to_pie, plot_type = &quot;map&quot;, vec_variables = &quot;y1&quot;) p_map_pies_y1$`2005-2006-2007-2008-2009` ## $y1_map_with_pies # y2 is a qualitative variable p_map_pies_y2 = PPBstats:::plot.data_network(net_bipart[1], data_to_pie, plot_type = &quot;map&quot;, vec_variables = &quot;y2&quot;) p_map_pies_y2$`2005-2006-2007-2008-2009` ## $y2_map_with_pies http://igraph.org/r/↩ "],
["agronomic.html", "Chapter 3 Analysis of agronomic traits", " Chapter 3 Analysis of agronomic traits In section 3.1, you will chose your objective, the analyses and the experimental design based on a decision tree and see how to implement it based on the workflow and function relations from formated data. Then, thanks to PPBstats, you will design the experiment (section 3.2), sow, note, harvest, measure … (section 3.3)4, describe the data (section 3.4), run statistical analysis (sections 3.5, 3.6, 3.7, 3.8 and 3.9) well, ok, PPBstats will not do it for you !!!↩ "],
["intro-agro.html", "3.1 Introduction", " 3.1 Introduction First, chose your objective (3.1.1), then the analyses (3.1.2) and the experimental design (3.1.3) based on a decision tree (3.1.4). Finally see how to implement it based on the workflow and function relations (3.1.5) from formated data (3.1.6). 3.1.1 Analysis according to the objectives The three main objectives in PPB are to : Compare different varieties evaluated for selection in different locations. This can be done through family 1 of analyses (section 3.5) classic anova (M4a, section 3.5.3) based on on fully replicated designs (D1, section 3.2.1), spatial analysis (M4b, section 3.5.4) based on row-column designs (D3, section 3.2.3), mixed models (M5, section3.5.5) for incomplete blocks designs (D2, section 3.2.2), bayesian hierarchical model intra-location (M7a, section 3.5.6) based on satellite-regional farms designs (D4, section 3.2.4). It can be completed by organoleptic analysis (section 4). Based on these analysis, specific objective including response to selection analysis can also be done. Study the response of varieties under selection over several environments. This can be done through family 2 of analyses (section 3.6): AMMI (M6a, section 3.6.3 and GGE (M6b, sections 3.6.4) based on on fully replicated designs (D1, section 3.2.1), bayesian hierarchical model \\(G \\times E\\) (M7b, section 3.6.5) based on satellite-regional farms designs (D4, section 3.2.4), It can be completed by specific analysis such as local-foreign (section 3.8.2.3) which corresponds to a specific objective : study local and foreign effect, where foreign in a location refers to a germplasm that has not been grown or selected in a given location and local in a location refers to a germplasm that has been grown or selected in a given location. Study diversity structure and identify parents to cross based on either good complementarity or similarity for some traits. This can be done through multivariate analysis and clustering (M2, section 3.9. It can be completed by analysis of molecular data and genetic distance trees (M3, section 5). 3.1.2 Family of analyses After describing the data (section 3.4), you can run statistical analysis. Table 3.1 summarizes the analyses available in PPBstats and their specificities. The various effects that can be estimated are: germplasm: a variety or a population location: a farm or a station where a trial is carried out environment: a combination of a location and a year entry: the occurence of a germplasm in a given environment or location interaction: interaction between germplasm and location or germplasm and environment year local-foreign: foreign in a location refers to a germplasm that has not been grown or selected in a given location; local in a location refers to a germplasm that has been grown or selected in a given location. version: version within a germplasm, for example selected vs non-selected The analyses are divided into five families: Family 1 (section 3.5) gathers analyses that estimate entry effects. It allows to compare different entries on each location and test for significant differences among entries. Specific analysis including response to selection can also be done. The objective to compare different germplasms on each location for selection. Family 2 (section 3.6) gathers analyses that estimate germplasm and location and interaction effects. This is to analyse the response over a network of locations. Estimation of environment and year effects is possible depending of the model. It allows to study the response of germplasm over several location or environments. The objectives is to study response of different germplasms over several locations for selection. Family 3 (section 3.7) correspond to combining family 1 and 2 analyses. This allows to analyse network of farms and to study the response of entries over several locations and environnements for selection. Family 4 (section 3.8) gathers analyses answering specific research questions and objectives such as study intra germplasm variation, study local adaptation with home-away and local-foreign analysis, study differential and response to selection based on models from Family 1. Family 5 (section 3.9) refers to multivariate analysis The different models in Family 1 and 2 correspond to experimental designs that are mentionned in the next section 3.1.3 and in the decision tree 3.1.4. Table 3.1: Analyses carried out in PPBstats. X: effects that are estimated. (X): effects that can be estimated. Family Name Section entry effects germpasm effects location effects environments effects interaction effects year effects local-foreign effects version effects variance intra germplasm effects 1 Anova 3.5.3 X Spatial analysis 3.5.4 X IBD 3.2.2 X Bayesian hierarchical model intra-location 3.5.6 X 2 IBD 3.2.2 X AMMI 3.6.3 X X (X) X (X) GGE 3.6.4 X X (X) X (X) Bayesian hierarchical model \\(G \\times E\\) 3.6.5 X X (X) X 3 Bayesian model 3 3.7.1 X X X X X 4 Variance intra 3.8.3 X Home-away 3.8.2.2 X X (X) (X) (X) (X) X Local-foreign 3.8.2.3 X X (X) (X) (X) (X) X Analysis used in PPB programmes are mentionned in decision tree in Section 3.1.4. 3.1.2.1 Frequentist statistics 3.1.2.1.1 Theory 3.1.2.1.2 Check model Regarding frequentist analysis, there are several ways to check if the model went well. Residuals distribution. If it looks normal then the hypothesis seems fullfiled. Skewness test which is an indicator used in distribution analysis as a sign of asymmetry and deviation from a normal distribution. Skewness &gt; 0 - Right skewed distribution - most values are concentrated on left of the mean, with extreme values to the right. Skewness &lt; 0 - Left skewed distribution - most values are concentrated on the right of the mean, with extreme values to the left. Skewness = 0 - mean = median, the distribution is symmetrical around the mean. Kurtosis test which is an indicator used in distribution analysis as a sign of flattening or “peakedness” of a distribution. Kurtosis &gt; 3 - Leptokurtic distribution, sharper than a normal distribution, with values concentrated around the mean and thicker tails. This means high probability for extreme values. Kurtosis &lt; 3 - Platykurtic distribution, flatter than a normal distribution with a wider peak. The probability for extreme values is less than for a normal distribution, and the values are wider spread around the mean. Kurtosis = 3 - Mesokurtic distribution - normal distribution for example. Shapiro test is an indicator of the normal distribution of the residuals. The null hypothesis is: residuals follow a normal distribution. If p-value is significant (i.e. &gt; 0.05), residuals follow a normal distribution. Standardized residuals vs theoretical quantiles (qqplot). If the residuals come from a normal distribution the plot should resemble a straight line. A straight line connecting the 1st and 3rd quartiles is added to the plot to aid in visual assessment. Distribution of residuals for each rows. It allos to llok for autocorrelation among residuals. Repartition of variability among factors whici is a pie with repartition of SumSq for each factor. This allows to better understand how the variability is separated between each factor. Variance intra germplasm whici is the repartition of the residuals for each germplasm. With the hypothesis than the micro-environmental variation is equaly distributed on all the individuals (i.e. all the plants), the distribution of each germplasm represent the intra-germplasm variance. This has to been seen with caution: If germplasm have no intra-germplasm variance (i.e. pure line or hybrides) then the distribution of each germplasm represent only the micro-environmental variation. If germplasm have intra-germplasm variance (i.e. population such as landraces for example) then the distribution of each germplasm represent the micro-environmental variation plus the intra-germplasm variance. 3.1.2.1.3 Mean comparisons LSD, LSmeans for home away and local foreign), etc 3.1.2.2 Bayesian statistics 3.1.2.2.1 Theory Some analyses performed in PPBstats are based on Bayesian statistics. Bayesian statistics are based on the Bayes theorem: \\(Pr(\\theta|y) \\propto Pr(\\theta) Pr(y|\\theta)\\) with \\(y\\) the observed value, \\(\\theta\\) the parameter to estimate, \\(Pr(\\theta|y)\\) the posterior distribution of the parameter given the data, \\(Pr(y|\\theta)\\) the likelihood of the observation and \\(Pr(\\theta)\\) the prior distribution of the parameter. The parameters’ distribution, knowing the data (the posterior), is proportional to the distribution of parameters a priori (the prior) \\(\\times\\) the information brought by the data (the likelihood). The more information (i.e. the larger the data set and the better the model fits the data), the less important is the prior. If the priors equal the posteriors, it means that there is not enough data or the model does not fit the data. Bayesian inference is based on the posterior distribution of model parameters. This distribution can not be calculated explicitely for the hierarchical model used in here (section 3.5.6 and section 3.6.5) but can be estimated using Markov Chain and Monte Carlo (MCMC) methods. These methods simulate parameters according to a Markov chain that converges to the posterior distribution of model parameters (Robert 2001). MCMC methods were implemented using JAGS by the R package rjags that performed Gibbs sampling (Robert 2001). Two MCMC chains were run independently to test for convergence using the Gelman-Rubin test. This test was based on the variance within and between the chains (Gelman and Rubin 1992). A burn-in and lots of iterations were needed in the MCMC procedure. Here the burn-in has 1000 iterations, then 100 000 iterations are done by default5 with a thinning interval of 10 to reduce autocorrelations between samples, so that 10 000 samples are available for inference for each chain by default6 The final distribution of a posterior is the concatenation of the two MCMC chains: 20 000 samples. 3.1.2.2.2 Check model 3.1.2.2.3 Mean comparisons In this part, the mean of each entry is compared to the mean of each other entry. Let \\(H_{0}\\) and \\(H_{1}\\) denote the hypotheses: \\(H_{0} : \\mu_{ij} \\ge \\mu_{i&#39;j} , \\; H_{1} : \\mu_{ij} &lt; \\mu_{i&#39;j}\\). The difference \\(\\mu_{ij}-\\mu_{i&#39;j}\\) between the means of entry \\(ij\\) and entry \\(i&#39;j\\) in environment \\(j\\) is considered as significant if either \\(H_{0}\\) or \\(H_{1}\\) has a high posterior probability, that is if \\(Pr\\{H_{0}|y\\} &gt; 1 - \\alpha\\) or \\(Pr\\{H_{1}|y\\}&gt; 1 - \\alpha\\), where \\(\\alpha\\) is some specified threshold. The difference is considered as not significant otherwise. The posterior probability of a hypothesis is estimated by the proportion of MCMC simulations for which this hypothesis is satisfied (Figure 3.1). Groups are made based on the probabilites. Entries that belong to the same group are not significantly different. Entries that do not belong to the same group are significantly different. Note that the term “significant” is not really correct7. Statistical significance refers to the variability of some estimator (e.g. \\(\\mu_{ij} - \\mu_{i&#39;j}\\)) under replications of the same experiment (i.e. different datasets), while the posterior probability quantifies the information about some variable given the current dataset. It may be better to claim - based on thershold \\(\\alpha\\) so that whenever the posterior probability of \\(H_0\\) or \\(H_1\\) exceeds \\(1 - \\alpha\\) - that the data provides evidence of some difference (not necessarily large) between groups. The threshold \\(\\alpha\\) depends on agronomic objectives. This threshold is set by default to \\(\\alpha=0.1/I\\) (with \\(I\\) the number of entries in a given location). It corresponds to a `soft’ Bonferroni correction, the Bonferroni correction being very conservative. As one objective of this PPB programme is that farmers (re)learn selection methods, the threshold could be adjusted to allow the detection of at least two groups instead of having farmers choose at random. The initial value could be set to \\(\\alpha=0.1/I\\) and if only one group is obtained, then this value could be adjusted to allow the detection of two groups. In this cases, the farmers should be informed that there is a lower degree of confidence for significant differences among entries. Figure 3.1: Mean comparison between \\(\\mu_{ij}\\) and \\(\\mu_{i&#39;j}\\) In PPBstats, mean comparisons are done with mean_comparisons. You can choose on which parameters to run the comparison (parameter argument) and the \\(\\alpha\\) type one error (alpha argument). The soft Bonferonni correction is applied by default (p.adj argument). More informations can be obtain on this function by typing ?mean_comparisons. 3.1.3 Experimental design Before sowing, you must plan the experiment regarding your research question, the amount of seeds available, the number of locations and the number of plots available in each location. The trial is designed in relation to the analysis you will perform. The key elements to choose an appropriate experimental design are: the number of locations the number of years the replication of entries within and between locations Several designs used in PPB programmes are mentionned in decision tree in section 3.1.4 and are presented in section 3.2. 3.1.4 Decision tree For each family of analysis, a decision tree is displayed in the corresponding section. Once you have chosen your objective, analysis and experimental design, you can sow, measure and harvest … (section 3.3). 3.1.5 Workflow and function relations in PPBstats regarding agronomic analysis After designing the experiment and describing the data, each family of analysis is implemented by several analysis with the same workflow : Format the data Run the model Check the model and visualize outputs Compare means and visualize outputs Note that for some functions for specific model maybe used. Figure 3.2 displays the functions and their relationships. Figure 3.2: Main functions used in the workflow. 3.1.6 Data format For agronomic analysis data must have a specific format: data_agro data_agro format corresponds to all the data set used in the functions that run models. The data have always the following columns : seed_lot, location, year, germplasm, block, X, Y as factors followed by the variables and their corresponding dates. The dates are associated to their corresponding variable by $. For example the date associated to variable y1 is y1$date. In addition, to get map, columns lat and long can be added. data(&quot;data_model_GxE&quot;) data_model_GxE = format_data_PPBstats(data_model_GxE, type = &quot;data_agro&quot;) ## data has been formated for PPBstats functions. head(data_model_GxE) ## seed_lot location long lat year germplasm block ## 1 germ-12_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-12 1 ## 2 germ-1_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-1 1 ## 3 germ-18_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-18 1 ## 4 germ-14_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-14 1 ## 5 germ-6_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-6 1 ## 6 germ-4_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-4 1 ## X Y y1 y1$date y2 y2$date y3 y3$date desease ## 1 A 1 14.32724 2017-07-15 41.85377 2017-07-15 66.05498 2017-07-15 low ## 2 A 2 23.03428 2017-07-15 37.38970 2017-07-15 63.39528 2017-07-15 low ## 3 A 3 24.91349 2017-07-15 38.38628 2017-07-15 60.52710 2017-07-15 high ## 4 A 4 24.99078 2017-07-15 39.72205 2017-07-15 60.80393 2017-07-15 low ## 5 A 5 18.95340 2017-07-15 46.60443 2017-07-15 53.71210 2017-07-15 high ## 6 B 1 21.31660 2017-07-15 49.94656 2017-07-15 60.71978 2017-07-15 medium ## vigor y1$date_julian y2$date_julian y3$date_julian ## 1 l 195 195 195 ## 2 l 195 195 195 ## 3 h 195 195 195 ## 4 l 195 195 195 ## 5 m 195 195 195 ## 6 l 195 195 195 Note that a column with julian date is added. class(data_model_GxE) ## [1] &quot;PPBstats&quot; &quot;data_agro&quot; &quot;data.frame&quot; Note that other formats exist in relation to specific reasearch questions as explained in section 3.8. References "],
["doe.html", "3.2 Design the experiment", " 3.2 Design the experiment The experimental design is described by the number of plots per location, the number of locations, the number of replications of the different germplasms within and between locations. Function design_experiment sets the experimental design based on : the number of entries the number of controls per block the number of blocks the number of columns in the design. The number of rows is computed automaticaly. The function returns a list with a data frame an image of the experimental design A description of the algorithm is describe in the help of the function: ?design_experiment. The four experimental designs are D1 - fully-repicated D2 - incomplete block design D3 - row-colum D4 - satellite-farm and regional-farm 3.2.1 Fully-replicated (D1) In fully replicated design, all entries are replicated with randomly choosen order into different blocks. The decision tree where fully-replicated designs are used is displayed in Figure 3.3. Figure 3.3: The decision tree where fully-replicated designs are used. The R code to implement is the following : p_fr = design_experiment( location = &quot;Location-1&quot;, year = &quot;2016&quot;, expe.type = &quot;fully-replicated&quot;, germplasm = paste(&quot;germ&quot;, c(1:20), sep = &quot;:&quot;), nb.blocks = 3, nb.cols = 4) ## Warning in get_data.frame(location, year, nb.germplasm, nb.blocks, ## nb.controls.per.block, : Germplasm are missing to get complete design, ## therefore XXXX are placed in order to fill the design. By default, the data frame is under a standard format: head(p_fr$&quot;fully-replicated&quot;$data.frame) ## location year germplasm block X Y ## 1 Location-1 2016 germ:1 1 A 1 ## 2 Location-1 2016 germ:5 1 A 2 ## 3 Location-1 2016 germ:13 1 A 3 ## 4 Location-1 2016 germ:17 1 A 4 ## 5 Location-1 2016 germ:9 1 A 5 ## 6 Location-1 2016 germ:4 1 A 6 You can set the format to a SHiNeMaS^[Seeds History and Network Management System, see here for more details and a presentation in french here reproduction template file: p_fr = design_experiment( location = &quot;Location-2&quot;, year = &quot;2016&quot;, expe.type = &quot;fully-replicated&quot;, germplasm = paste(&quot;germ&quot;, c(1:20), sep = &quot;:&quot;), nb.blocks = 3, nb.cols = 4, return.format = &quot;shinemas&quot;) ## Warning in get_data.frame(location, year, nb.germplasm, nb.blocks, ## nb.controls.per.block, : Germplasm are missing to get complete design, ## therefore XXXX are placed in order to fill the design. head(p_fr$&quot;fully-replicated&quot;$data.frame) ## project sown_year harvested_year id_seed_lot_sown ## 1 2016 germ:20_Location-2_2016 ## 2 2016 germ:5_Location-2_2016 ## 3 2016 germ:4_Location-2_2016 ## 4 2016 germ:11_Location-2_2016 ## 5 2016 germ:9_Location-2_2016 ## 6 2016 germ:18_Location-2_2016 ## intra_selection_name etiquette split quantity_sown quantity_harvested ## 1 ## 2 ## 3 ## 4 ## 5 ## 6 ## block X Y ## 1 1 A 1 ## 2 1 A 2 ## 3 1 A 3 ## 4 1 A 4 ## 5 1 A 5 ## 6 1 A 6 p_fr$&quot;fully-replicated&quot;$design Figure 3.4: Fully replicated design where all germplasms are replicated three time in bocks 3.2.2 Incomplete Block Design (D2) The decision tree where incomplete block designs are used is displayed in Figure 3.5. Figure 3.5: The decision tree where incomplete block designs are used. Entries are not replicated on a location. Some entries are common to some locations. Each block is an independent unit and can be allocated to any location. Each farmer has to choose one or several pre-designed blocks. Therefore, the experiment can be handled by several locations that can not receive a high number of plots. p_ibd = design_experiment( year = &quot;2016&quot;, expe.type = &quot;IBD&quot;, germplasm = paste(&quot;germ&quot;, c(1:10), sep = &quot;:&quot;), nb.blocks = 8, # i.e. number of location if each location has one block nb.cols = 4) head(p_ibd$`IBD`$data.frame) ## germplasm block X Y year ## 1 germ:1 1 A 1 2016 ## 2 germ:1 2 A 2 2016 ## 3 germ:5 3 A 3 2016 ## 4 germ:3 4 A 4 2016 ## 5 germ:2 5 A 5 2016 ## 6 germ:3 6 A 6 2016 p_ibd$`IBD`$design Figure 3.6: Example of incomplete block design where different germplasms are replicated over some blocks. 3.2.3 Row-column (D3) In Row-column design, a control is replicated in row and columns to catch as much as possible of the variation. The decision tree where row-column design are used is displayed in Figure 3.7. Figure 3.7: The decision tree where row-column designs are used. The R code to implement is the following : p_case2 = design_experiment( location = &quot;Location-3&quot;, year = &quot;2016&quot;, expe.type = &quot;row-column&quot;, germplasm = paste(&quot;germ&quot;, c(1:20), sep = &quot;:&quot;), controls = &quot;germ:ctrl&quot;, nb.controls.per.block = 7, nb.blocks = 1, nb.cols = 7) head(p_case2$&quot;row-column&quot;$data.frame) ## location year germplasm block X Y ## 1 Location-3 2016 germ:5 1 A 1 ## 2 Location-3 2016 germ:7 1 A 2 ## 3 Location-3 2016 germ:ctrl 1 A 3 ## 4 Location-3 2016 germ:20 1 A 4 ## 5 Location-3 2016 germ:17 1 B 1 ## 6 Location-3 2016 germ:ctrl 1 B 2 p_case2$&quot;row-column&quot;$design Figure 3.8: Row column design where a control (germ:ctrl) is replicated in rows and columns. Note that if controls are missing in rows or columns, the function will return an error message. The controls must catch as much as possible of the trial variation. 3.2.4 Regional and satellite farms (D4) Regional farms receive several entries (i.e. a germplasm in an environment) in two or more blocks with some entries (i.e. controls) replicated in each block. Satellite farms have a single block and only one entry (i.e. the control) is replicated twice. Farmers choose all entries that are not replicated. The number of entries may vary between farms. Note that at least 25 environments (location \\(\\times\\) year) are need in order to get robust results. The decision tree where regional and satellite farms designs are used is displayed in Figure 3.9. Figure 3.9: The decision tree where regional and satellite farms designs are used. The R code to implement is the following : As an example here, six designs are generated: four for satellite farms and two for regional farms. p_case3_sf1 = design_experiment( location = &quot;Location-4&quot;, year = &quot;2016&quot;, expe.type = &quot;satellite-farm&quot;, germplasm = paste(&quot;germ&quot;, c(1:6), sep = &quot;:&quot;), controls = &quot;germ:ctrl&quot;, nb.controls.per.block = 2, nb.blocks = 1, nb.cols = 2) p_case3_sf1 = p_case3_sf1$`satellite-farms`$design p_case3_sf1 Figure 3.10: Example of a satellite farm design. p_case3_sf2 = design_experiment( location = &quot;Location-5&quot;, year = &quot;2016&quot;, expe.type = &quot;satellite-farm&quot;, germplasm = paste(&quot;germ&quot;, c(1:6), sep = &quot;:&quot;), controls = &quot;germ:ctrl&quot;, nb.controls.per.block = 2, nb.blocks = 1, nb.cols = 2) p_case3_sf2 = p_case3_sf2$`satellite-farms`$design p_case3_sf2 Figure 3.11: Example of a satellite farm design. p_case3_sf3 = design_experiment( location = &quot;Location-6&quot;, year = &quot;2016&quot;, expe.type = &quot;satellite-farm&quot;, germplasm = paste(&quot;germ&quot;, c(1:6), sep = &quot;:&quot;), controls = &quot;germ:ctrl&quot;, nb.controls.per.block = 2, nb.blocks = 1, nb.cols = 2) p_case3_sf3 = p_case3_sf3$`satellite-farms`$design p_case3_sf3 Figure 3.12: Example of a satellite farm design. p_case3_rf1 = design_experiment( location = &quot;Location-7&quot;, year = &quot;2016&quot;, expe.type = &quot;regional-farm&quot;, germplasm = paste(&quot;germ&quot;, c(1:16), sep = &quot;:&quot;), controls = c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c4&quot;), nb.controls.per.block = 4, nb.blocks = 2, nb.cols = 4) p_case3_rf1 = p_case3_rf1$`regional-farms`$design p_case3_rf1 Figure 3.13: Example of a regional farm design. p_case3_rf2 = design_experiment( location = &quot;Location-8&quot;, year = &quot;2016&quot;, expe.type = &quot;regional-farm&quot;, germplasm = paste(&quot;germ&quot;, c(1:16), sep = &quot;:&quot;), controls = c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;), nb.controls.per.block = 3, nb.blocks = 2, nb.cols = 3) ## Warning in place_controls(d, expe.type): Controls are missing in columns 3. ## You can rise nb.controls.per.block. ## Warning in place_controls(d, expe.type): Controls are missing in rows 2. ## You can rise nb.controls.per.block. ## Warning in place_controls(d, expe.type): Controls are missing in columns 2. ## You can rise nb.controls.per.block. ## Warning in place_controls(d, expe.type): Controls are missing in rows 3. ## You can rise nb.controls.per.block. p_case3_rf2 = p_case3_rf2$`regional-farms`$design p_case3_rf2 Figure 3.14: Example of a regional farm design. If you have enought space and lots of seeds, you can adapt the satellite farm design with only one column. Each row beeing a sower width. Then you must be careful to have several sample for a given row to be as representative as possible. p_case3_sf4 = design_experiment( location = &quot;Location-9&quot;, year = &quot;2016&quot;, expe.type = &quot;satellite-farm&quot;, germplasm = paste(&quot;germ&quot;, c(1:6), sep = &quot;:&quot;), controls = &quot;C&quot;, nb.controls.per.block = 2, nb.blocks = 1, nb.cols = 1) p_case3_sf4 = p_case3_sf4$`satellite-farms`$design p_case3_sf4 Figure 3.15: Example of a satellite farm design. There some constraints regarding expe.type = &quot;satellite-farm&quot;: if nb.entries &gt; 10, a warning message recommands to have less than 10 germplasms or to choose expe.type = &quot;regional-farm&quot;. There are two controls per block There is one block There are maximum two columns For expe.type = &quot;regional-farm&quot;, there is a warning message if controls are missing in rows or columns. It is better to catch as much as possible of the trial variation. If there are less than 2 blocks, an error message is returned. "],
["sow.html", "3.3 Sow, note, harvest, measure …", " 3.3 Sow, note, harvest, measure … PPBstats will not do it for you … but here are some pictures ! Figure 3.16: (Storup 2011) Figure 3.17: (Galic 2011) Figure 3.18: (Rivière 2012a) Figure 3.19: (Rivière 2014) Figure 3.20: (Goldringer 2014) Figure 3.21: (Pin, n.d.) References "],
["describe-data-agro.html", "3.4 Describe the data", " 3.4 Describe the data Once the data have been collected, a first step is to describe them with plot(). Seven types of plot, through the plot_type argument are possible: presence abscence matrix that represent the combinaison of germplasm \\(\\times\\) location histogramm barplot, where sd error are displayed boxplot interaction biplot radar raster map Then you must choose which factor to represent on the x axis (x_axis argument), the factor to display in color (in_col argument), and of course the variables to describe (vec_variables argument). It is possible to tune the number of factor displayed (nb_parameters_per_plot_x_axis and nb_parameters_per_plot_in_col arguments) and the size of the labels regarding biplot and radar (labels_on and labels_size arguments). Note that descriptive plots can be done based on version within the data set. See section 3.8 formore details. 3.4.1 Format the data Get two data set to look at some examples data(&quot;data_model_GxE&quot;) data_model_GxE = format_data_PPBstats(data_model_GxE, type = &quot;data_agro&quot;) ## data has been formated for PPBstats functions. data(&quot;data_model_bh_GxE&quot;) data_model_bh_GxE = format_data_PPBstats(data_model_bh_GxE, type = &quot;data_agro&quot;) ## Warning in format_data_PPBstats.data_agro(data): Column &quot;long&quot; is needed to ## get map and not present in data. ## Warning in format_data_PPBstats.data_agro(data): Column &quot;lat&quot; is needed to ## get map and not present in data. ## data has been formated for PPBstats functions. 3.4.2 presence abscence matrix The presence absence matrix may be different from experimental design planned because of NA. The plot represents the presence/absence matrix of G \\(\\times\\) E combinations. p = plot( data_model_GxE, plot_type = &quot;pam&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;) ) names(p) ## [1] &quot;y1&quot; &quot;y2&quot; p$y1 A score of 3 is for a given germplasm replicated three times in a given environement. p = plot( data_model_bh_GxE, plot_type = &quot;pam&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;) ) p$y1 Here there are lots of 0 meaning that a lot of germplasm are no in at least two locations. A score of 1 is for a given germplasm in a given location. A score of 2 is for a given germplasm replicated twice in a given location. 3.4.3 histogramm p = plot( data_model_GxE, plot_type = &quot;histogramm&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;) ) p$y1 ## $`-NA|-NA` ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 3.4.4 barplot p = plot( data_model_GxE, plot_type = &quot;barplot&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;), x_axis = &quot;germplasm&quot; ) Note that for each element of the following list, there are as many graph as needed with nb_parameters_per_x_axis parameters per graph. names(p$y1) ## [1] &quot;germplasm-1|-NA&quot; &quot;germplasm-2|-NA&quot; &quot;germplasm-3|-NA&quot; &quot;germplasm-4|-NA&quot; p$y1$`germplasm-1|-NA` p = plot( data_model_GxE, plot_type = &quot;barplot&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;), x_axis = &quot;germplasm&quot;, in_col = &quot;location&quot; ) Note that for each element of the following list, there are as many graph as needed with nb_parameters_per_x_axis and nb_parameters_per_in_col parameters per graph. names(p$y1) ## [1] &quot;germplasm-1|location-1&quot; &quot;germplasm-2|location-1&quot; ## [3] &quot;germplasm-3|location-1&quot; &quot;germplasm-4|location-1&quot; p$y1$`germplasm-1|location-1` 3.4.5 boxplot p = plot( data_model_GxE, plot_type = &quot;boxplot&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;), x_axis = &quot;germplasm&quot; ) Note that for each element of the following list, there are as many graph as needed with nb_parameters_per_x_axis parameters per graph. names(p$y1) ## [1] &quot;germplasm-1|-NA&quot; &quot;germplasm-2|-NA&quot; &quot;germplasm-3|-NA&quot; &quot;germplasm-4|-NA&quot; p$y1$`germplasm-1|-NA` p = plot( data_model_GxE, plot_type = &quot;boxplot&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;), x_axis = &quot;germplasm&quot;, in_col = &quot;location&quot; ) Note that for each element of the following list, there are as many graph as needed with nb_parameters_per_x_axis and nb_parameters_per_in_col parameters per graph. names(p$y1) ## [1] &quot;germplasm-1|location-1&quot; &quot;germplasm-2|location-1&quot; ## [3] &quot;germplasm-3|location-1&quot; &quot;germplasm-4|location-1&quot; p$y1$`germplasm-1|location-1` 3.4.6 interaction p = plot( data_model_GxE, plot_type = &quot;interaction&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;), x_axis = &quot;germplasm&quot;, in_col = &quot;location&quot; ) Note that for each element of the following list, there are as many graph as needed with nb_parameters_per_x_axis and nb_parameters_per_in_col parameters per graph. names(p$y1) ## [1] &quot;germplasm-1|location-1&quot; &quot;germplasm-2|location-1&quot; ## [3] &quot;germplasm-3|location-1&quot; &quot;germplasm-4|location-1&quot; p$y1$`germplasm-1|location-1` It is also possible to have on the x_axis the date in julian day that have been automatically calculated from format_data_PPBstats(). Note that this is possible only for plot_type = &quot;histogramm&quot;, &quot;barplot&quot;, &quot;boxplot&quot; and &quot;interaction&quot;. p = plot( data_model_GxE, plot_type = &quot;interaction&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;), x_axis = &quot;date_julian&quot;, in_col = &quot;location&quot; ) ## Warning in plot_descriptive_data(x, plot_type, x_axis, in_col, ## vec_variables, : x_axis = &quot;date_julian&quot; is a special feature that will ## display julian day for a given variable automatically calculated from ## format_data_PPBstats(). p$y1$`y1$date_julian-1|location-1` ## geom_path: Each group consists of only one observation. Do you need to ## adjust the group aesthetic? 3.4.7 biplot p = plot( data_model_GxE, plot_type = &quot;biplot&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;), in_col = &quot;germplasm&quot;, labels_on = &quot;germplasm&quot; ) The name of the list correspond to the pairs of variables displayed. Note that for each element of the following list, there are as many graph as needed with nb_parameters_per_in_col parameters per graph. names(p) ## [1] &quot;y1 - y2&quot; &quot;y1 - y3&quot; &quot;y2 - y3&quot; p$`y1 - y2`$`-NA|germplasm-1` 3.4.8 radar Radar can be display either for all variable and a gien factor: p = plot( data_model_GxE, plot_type = &quot;radar&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;), in_col = &quot;location&quot; ) p ## $`all-variables` or for each variable for two given factors: p = plot( data_model_GxE, plot_type = &quot;radar&quot;, vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;), x_axis = &quot;location&quot;, in_col = &quot;germplasm&quot; ) p$y1 3.4.9 raster Raster plot can be done for factor variables. Note than when there are no single value for a given x_axis, colums block, X and Y are added in order to have single value. p = plot( data_model_GxE, plot_type = &quot;raster&quot;, vec_variables = c(&quot;desease&quot;, &quot;vigor&quot;), x_axis = &quot;germplasm&quot; ) ## Warning in fun_raster(data, vec_variables, x_axis, ## nb_parameters_per_plot_x_axis): There are no single value for each x_axis, ## therefore block, X and Y colums have been added in order to have single ## value. p$`germplasm-block-X-Y-9|-NA` 3.4.10 map You can display map with location if you have data with latitude and longitude for each location. When using map, do not forget to use credit : Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL. p = plot( data_model_GxE, plot_type = &quot;map&quot;, labels_on = &quot;location&quot; ) p$map and add pies for a given variables p = plot( data_model_GxE, vec_variables = c(&quot;y1&quot;, &quot;desease&quot;), plot_type = &quot;map&quot; ) p$pies_on_map_y1 p$pies_on_map_desease "],
["family-1.html", "3.5 Family 1 of analysis : Compare different varieties evaluated for selection in different locations.", " 3.5 Family 1 of analysis : Compare different varieties evaluated for selection in different locations. Family 1 gathers analyses that estimate entry effects. It allows to compare different entries on each location and test for significant differences among entries. Specific analysis including response to selection can also be done. The objective to compare different germplasms on each location for selection. 3.5.1 Decision tree To compare different germplasms on each location for selection, different scenarios are possible (Figure 3.22) : classic anova (M4a, section 3.5.3) based on on fully replicated designs (D1, section 3.2.1), spatial analysis (M4b, section 3.5.4) based on row-column designs (D3, section 3.2.3), mixed models (M5, section3.5.5) for incomplete blocks designs (D2, section 3.2.2), bayesian hierarchical model intra-location (M7a, section 3.5.6) based on satellite-regional farms designs (D4, section 3.2.4). It can be completed by organoleptic analysis (section 4). Based on these analysis, specific objective including response to selection analysis can also be done. Figure 3.22: Decision tree with experimental constraints, designs and methods of agronomic analysis carry out in PPBstats regarding the objective : Compare different varieties evaluated for selection in different locations. D refers to designs and M to methods. 3.5.2 Workflow and function relations in PPBstats regarding family 1 of analysis Figure 3.23 displays the functions and their relationships. Table 3.2 describes each of the main functions. You can have more information for each function by typing ?function_name in your R session. Note that check_model(), mean_comparison() and plot() are S3 method. Therefore, you should type ?check_model, ?mean_comparison or ?plot.PPBstats to have general features and then see in details for specific functions. Figure 3.23: Main functions used in the workflow of family 1. Table 3.2: Function description. function name description design_experiment Provides experimental design for the different situations corresponding to the choosen family of analysis format_data_PPBstats Check and format the data to be used in PPBstats functions model_bh_intra-location Run Hierarchical Bayesian intra-location model model_spatial Run spatial row and column model model_anova Run classic anova model check_model Check if the model went well mean_comparisons Get mean comparisons plot Build ggplot objects to visualize output 3.5.3 Classic ANOVA (M4a) 3.5.3.1 Theory of the model The experimental design used is fully replicated (D1) on one location. The model is based on frequentist statistics (section 3.1.2.1). The tests to check the model are explained in section 3.1.2.1.2. The method to compute mean comparison are explained in section 3.1.2.1.3. The analysis is done the following model : \\(Y_{ijk} = \\mu + \\alpha_{i} + rep_{k} + \\varepsilon_{ijk}; \\quad \\varepsilon_{ijk} \\sim \\mathcal{N} (0,\\sigma^2)\\) With, \\(Y_{ijk}\\) the phenotypic value for replication \\(k\\), germplasm \\(i\\) and individual \\(j\\), \\(\\mu\\) the general mean, \\(\\alpha_{i}\\) the effect of germplasm \\(i\\), \\(rep_{k}\\) the effect of the replication \\(k\\), \\(\\varepsilon_{ijk}\\) the residuals. 3.5.3.2 Steps with PPBstats For classic anova analysis, you can follow these steps (Figure 3.2): Format the data with format_data_PPBstats() Run the model with model_anova() Check model outputs to know if you can continue the analysis with check_model() and vizualise it with plot() Get mean comparisons for each factor with mean_comparisons() and vizualise it with plot() 3.5.3.3 Format the data A subset of data_model_GxE is used in this exemple. data(data_model_GxE) data_model_anova = droplevels(dplyr::filter(data_model_GxE, location == &quot;loc-1&quot;)) data_model_anova = format_data_PPBstats(data_model_anova, type = &quot;data_agro&quot;) ## data has been formated for PPBstats functions. head(data_model_anova) ## seed_lot location long lat year germplasm block ## 1 germ-12_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-12 1 ## 2 germ-1_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-1 1 ## 3 germ-18_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-18 1 ## 4 germ-14_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-14 1 ## 5 germ-6_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-6 1 ## 6 germ-4_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-4 1 ## X Y y1 y1$date y2 y2$date y3 y3$date desease ## 1 A 1 14.32724 2017-07-15 41.85377 2017-07-15 66.05498 2017-07-15 low ## 2 A 2 23.03428 2017-07-15 37.38970 2017-07-15 63.39528 2017-07-15 low ## 3 A 3 24.91349 2017-07-15 38.38628 2017-07-15 60.52710 2017-07-15 high ## 4 A 4 24.99078 2017-07-15 39.72205 2017-07-15 60.80393 2017-07-15 low ## 5 A 5 18.95340 2017-07-15 46.60443 2017-07-15 53.71210 2017-07-15 high ## 6 B 1 21.31660 2017-07-15 49.94656 2017-07-15 60.71978 2017-07-15 medium ## vigor y1$date_julian y2$date_julian y3$date_julian ## 1 l 195 195 195 ## 2 l 195 195 195 ## 3 h 195 195 195 ## 4 l 195 195 195 ## 5 m 195 195 195 ## 6 l 195 195 195 3.5.3.4 Run the model To run model on the dataset, used the function model_anova. You can run it on one variable. out_anova = model_anova(data_model_anova, variable = &quot;y1&quot;) out_anova is a list containing two elements : info : a list with variable out_anova$info ## $variable ## [1] &quot;y1&quot; ANOVA a list with two elements : model out_anova$ANOVA$model ## ## Call: ## stats::lm(formula = variable ~ germplasm + block, data = data) ## ## Coefficients: ## (Intercept) germplasm1 germplasm2 germplasm3 germplasm4 ## 20.26702 1.60183 0.02397 -0.39822 1.21183 ## germplasm5 germplasm6 germplasm7 germplasm8 germplasm9 ## 1.06590 3.76010 -5.10761 -0.92696 2.63546 ## germplasm10 germplasm11 germplasm12 germplasm13 germplasm14 ## 0.42415 1.56248 -5.76240 -4.62059 0.47600 ## germplasm15 germplasm16 germplasm17 germplasm18 germplasm19 ## 1.43492 -1.55346 0.89022 0.39441 1.16307 ## block1 block2 ## -0.93928 -0.22936 anova_model out_anova$ANOVA$anova_model ## Analysis of Variance Table ## ## Response: variable ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## germplasm 19 361.54 19.028 0.5090 0.9414 ## block 2 46.01 23.006 0.6154 0.5457 ## Residuals 38 1420.67 37.386 germplasm_effects a list of two elements : effects out_anova$ANOVA$germplasm_effects$effects ## germ-1 germ-10 germ-11 germ-12 germ-13 germ-14 ## 1.60183489 0.02396579 -0.39821799 1.21183407 1.06590372 3.76009917 ## germ-15 germ-16 germ-17 germ-18 germ-19 germ-2 ## -5.10761419 -0.92695642 2.63546203 0.42415203 1.56247594 -5.76239571 ## germ-20 germ-3 germ-4 germ-5 germ-6 germ-7 ## -4.62059183 0.47600360 1.43491926 -1.55346262 0.89022028 0.39441135 ## germ-8 germ-9 ## 1.16306897 1.72488766 intra_variance out_anova$ANOVA$germplasm_effects$intra_variance ## germ-1 germ-10 germ-11 germ-12 germ-13 germ-14 ## 14.550965 204.517046 28.558887 45.376513 51.105885 3.216895 ## germ-15 germ-16 germ-17 germ-18 germ-19 germ-2 ## 21.434155 19.650429 28.827606 24.862755 80.733922 2.938909 ## germ-20 germ-3 germ-4 germ-5 germ-6 germ-7 ## 17.722408 43.102002 10.437349 37.931023 13.113586 44.667769 ## germ-8 germ-9 ## 7.226053 10.361250 3.5.3.5 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.1.2. 3.5.3.5.1 Check the model Once the model is run, it is necessary to check if the outputs can be taken with confidence. This step is needed before going ahead in the analysis (in fact, object used in the next functions must come from check_model()). out_check_anova = check_model(out_anova) out_check_anova is a list containing four elements : info : a list with variable model_anova the output from the model data_ggplot a list containing information for ggplot: data_ggplot_residuals a list containing : data_ggplot_normality data_ggplot_skewness_test data_ggplot_kurtosis_test data_ggplot_shapiro_test data_ggplot_qqplot data_ggplot_variability_repartition_pie data_ggplot_var_intra 3.5.3.5.2 Visualize outputs Once the computation is done, you can visualize the results with plot() p_out_check_anova = plot(out_check_anova) p_out_check_anova is a list with: residuals histogram : histogram with the distribution of the residuals p_out_check_anova$residuals$histogram ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qqplot p_out_check_anova$residuals$qqplot points p_out_check_anova$residuals$points variability_repartition : pie with repartition of SumSq for each factor p_out_check_anova$variability_repartition variance_intra_germplasm : repartition of the residuals for each germplasm (see Details for more information) With the hypothesis than the micro-environmental variation is equaly distributed on all the individuals (i.e. all the plants), the distribution of each germplasm represent the intra-germplasm variance. This has to been seen with caution: If germplasm have no intra-germplasm variance (i.e. pure line or hybrides) then the distribution of each germplasm represent only the micro-environmental variation. If germplasm have intra-germplasm variance (i.e. population such as landraces for example) then the distribution of each germplasm represent the micro-environmental variation plus the intra-germplasm variance. p_out_check_anova$variance_intra_germplasm 3.5.3.6 Get and visualize mean comparisons The method to compute mean comparison are explained in section 3.1.2.1.3. 3.5.3.6.1 Get mean comparisons Get mean comparisons with mean_comparisons(). out_mean_comparisons_anova = mean_comparisons(out_check_anova, p.adj = &quot;bonferroni&quot;) out_mean_comparisons_anova is a list of two elements: info : a list with variable data_ggplot_LSDbarplot_germplasm 3.5.3.6.2 Visualize mean comparisons p_out_mean_comparisons_anova = plot(out_mean_comparisons_anova) p_out_mean_comparisons_anova is a list of one element with barplots : For each element of the list, there are as many graph as needed with nb_parameters_per_plot parameters per graph. Letters are displayed on each bar. Parameters that do not share the same letters are different regarding type I error (alpha) and alpha correction. The error I (alpha) and the alpha correction are displayed in the title. germplasm : mean comparison for germplasm pg = p_out_mean_comparisons_anova$germplasm names(pg) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; pg$`1` 3.5.3.7 Get and vizualise groups of parameters 3.5.3.7.1 Get groups of parameters In order to cluster locations or germplasms, you may use mulivariate analysis on a matrix with several variables in columns and parameter in rows. This is done with parameter_groups() which do a PCA on this matrix. Clusters are done based on HCPC method as explained here Lets’ have an example with three variables. First run the models out_anova_2 = model_anova(data_model_anova, variable = &quot;y2&quot;) out_anova_3 = model_anova(data_model_anova, variable = &quot;y3&quot;) Then check the models out_check_anova_2 = check_model(out_anova_2) out_check_anova_3 = check_model(out_anova_3) Then run the function for germplasm. out_parameter_groups = parameter_groups( list(&quot;y1&quot; = out_check_anova, &quot;y2&quot; = out_check_anova_2, &quot;y3&quot; = out_check_anova_3), &quot;germplasm&quot; ) out_parameter_groups is list of two elements: obj.pca : the PCA object from FactoMineR::PCA() clust, a list of two elements: res.hcpc : the HCPC object from FactoMineR::HCPC() clust : the dataframe with cluster assigned to each individual 3.5.3.7.2 Visualize groups of parameters Visualize outputs with plot p_germplasm_group = plot(out_parameter_groups) p_germplasm_group is list of two elements : pca : a list with three elements on the PCA on the group of parameters : composante_variance : variance caught by each dimension of the PCA p_germplasm_group$pca$composante_variance ind : graph of individuals p_germplasm_group$pca$ind var : graph of variables p_germplasm_group$pca$var clust : output from factextra::fviz_cluster(), a list of number of cluster + 1 element cl = p_germplasm_group$clust names(cl) ## [1] &quot;cluster_all&quot; &quot;cluster_1&quot; &quot;cluster_2&quot; &quot;cluster_3&quot; cl$cluster_all cl$cluster_1 ## Warning: Removed 3 rows containing non-finite values (stat_mean). ## Warning: Removed 3 rows containing missing values (geom_point). ## Warning: Removed 3 rows containing missing values (geom_text_repel). 3.5.3.8 post hoc analysis to visualize variation repartition for several variables list_out_check_model = list(&quot;anova_1&quot; = out_check_anova, &quot;anova_2&quot; = out_check_anova_2, &quot;anova_3&quot; = out_check_anova_3) post_hoc_variation(list_out_check_model) 3.5.3.9 Apply the workflow to several variables If you wish to apply the AMMI workflow to several variables, you can use lapply() with the following code : workflow_anova = function(x, data){ out_anova = model_anova(data, variable = x) out_check_anova = check_model(out_anova) p_out_check_anova = plot(out_check_anova) out_mean_comparisons_anova = mean_comparisons(out_check_anova, p.adj = &quot;bonferroni&quot;) p_out_mean_comparisons_anova = plot(out_mean_comparisons_anova) out = list( &quot;out_anova&quot; = out_anova, &quot;out_check_anova&quot; = out_check_anova, &quot;p_out_check_anova&quot; = p_out_check_anova, &quot;out_mean_comparisons_anova&quot; = out_mean_comparisons_anova, &quot;p_out_mean_comparisons_anova&quot; = p_out_mean_comparisons_anova ) return(out) } vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;) out = lapply(vec_variables, workflow_anova, data_model_anova) names(out) = vec_variables list_out_check_model = list(&quot;anova_1&quot; = out$y1$out_check_anova, &quot;anova_2&quot; = out$y2$out_check_anova, &quot;anova_3&quot; = out$y3$out_check_anova) out_parameter_groups = parameter_groups(list_out_check_model, &quot;germplasm&quot; ) p_germplasm_group = plot(out_parameter_groups) p_post_hoc_variation = post_hoc_variation(list_out_check_model) 3.5.4 Spatial analysis (M4b) 3.5.4.1 Theory of the model The experimental design used is the row-column design (D3). The following model is based on frequentist statistics (section 3.1.2.1). The model allows taking into account environmental variation within a block with few control replicated in rows and columns. It is based on a SpATS (Spatial Analysis of Field Trials with Splines) model proposed by Rodrı'guez-Álvarez et al. (2016) : \\(Y_{ijk} = \\alpha_{i} + r_{j} + c_{k} + f(u,v) + \\varepsilon_{ijk}; \\quad \\varepsilon_{ijk} \\sim \\mathcal{N} (0,\\sigma^2)\\) With, \\(Y_{ijk}\\) the phenotypic value for germplasm \\(i\\), row \\(j\\) and column \\(k\\) \\(\\alpha_{i}\\) the random effect of germplasm \\(i\\) \\(r_{j}\\) the effect of row \\(j\\) \\(c_{k}\\) the effect of col \\(k\\) \\(f(u,v)\\) the smooth bivariate function that simultaneously accounts for the spatial trend across both directions of the fiel (i.e. rows and columns) \\(\\varepsilon_{ijk}\\) the residuals Note that \\(f(u,v)\\) is divided into 8 components excluding the intercept (Rodrı'guez-Álvarez et al. 2016): the linear effect of the rows (row), the linear effect of the columns (col), the linear interaction of rows and columns (row:col), the main row effect (f(row)), the main column effect (f(col)), the smooth varying coefficient term regarding rows (f(col):row), the smooth varying coefficient term regarding columns (row:f(col))), the smooth-by-smooth interaction component (f(col):f(row)) Much more information regarding the model as well as example of R package SpATS can be found in Rodrı'guez-Álvarez et al. (2016). 3.5.4.2 Steps with PPBstats Format the data with format_data_PPBstats() Run the model with model_spatial() Check model outputs with graphs to know if you can continue the analysis with check_model() and vizualise it with plot() Get mean comparisons for germplasms with mean_comparisons() and vizualise it with plot() 3.5.4.3 Format the data data(&quot;data_model_spatial&quot;) data_model_spatial = format_data_PPBstats(data_model_spatial, type = &quot;data_agro&quot;) ## Warning in format_data_PPBstats.data_agro(data): Column &quot;long&quot; is needed to ## get map and not present in data. ## Warning in format_data_PPBstats.data_agro(data): Column &quot;lat&quot; is needed to ## get map and not present in data. ## data has been formated for PPBstats functions. 3.5.4.4 Run the model By default, germplasm are settled as random. out_spatial = model_spatial(data = data_model_spatial, variable = &quot;y1&quot;) ## Effective dimensions ## ------------------------- ## It. Deviance germplasm col_f row_f f(col) f(row) f(col):row col:f(row)f(col):f(row) ## 1 499915783.828728 40.302 0.366 0.191 9.650 0.138 7.750 0.131 2.748 ## 2 1810.537704 43.464 0.378 0.143 7.328 0.155 6.301 0.282 2.305 ## 3 1805.922367 45.867 0.387 0.139 6.084 0.228 5.185 0.526 1.927 ## 4 1802.131778 47.949 0.400 0.148 5.210 0.352 4.138 0.747 1.768 ## 5 1798.314988 49.937 0.420 0.156 4.466 0.507 3.053 0.866 1.795 ## 6 1794.244331 51.894 0.445 0.153 3.756 0.645 1.907 0.922 1.977 ## 7 1790.398147 53.762 0.476 0.142 3.017 0.740 0.844 0.958 2.303 ## 8 1787.563839 55.436 0.512 0.128 2.202 0.799 0.117 0.986 2.759 ## 9 1785.425510 56.826 0.551 0.115 1.311 0.841 0.006 1.008 3.299 ## 10 1783.781636 58.206 0.589 0.105 0.443 0.871 0.000 1.025 3.835 ## 11 1783.208754 59.401 0.614 0.098 0.046 0.889 0.000 1.035 4.260 ## 12 1783.062960 60.434 0.631 0.094 0.003 0.900 0.000 1.043 4.591 ## 13 1782.967780 61.461 0.645 0.091 0.000 0.907 0.000 1.048 4.866 ## 14 1782.883251 62.499 0.660 0.090 0.000 0.912 0.000 1.052 5.091 ## 15 1782.804649 63.543 0.674 0.090 0.000 0.916 0.000 1.056 5.275 ## 16 1782.730232 64.587 0.688 0.091 0.000 0.918 0.000 1.059 5.423 ## 17 1782.658970 65.625 0.702 0.093 0.000 0.919 0.000 1.062 5.543 ## 18 1782.590255 66.652 0.715 0.095 0.000 0.919 0.000 1.065 5.640 ## 19 1782.523756 67.663 0.728 0.099 0.000 0.918 0.000 1.068 5.720 ## 20 1782.459310 68.655 0.741 0.103 0.000 0.916 0.000 1.070 5.786 ## 21 1782.396860 69.624 0.753 0.108 0.000 0.914 0.000 1.072 5.843 ## 22 1782.336404 70.567 0.764 0.114 0.000 0.911 0.000 1.075 5.893 ## 23 1782.277969 71.482 0.775 0.120 0.000 0.907 0.000 1.077 5.938 ## 24 1782.221594 72.366 0.786 0.128 0.000 0.903 0.000 1.079 5.980 ## 25 1782.167314 73.220 0.796 0.137 0.000 0.898 0.000 1.082 6.020 ## 26 1782.115161 74.040 0.805 0.147 0.000 0.892 0.000 1.084 6.058 ## 27 1782.065153 74.827 0.814 0.158 0.000 0.886 0.000 1.086 6.096 ## 28 1782.017297 75.580 0.823 0.170 0.000 0.879 0.000 1.089 6.135 ## 29 1781.971586 76.299 0.830 0.184 0.000 0.871 0.000 1.091 6.173 ## 30 1781.928002 76.985 0.837 0.199 0.000 0.863 0.000 1.094 6.212 ## 31 1781.886515 77.636 0.844 0.215 0.000 0.853 0.000 1.097 6.253 ## 32 1781.847089 78.255 0.850 0.233 0.000 0.843 0.000 1.099 6.294 ## 33 1781.809681 78.842 0.855 0.251 0.000 0.832 0.000 1.102 6.336 ## 34 1781.774244 79.398 0.860 0.272 0.000 0.821 0.000 1.104 6.378 ## 35 1781.740730 79.923 0.864 0.293 0.000 0.809 0.000 1.107 6.422 ## 36 1781.709090 80.420 0.868 0.315 0.000 0.796 0.000 1.110 6.466 ## 37 1781.679272 80.890 0.871 0.338 0.000 0.782 0.000 1.112 6.511 ## 38 1781.651224 81.333 0.873 0.361 0.000 0.769 0.000 1.115 6.556 ## 39 1781.624892 81.752 0.875 0.384 0.000 0.755 0.000 1.118 6.601 ## 40 1781.600217 82.147 0.876 0.408 0.000 0.740 0.000 1.120 6.647 ## 41 1781.577140 82.520 0.876 0.431 0.000 0.726 0.000 1.123 6.692 ## 42 1781.555595 82.873 0.876 0.455 0.000 0.712 0.000 1.125 6.737 ## 43 1781.535515 83.206 0.875 0.478 0.000 0.698 0.000 1.128 6.781 ## 44 1781.516828 83.520 0.874 0.500 0.000 0.684 0.000 1.130 6.824 ## 45 1781.499462 83.817 0.872 0.522 0.000 0.670 0.000 1.132 6.867 ## 46 1781.483344 84.097 0.870 0.543 0.000 0.656 0.000 1.135 6.909 ## 47 1781.468399 84.363 0.867 0.563 0.000 0.643 0.000 1.137 6.950 ## 48 1781.454555 84.613 0.864 0.583 0.000 0.630 0.000 1.139 6.989 ## 49 1781.441740 84.850 0.860 0.602 0.000 0.618 0.000 1.141 7.028 ## 50 1781.429885 85.074 0.856 0.620 0.000 0.606 0.000 1.143 7.066 ## 51 1781.418924 85.286 0.851 0.638 0.000 0.594 0.000 1.145 7.102 ## 52 1781.408793 85.486 0.846 0.655 0.000 0.583 0.000 1.146 7.137 ## 53 1781.399431 85.676 0.840 0.671 0.000 0.572 0.000 1.148 7.172 ## 54 1781.390781 85.855 0.835 0.686 0.000 0.561 0.000 1.150 7.205 ## 55 1781.382789 86.025 0.829 0.701 0.000 0.551 0.000 1.151 7.237 ## 56 1781.375404 86.186 0.822 0.716 0.000 0.541 0.000 1.153 7.267 ## 57 1781.368579 86.339 0.816 0.730 0.000 0.531 0.000 1.154 7.297 ## 58 1781.362271 86.483 0.809 0.743 0.000 0.522 0.000 1.156 7.326 ## 59 1781.356438 86.621 0.802 0.756 0.000 0.513 0.000 1.157 7.353 ## 60 1781.351042 86.751 0.795 0.768 0.000 0.504 0.000 1.158 7.380 ## 61 1781.346049 86.875 0.787 0.780 0.000 0.496 0.000 1.159 7.406 ## 62 1781.341425 86.993 0.780 0.792 0.000 0.487 0.000 1.160 7.430 ## 63 1781.337142 87.105 0.772 0.803 0.000 0.480 0.000 1.162 7.454 ## 64 1781.333172 87.212 0.764 0.813 0.000 0.472 0.000 1.163 7.477 ## 65 1781.329489 87.313 0.756 0.823 0.000 0.464 0.000 1.164 7.499 ## 66 1781.326070 87.410 0.748 0.833 0.000 0.457 0.000 1.165 7.521 ## 67 1781.322895 87.502 0.740 0.843 0.000 0.450 0.000 1.166 7.541 ## 68 1781.319943 87.591 0.732 0.852 0.000 0.444 0.000 1.166 7.561 ## 69 1781.317197 87.675 0.724 0.861 0.000 0.437 0.000 1.167 7.580 ## 70 1781.314640 87.755 0.716 0.869 0.000 0.431 0.000 1.168 7.599 ## 71 1781.312258 87.832 0.707 0.878 0.000 0.425 0.000 1.169 7.617 ## 72 1781.310036 87.906 0.699 0.886 0.000 0.419 0.000 1.170 7.634 ## 73 1781.307962 87.976 0.691 0.893 0.000 0.413 0.000 1.170 7.650 ## 74 1781.306024 88.044 0.682 0.901 0.000 0.408 0.000 1.171 7.666 ## 75 1781.304213 88.109 0.674 0.908 0.000 0.402 0.000 1.172 7.682 ## 76 1781.302517 88.171 0.665 0.915 0.000 0.397 0.000 1.172 7.697 ## 77 1781.300929 88.231 0.657 0.921 0.000 0.392 0.000 1.173 7.711 ## 78 1781.299441 88.288 0.649 0.928 0.000 0.387 0.000 1.174 7.725 ## 79 1781.298044 88.343 0.640 0.934 0.000 0.383 0.000 1.174 7.738 ## 80 1781.296731 88.396 0.632 0.940 0.000 0.378 0.000 1.175 7.751 ## 81 1781.295498 88.447 0.624 0.946 0.000 0.373 0.000 1.175 7.764 ## 82 1781.294337 88.496 0.616 0.952 0.000 0.369 0.000 1.176 7.776 ## 83 1781.293245 88.543 0.607 0.957 0.000 0.365 0.000 1.176 7.788 ## 84 1781.292215 88.589 0.599 0.963 0.000 0.361 0.000 1.177 7.799 ## 85 1781.291243 88.633 0.591 0.968 0.000 0.357 0.000 1.177 7.810 ## Timings: ## SpATS 10.806 seconds ## All process 10.939 seconds ## ## Spatial analysis of trials with splines ## ## Response: variable ## Genotypes (as random): germplasm ## Spatial: ~PSANOVA(col, row, nseg = c(nlevels(data_tmp$X), nlevels(data_tmp$Y))) ## Random: ~col_f + row_f ## ## ## Number of observations: 107 ## Number of missing data: 104 ## Effective dimension: 103.54 ## Deviance: 1781.291 ## ## Dimensions: ## Effective Model Nominal Ratio Type ## Intercept 1.0 1 1 1.00 F ## germplasm 88.6 104 102 0.87 R ## col_f 0.6 54 49 0.01 R ## row_f 1.0 4 2 0.48 R ## col 1.0 1 1 1.00 S ## row 1.0 1 1 1.00 S ## rowcol 1.0 1 1 1.00 S ## f(col) 0.0 55 55 0.00 S ## f(row) 0.4 5 5 0.07 S ## f(col):row 0.0 55 55 0.00 S ## col:f(row) 1.2 5 5 0.24 S ## f(col):f(row) 7.8 275 275 0.03 S ## ## Total 103.5 561 552 0.19 ## Residual 3.5 ## Nobs 107 ## ## Type codes: F &#39;Fixed&#39; R &#39;Random&#39; S &#39;Smooth/Semiparametric&#39; ## ## ## Spatial analysis of trials with splines ## ## Response: variable ## Genotypes (as random): germplasm ## Spatial: ~PSANOVA(col, row, nseg = c(nlevels(data_tmp$X), nlevels(data_tmp$Y))) ## Random: ~col_f + row_f ## ## ## Number of observations: 107 ## Number of missing data: 104 ## Effective dimension: 103.54 ## Deviance: 1781.291 ## ## Dimensions: ## Effective Model Nominal Ratio Type ## Intercept 1.0 1 1 1.00 F ## germplasm 88.6 104 102 0.87 R ## col_f 0.6 54 49 0.01 R ## row_f 1.0 4 2 0.48 R ## col 1.0 1 1 1.00 S ## row 1.0 1 1 1.00 S ## rowcol 1.0 1 1 1.00 S ## f(col) 0.0 55 55 0.00 S ## f(row) 0.4 5 5 0.07 S ## f(col):row 0.0 55 55 0.00 S ## col:f(row) 1.2 5 5 0.24 S ## f(col):f(row) 7.8 275 275 0.03 S ## ## Total 103.5 561 552 0.19 ## Residual 3.5 ## Nobs 107 ## ## Type codes: F &#39;Fixed&#39; R &#39;Random&#39; S &#39;Smooth/Semiparametric&#39; out_spatial is a list containing two elements : info : a list with variable and data out_spatial$info$variable ## [1] &quot;y1&quot; head(out_spatial$info$data) ## seed_lot location year germplasm block X Y y1 y2 ## 1 germ-1_loc-1_2018_0001 loc-1 2018 germ-1 1 1 1 18132.88 18 ## 2 germ-2_loc-1_2018_0001 loc-1 2018 germ-2 1 2 1 19910.61 20 ## 3 germ-3_loc-1_2018_0001 loc-1 2018 germ-3 1 3 1 19575.27 25 ## 4 germ-4_loc-1_2018_0001 loc-1 2018 germ-4 1 4 1 19098.78 22 ## 5 germ-29_loc-1_2018_0001 loc-1 2018 germ-29 1 5 1 NA NA ## 6 germ-30_loc-1_2018_0001 loc-1 2018 germ-30 1 6 1 NA NA ## y3 ## 1 312 ## 2 275 ## 3 267 ## 4 256 ## 5 NA ## 6 NA model a list with four elements : model out_spatial$model$model ## ## Spatial analysis of trials with splines ## ## Response: variable ## Genotypes (as random): germplasm ## Spatial: ~PSANOVA(col, row, nseg = c(nlevels(data_tmp$X), nlevels(data_tmp$Y))) ## Random: ~col_f + row_f ## ## ## Number of observations: 107 ## Number of missing data: 104 ## Effective dimension: 103.54 ## Deviance: 1781.291 summary out_spatial$model$summary ## ## Spatial analysis of trials with splines ## ## Response: variable ## Genotypes (as random): germplasm ## Spatial: ~PSANOVA(col, row, nseg = c(nlevels(data_tmp$X), nlevels(data_tmp$Y))) ## Random: ~col_f + row_f ## ## ## Number of observations: 107 ## Number of missing data: 104 ## Effective dimension: 103.54 ## Deviance: 1781.291 ## ## Dimensions: ## Effective Model Nominal Ratio Type ## Intercept 1.0 1 1 1.00 F ## germplasm 88.6 104 102 0.87 R ## col_f 0.6 54 49 0.01 R ## row_f 1.0 4 2 0.48 R ## col 1.0 1 1 1.00 S ## row 1.0 1 1 1.00 S ## rowcol 1.0 1 1 1.00 S ## f(col) 0.0 55 55 0.00 S ## f(row) 0.4 5 5 0.07 S ## f(col):row 0.0 55 55 0.00 S ## col:f(row) 1.2 5 5 0.24 S ## f(col):f(row) 7.8 275 275 0.03 S ## ## Total 103.5 561 552 0.19 ## Residual 3.5 ## Nobs 107 ## ## Type codes: F &#39;Fixed&#39; R &#39;Random&#39; S &#39;Smooth/Semiparametric&#39; var_res the variance of the residuals out_spatial$model$df_residual ## [1] 3.5 out_spatial$model$MSerror ## [1] 508.9404 3.5.4.5 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.1.2. 3.5.4.5.1 Check the model out_check_spatial = check_model(out_spatial) out_check_spatial is a list containing two elements : spatial the output from the model data_ggplot a list containing information for ggplot: data_ggplot_residuals a list containing : data_ggplot_normality data_ggplot_skewness_test data_ggplot_kurtosis_test data_ggplot_shapiro_test data_ggplot_qqplot data_ggplot_variability_repartition_pie 3.5.4.5.2 Visualize outputs Once the computation is done, you can visualize the results with plot p_out_check_spatial = plot(out_check_spatial) p_out_check_spatial is a list with: residuals histogram : histogram with the distribution of the residuals p_out_check_spatial$residuals$histogram ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qqplot p_out_check_spatial$residuals$qqplot points p_out_check_spatial$residuals$points variability_repartition : pie with repartition of variance for each factor p_out_check_spatial$variability_repartition 3.5.4.6 Get and visualize mean comparisons The method to compute mean comparison are explained in section 3.1.2.1.3. 3.5.4.7 Get mean comparisons Get mean comparisons with mean_comparisons. out_mean_comparisons_spatial = mean_comparisons(out_check_spatial, p.adj = &quot;bonferroni&quot;) out_mean_comparisons_spatial is a list of two elements: info : a list with variable and data data_ggplot_LSDbarplot_germplasm 3.5.4.8 Visualize mean comparisons p_out_mean_comparisons_spatial = plot(out_mean_comparisons_spatial) p_out_mean_comparisons_spatial is a list of two elements germplasm_blup whih represent the BLUPs with their confidence intervalle p_out_mean_comparisons_spatial$germplasm_blup germplasm_barplot. For each element of the list, there are as many graph as needed with nb_parameters_per_plot parameters per graph. Letters are displayed on each bar. Parameters that do not share the same letters are different regarding type I error (alpha) and alpha correction. The error I (alpha) and the alpha correction are displayed in the title. pg = p_out_mean_comparisons_spatial$germplasm_barplot pg$`23` ## NULL 3.5.4.9 Get and vizualise groups of parameters 3.5.4.9.1 Get groups of parameters In order to cluster locations or germplasms, you may use mulivariate analysis on a matrix with several variables in columns and parameter in rows. This is done with parameter_groups() which do a PCA on this matrix. Clusters are done based on HCPC method as explained here Lets’ have an example with three variables. First run the models out_spatial_2 = model_spatial(data_model_spatial, variable = &quot;y2&quot;) ## Effective dimensions ## ------------------------- ## It. Deviance germplasm col_f row_f f(col) f(row) f(col):row col:f(row)f(col):f(row) ## 1 752.878073 41.911 0.387 0.210 9.825 0.150 7.982 0.141 2.912 ## 2 419.535807 43.966 0.522 0.089 7.493 0.098 5.947 0.417 2.641 ## 3 410.398567 45.608 0.694 0.040 5.722 0.066 4.341 0.843 2.355 ## 4 404.258754 47.135 0.902 0.018 4.512 0.047 2.945 1.101 2.175 ## 5 400.833985 48.557 1.137 0.009 3.686 0.033 1.963 1.168 2.059 ## 6 398.742890 49.897 1.401 0.005 3.037 0.025 1.348 1.183 1.957 ## 7 397.045030 51.238 1.700 0.003 2.449 0.019 0.873 1.189 1.861 ## 8 395.573882 52.604 2.041 0.002 1.898 0.015 0.436 1.193 1.761 ## 9 394.530274 53.904 2.428 0.001 1.424 0.012 0.139 1.193 1.638 ## 10 393.941514 55.056 2.856 0.001 1.070 0.010 0.032 1.191 1.490 ## 11 393.627428 56.073 3.319 0.000 0.841 0.009 0.006 1.189 1.337 ## 12 393.432742 56.975 3.809 0.000 0.708 0.008 0.001 1.188 1.193 ## 13 393.282401 57.783 4.326 0.000 0.632 0.007 0.000 1.187 1.068 ## 14 393.150564 58.512 4.865 0.000 0.587 0.006 0.000 1.187 0.961 ## 15 393.029292 59.171 5.423 0.000 0.562 0.006 0.000 1.188 0.871 ## 16 392.916391 59.771 5.995 0.000 0.547 0.005 0.000 1.188 0.795 ## 17 392.811570 60.316 6.572 0.000 0.539 0.004 0.000 1.189 0.731 ## 18 392.715148 60.813 7.148 0.000 0.536 0.004 0.000 1.191 0.678 ## 19 392.627537 61.268 7.715 0.000 0.535 0.003 0.000 1.192 0.633 ## 20 392.549019 61.686 8.265 0.000 0.536 0.003 0.000 1.193 0.596 ## 21 392.479639 62.072 8.792 0.000 0.537 0.003 0.000 1.195 0.565 ## 22 392.419185 62.431 9.290 0.000 0.540 0.002 0.000 1.196 0.540 ## 23 392.367204 62.768 9.756 0.000 0.542 0.002 0.000 1.197 0.520 ## 24 392.323049 63.084 10.186 0.000 0.545 0.002 0.000 1.198 0.504 ## 25 392.285947 63.384 10.578 0.000 0.548 0.001 0.000 1.200 0.491 ## 26 392.255057 63.669 10.933 0.000 0.550 0.001 0.000 1.201 0.482 ## 27 392.229526 63.941 11.250 0.000 0.553 0.001 0.000 1.202 0.475 ## 28 392.208541 64.201 11.532 0.000 0.555 0.001 0.000 1.203 0.471 ## 29 392.191351 64.450 11.779 0.000 0.557 0.001 0.000 1.204 0.469 ## 30 392.177291 64.689 11.996 0.000 0.559 0.000 0.000 1.205 0.469 ## 31 392.165782 64.918 12.184 0.000 0.560 0.000 0.000 1.206 0.471 ## 32 392.156339 65.137 12.346 0.000 0.562 0.000 0.000 1.207 0.474 ## 33 392.148555 65.347 12.485 0.000 0.563 0.000 0.000 1.207 0.479 ## 34 392.142101 65.547 12.604 0.000 0.564 0.000 0.000 1.208 0.486 ## 35 392.136708 65.738 12.705 0.000 0.565 0.000 0.000 1.209 0.494 ## 36 392.132161 65.919 12.790 0.000 0.566 0.000 0.000 1.209 0.503 ## 37 392.128290 66.091 12.861 0.000 0.567 0.000 0.000 1.210 0.513 ## 38 392.124956 66.254 12.921 0.000 0.568 0.000 0.000 1.210 0.524 ## 39 392.122055 66.408 12.971 0.000 0.569 0.000 0.000 1.211 0.536 ## 40 392.119499 66.554 13.013 0.000 0.570 0.000 0.000 1.211 0.549 ## 41 392.117222 66.691 13.047 0.000 0.570 0.000 0.000 1.212 0.564 ## 42 392.115170 66.821 13.076 0.000 0.571 0.000 0.000 1.212 0.579 ## 43 392.113302 66.943 13.099 0.000 0.571 0.000 0.000 1.213 0.594 ## 44 392.111583 67.058 13.119 0.000 0.572 0.000 0.000 1.213 0.611 ## 45 392.109986 67.166 13.134 0.000 0.572 0.000 0.000 1.213 0.628 ## 46 392.108492 67.268 13.147 0.000 0.573 0.000 0.000 1.214 0.646 ## 47 392.107082 67.363 13.158 0.000 0.573 0.000 0.000 1.214 0.665 ## 48 392.105743 67.453 13.167 0.000 0.574 0.000 0.000 1.214 0.684 ## 49 392.104465 67.537 13.174 0.000 0.574 0.000 0.000 1.215 0.704 ## 50 392.103239 67.617 13.180 0.000 0.574 0.000 0.000 1.215 0.725 ## 51 392.102059 67.691 13.185 0.000 0.575 0.000 0.000 1.215 0.746 ## 52 392.100918 67.761 13.189 0.000 0.575 0.000 0.000 1.216 0.767 ## 53 392.099814 67.828 13.193 0.000 0.575 0.000 0.000 1.216 0.789 ## 54 392.098743 67.890 13.197 0.000 0.576 0.000 0.000 1.216 0.811 ## 55 392.097702 67.949 13.200 0.000 0.576 0.000 0.000 1.216 0.834 ## 56 392.096690 68.005 13.203 0.000 0.576 0.000 0.000 1.217 0.857 ## 57 392.095706 68.057 13.206 0.000 0.576 0.000 0.000 1.217 0.880 ## Timings: ## SpATS 7.208 seconds ## All process 7.629 seconds ## ## Spatial analysis of trials with splines ## ## Response: variable ## Genotypes (as random): germplasm ## Spatial: ~PSANOVA(col, row, nseg = c(nlevels(data_tmp$X), nlevels(data_tmp$Y))) ## Random: ~col_f + row_f ## ## ## Number of observations: 112 ## Number of missing data: 99 ## Effective dimension: 87.94 ## Deviance: 392.096 ## ## Dimensions: ## Effective Model Nominal Ratio Type ## Intercept 1.0 1 1 1.00 F ## germplasm 68.1 107 106 0.64 R ## col_f 13.2 54 50 0.26 R ## row_f 0.0 4 2 0.00 R ## col 1.0 1 1 1.00 S ## row 1.0 1 1 1.00 S ## rowcol 1.0 1 1 1.00 S ## f(col) 0.6 55 55 0.01 S ## f(row) 0.0 5 5 0.00 S ## f(col):row 0.0 55 55 0.00 S ## col:f(row) 1.2 5 5 0.24 S ## f(col):f(row) 0.9 275 275 0.00 S ## ## Total 87.9 564 557 0.16 ## Residual 24.1 ## Nobs 112 ## ## Type codes: F &#39;Fixed&#39; R &#39;Random&#39; S &#39;Smooth/Semiparametric&#39; ## ## ## Spatial analysis of trials with splines ## ## Response: variable ## Genotypes (as random): germplasm ## Spatial: ~PSANOVA(col, row, nseg = c(nlevels(data_tmp$X), nlevels(data_tmp$Y))) ## Random: ~col_f + row_f ## ## ## Number of observations: 112 ## Number of missing data: 99 ## Effective dimension: 87.94 ## Deviance: 392.096 ## ## Dimensions: ## Effective Model Nominal Ratio Type ## Intercept 1.0 1 1 1.00 F ## germplasm 68.1 107 106 0.64 R ## col_f 13.2 54 50 0.26 R ## row_f 0.0 4 2 0.00 R ## col 1.0 1 1 1.00 S ## row 1.0 1 1 1.00 S ## rowcol 1.0 1 1 1.00 S ## f(col) 0.6 55 55 0.01 S ## f(row) 0.0 5 5 0.00 S ## f(col):row 0.0 55 55 0.00 S ## col:f(row) 1.2 5 5 0.24 S ## f(col):f(row) 0.9 275 275 0.00 S ## ## Total 87.9 564 557 0.16 ## Residual 24.1 ## Nobs 112 ## ## Type codes: F &#39;Fixed&#39; R &#39;Random&#39; S &#39;Smooth/Semiparametric&#39; out_spatial_3 = model_spatial(data_model_spatial, variable = &quot;y3&quot;) ## Effective dimensions ## ------------------------- ## It. Deviance germplasm col_f row_f f(col) f(row) f(col):row col:f(row)f(col):f(row) ## 1 76730.878077 42.736 0.414 0.218 10.013 0.155 8.064 0.152 3.158 ## 2 978.299650 46.606 0.537 0.097 6.537 0.055 5.770 0.147 3.335 ## 3 968.603398 49.218 0.656 0.061 4.472 0.031 4.096 0.098 3.435 ## 4 961.162214 50.901 0.783 0.043 2.965 0.020 2.695 0.052 3.634 ## 5 956.556509 51.807 0.923 0.030 1.702 0.012 1.766 0.025 3.886 ## 6 954.992653 51.910 1.068 0.019 0.935 0.007 1.501 0.012 4.046 ## 7 954.339333 51.676 1.222 0.012 0.438 0.005 1.449 0.006 4.120 ## 8 954.067806 51.310 1.385 0.008 0.166 0.003 1.441 0.003 4.105 ## 9 953.955444 50.888 1.555 0.005 0.058 0.002 1.441 0.001 4.035 ## 10 953.897175 50.455 1.734 0.003 0.019 0.001 1.440 0.001 3.952 ## 11 953.858105 50.029 1.923 0.002 0.006 0.001 1.439 0.000 3.874 ## 12 953.826496 49.616 2.121 0.001 0.002 0.001 1.438 0.000 3.806 ## 13 953.798326 49.217 2.327 0.001 0.001 0.000 1.436 0.000 3.747 ## 14 953.772271 48.835 2.539 0.001 0.000 0.000 1.435 0.000 3.697 ## 15 953.747949 48.468 2.757 0.000 0.000 0.000 1.433 0.000 3.654 ## 16 953.725304 48.117 2.977 0.000 0.000 0.000 1.432 0.000 3.619 ## 17 953.704376 47.783 3.198 0.000 0.000 0.000 1.431 0.000 3.589 ## 18 953.685218 47.464 3.418 0.000 0.000 0.000 1.430 0.000 3.564 ## 19 953.667866 47.161 3.635 0.000 0.000 0.000 1.429 0.000 3.544 ## 20 953.652322 46.875 3.846 0.000 0.000 0.000 1.428 0.000 3.527 ## 21 953.638552 46.604 4.051 0.000 0.000 0.000 1.428 0.000 3.514 ## 22 953.626486 46.349 4.246 0.000 0.000 0.000 1.427 0.000 3.504 ## 23 953.616026 46.109 4.433 0.000 0.000 0.000 1.426 0.000 3.496 ## 24 953.607049 45.883 4.608 0.000 0.000 0.000 1.426 0.000 3.491 ## 25 953.599418 45.672 4.772 0.000 0.000 0.000 1.425 0.000 3.487 ## 26 953.592988 45.475 4.925 0.000 0.000 0.000 1.425 0.000 3.485 ## 27 953.587613 45.291 5.066 0.000 0.000 0.000 1.424 0.000 3.485 ## 28 953.583151 45.119 5.195 0.000 0.000 0.000 1.424 0.000 3.485 ## 29 953.579470 44.959 5.313 0.000 0.000 0.000 1.423 0.000 3.487 ## 30 953.576449 44.809 5.420 0.000 0.000 0.000 1.423 0.000 3.489 ## 31 953.573979 44.670 5.517 0.000 0.000 0.000 1.423 0.000 3.492 ## 32 953.571966 44.539 5.604 0.000 0.000 0.000 1.422 0.000 3.495 ## 33 953.570328 44.418 5.682 0.000 0.000 0.000 1.422 0.000 3.499 ## 34 953.568996 44.304 5.751 0.000 0.000 0.000 1.422 0.000 3.503 ## 35 953.567913 44.197 5.813 0.000 0.000 0.000 1.421 0.000 3.507 ## 36 953.567030 44.098 5.868 0.000 0.000 0.000 1.421 0.000 3.512 ## Timings: ## SpATS 4.532 seconds ## All process 4.622 seconds ## ## Spatial analysis of trials with splines ## ## Response: variable ## Genotypes (as random): germplasm ## Spatial: ~PSANOVA(col, row, nseg = c(nlevels(data_tmp$X), nlevels(data_tmp$Y))) ## Random: ~col_f + row_f ## ## ## Number of observations: 118 ## Number of missing data: 93 ## Effective dimension: 58.90 ## Deviance: 953.567 ## ## Dimensions: ## Effective Model Nominal Ratio Type ## Intercept 1.0 1 1 1.00 F ## germplasm 44.1 108 107 0.41 R ## col_f 5.9 54 50 0.12 R ## row_f 0.0 4 2 0.00 R ## col 1.0 1 1 1.00 S ## row 1.0 1 1 1.00 S ## rowcol 1.0 1 1 1.00 S ## f(col) 0.0 55 55 0.00 S ## f(row) 0.0 5 5 0.00 S ## f(col):row 1.4 55 55 0.03 S ## col:f(row) 0.0 5 5 0.00 S ## f(col):f(row) 3.5 275 275 0.01 S ## ## Total 58.9 565 558 0.11 ## Residual 59.1 ## Nobs 118 ## ## Type codes: F &#39;Fixed&#39; R &#39;Random&#39; S &#39;Smooth/Semiparametric&#39; ## ## ## Spatial analysis of trials with splines ## ## Response: variable ## Genotypes (as random): germplasm ## Spatial: ~PSANOVA(col, row, nseg = c(nlevels(data_tmp$X), nlevels(data_tmp$Y))) ## Random: ~col_f + row_f ## ## ## Number of observations: 118 ## Number of missing data: 93 ## Effective dimension: 58.90 ## Deviance: 953.567 ## ## Dimensions: ## Effective Model Nominal Ratio Type ## Intercept 1.0 1 1 1.00 F ## germplasm 44.1 108 107 0.41 R ## col_f 5.9 54 50 0.12 R ## row_f 0.0 4 2 0.00 R ## col 1.0 1 1 1.00 S ## row 1.0 1 1 1.00 S ## rowcol 1.0 1 1 1.00 S ## f(col) 0.0 55 55 0.00 S ## f(row) 0.0 5 5 0.00 S ## f(col):row 1.4 55 55 0.03 S ## col:f(row) 0.0 5 5 0.00 S ## f(col):f(row) 3.5 275 275 0.01 S ## ## Total 58.9 565 558 0.11 ## Residual 59.1 ## Nobs 118 ## ## Type codes: F &#39;Fixed&#39; R &#39;Random&#39; S &#39;Smooth/Semiparametric&#39; Then check the models out_check_spatial_2 = check_model(out_spatial_2) out_check_spatial_3 = check_model(out_spatial_3) Then run the function for germplasm. list_out_check_model = list(&quot;spatial_1&quot; = out_check_spatial, &quot;spatial_2&quot; = out_check_spatial_2, &quot;spatial_3&quot; = out_check_spatial_3) out_parameter_groups = parameter_groups(list_out_check_model, &quot;germplasm&quot;) ## Warning in FactoMineR::PCA(mat, scale.unit = TRUE, ncp = 2, graph = FALSE): ## Missing values are imputed by the mean of the variable: you should use the ## imputePCA function of the missMDA package out_parameter_groups is list of two elements: obj.pca : the PCA object from FactoMineR::PCA() clust, a list of two elements: res.hcpc : the HCPC object from FactoMineR::HCPC() clust : the dataframe with cluster assigned to each individual 3.5.4.9.2 Visualize groups of parameters Visualize outputs with plot p_germplasm_group = plot(out_parameter_groups) p_germplasm_group is list of two elements : pca : a list with three elements on the PCA on the group of parameters : composante_variance : variance caught by each dimension of the PCA p_germplasm_group$pca$composante_variance ind : graph of individuals p_germplasm_group$pca$ind var : graph of variables p_germplasm_group$pca$var clust : output from factextra::fviz_cluster(), a list of number of cluster + 1 element cl = p_germplasm_group$clust names(cl) ## [1] &quot;cluster_all&quot; &quot;cluster_1&quot; &quot;cluster_2&quot; cl$cluster_all cl$cluster_1 ## Warning: Removed 2 rows containing non-finite values (stat_mean). ## Warning: Removed 2 rows containing missing values (geom_point). ## Warning: Removed 2 rows containing missing values (geom_text_repel). 3.5.4.10 post hoc analysis to visualize variation repartition for several variables list_out_check_model = list(&quot;spatial_1&quot; = out_check_spatial, &quot;spatial_2&quot; = out_check_spatial_2, &quot;spatial_3&quot; = out_check_spatial_3) post_hoc_variation(list_out_check_model) 3.5.4.11 Apply the workflow to several variables If you wish to apply the spatial workflow to several variables, you can use lapply with the following code : workflow_spatial = function(x, data){ out_spatial = model_spatial(data = data, variable = x) out_check_spatial = check_model(out_spatial) p_out_check_spatial = plot(out_check_spatial) out_mean_comparisons_spatial = mean_comparisons(out_check_spatial, p.adj = &quot;bonferroni&quot;) p_out_mean_comparisons_spatial = plot(out_mean_comparisons_spatial) out = list( out_spatial = out_spatial, out_check_spatial = out_check_spatial, p_out_check_spatial = p_out_check_spatial, out_mean_comparisons_spatial = out_mean_comparisons_spatial, p_out_mean_comparisons_spatial = p_out_mean_comparisons_spatial ) return(out) } vec_variables = c(&quot;y1&quot;, &quot;y1&quot;, &quot;y1&quot;) out = lapply(vec_variables, workflow_spatial, data_model_spatial) names(out) = vec_variables list_out_check_model = list(&quot;spatial_1&quot; = out_check_spatial, &quot;spatial_2&quot; = out_check_spatial_2, &quot;spatial_3&quot; = out_check_spatial_3) out_parameter_groups = parameter_groups(list_out_check_model, &quot;germplasm&quot; ) p_germplasm_group = plot(out_parameter_groups) p_post_hoc_variation = post_hoc_variation(list_out_check_model) 3.5.5 Mixted model for incomplete block design (M5) !!! TO DO !!! The model is based on frequentist statistics (section 3.1.2.1). The tests to check the model are explained in section 3.1.2.1.2. The method to compute mean comparison are explained in section 3.1.2.1.3. (Zystro, Colley, and Dawson 2018) #library(ibd) #data(ibddata) #aov.ibd(y~factor(trt)+factor(blk),data=ibddata) #contrast=matrix(c(1,-1,0,0,0,0,0,0,0,0,0,1,-1,0,0,0,0,0),nrow=2,byrow=TRUE) #aov.ibd(y~factor(trt)+factor(blk),specs=&quot;trt&quot;,data=ibddata,contrast=contrast) 3.5.6 Hierarchical Bayesian intra-location model to perform mean comparisons with each farm (M7a) At the farm level, the residual has few degrees of freedom, leading to a poor estimation of the residual variance and to a lack of power for comparing populations. model_bh_intra_location was implemented to improve efficiency of mean comparisons. It is efficient with more than 20 environment (i.e. location \\(\\times\\) year) (Rivière et al. 2015). The model is based on bayesian statistics (section 3.1.2.2). 3.5.6.1 Theory of the model The experimental design used is satellite and regional farms (D4). The model is described in Rivière et al. (2015). We restricted ourselves to analysing values at the plot level (the values may result from the average of individual plants measures). The phenotypic value \\(Y_{ijk}\\) for variable \\(Y\\), germplasm \\(i\\), environment \\(j\\) and block \\(k\\) is modelled as : \\(Y_{ijk} = \\mu_{ij} + \\beta_{jk} + \\varepsilon_{ijk} ; \\quad \\varepsilon_{ijk} \\sim \\mathcal{N} (0,\\sigma^2_{j})\\), where \\(\\mu_{ij}\\) is the mean of germplasm \\(i\\) in environment \\(j\\) (note that this parameter, which corresponds to an entry, confounds the population effect and the population \\(\\times\\) environment effect); \\(\\beta_{jk}\\) is the effect of block \\(k\\) in environment \\(j\\) satisfying the constraint8 \\(\\sum\\limits_{k=1}^K \\beta_{jk} = 1\\) ; \\(\\varepsilon_{ijk}\\) is the residual error; \\(\\mathcal{N} (0,\\sigma^2_{j})\\) denotes normal distribution centred on 0 with variance \\(\\sigma^2_{j}\\), which is specific to environment \\(j\\). We take advantage of the similar structure of the trials in each environment of the network to assume that trial residual variances come from a common distribution : \\(\\sigma^2_{j} \\sim \\frac{1}{Gamma(\\nu,\\rho)}\\), where \\(\\nu\\) and \\(\\rho\\) are unknown parameters. Because of the low number of residual degrees of freedom for each farm, we use a hierarchical approach in order to assess mean differences on farm. For that, we place vague prior distributions on the hyperparameters \\(\\nu\\) and \\(\\rho\\) : \\(\\nu \\sim Uniform(\\nu_{min},\\nu_{max}) ; \\quad \\rho \\sim Gamma(10^{-6},10^{-6})\\). In other words, the residual variance of a trial in a given environment is estimated using all the informations available on the network rather than using the data from that particular trial only. The parameters \\(\\mu_{ij}\\) and \\(\\beta_{jk}\\) are assumed to follow vague prior distributions too: \\(\\mu_{ij} \\sim \\mathcal{N}(\\mu_{.j},10^{6}); \\quad \\beta_{jk} \\sim \\mathcal{N}(0,10^{6})\\). The inverse gamma distribution has a minimum value of 0 (consistent with the definition of a variance) and may have various shapes including asymmetric distributions. From an agronomical point of view, the assumption that trial variances are heterogeneous is consistent with organic farming: there are as many environments as farms and farmers leading to a high heterogeneity. Environment is here considered in a broad sense: practices (sowing date, sowing density, tilling, etc.), pedo climatic conditions, biotic and abiotic stress, … (Desclaux et al. 2008). Moreover, the inverse gamma distribution has conjugate properties that facilitate MCMC convergence. This model is therefore a good choice based on both agronomic and statistical criteria. The residual variance estimated from the controls is assumed to be representative of the residual variance of the other entries. Blocks are included in the model only if the trial has blocks. 3.5.6.2 Steps with To run model_bh_intra_location, follow these steps (Figure 3.2): Format the data with format_data_PPBstats() Run the model with model_bh_intra_location() Check model outputs with graphs using check_model()to know if you can continue the analysis Get mean comparisons for each factor with mean_comparisons() and vizualise it with plot() 3.5.6.3 Format the data The values for \\(\\mu_{ij}\\), \\(\\beta_{jk}\\), \\(\\epsilon_{ijk}\\) and \\(\\sigma_j\\) are the real value used to create the simulated dataset. This dataset is representative of data obtain in a PPB programme. data(data_model_bh_intra_location) data_model_bh_intra_location = format_data_PPBstats(data_model_bh_intra_location, type = &quot;data_agro&quot;) ## Warning in format_data_PPBstats.data_agro(data): Column &quot;long&quot; is needed to ## get map and not present in data. ## Warning in format_data_PPBstats.data_agro(data): Column &quot;lat&quot; is needed to ## get map and not present in data. ## data has been formated for PPBstats functions. head(data_model_bh_intra_location) # first rows of the data ## seed_lot location year germplasm block X Y tkw ## 1 germ-25_loc-1_2005_0001 loc-1 2005 germ-25 1 1 a 72.09900 ## 2 germ-26_loc-1_2005_0001 loc-1 2005 germ-26 1 2 b 61.05274 ## 3 germ-27_loc-1_2005_0001 loc-1 2005 germ-27 1 3 c 62.99350 ## 4 germ-28_loc-1_2005_0001 loc-1 2005 germ-28 1 4 d 65.10909 ## 5 germ-25_loc-1_2005_0001 loc-1 2005 germ-25 2 5 e 77.01361 ## 6 germ-26_loc-1_2005_0001 loc-1 2005 germ-26 2 6 f 64.10541 ## tkw$date mu_ij beta_jk epsilon_ijk sigma_j tkw$date_julian ## 1 2017-07-22 73.37224 0 -1.2732421 1.622339 202 ## 2 2017-07-22 61.61823 0 -0.5654918 1.622339 202 ## 3 2017-07-22 64.31830 0 -1.3248006 1.622339 202 ## 4 2017-07-22 62.57840 0 2.5306946 1.622339 202 ## 5 2017-07-22 73.37224 0 3.6413666 1.622339 202 ## 6 2017-07-22 61.61823 0 2.4871807 1.622339 202 3.5.6.4 Run the model To run model model_bh_intra_location on the dataset, used the function model_bh_intra_location(). Here it is run on thousand kernel weight (tkw). By default, model_bh_intra_location returns posteriors for \\(\\mu_{ij}\\) (return.mu = TRUE), \\(\\beta_{jk}\\) (return.beta = TRUE), \\(\\sigma_j\\) (return.sigma = TRUE), \\(\\nu\\) (return.nu = TRUE) and \\(\\rho\\) (return.rho = TRUE). You can also get \\(\\epsilon_{ijk}\\) value with return.espilon = TRUE. DIC criterion is a generalization of the AIC criterion that can be used for hierarchical models (Spiegelhalter et al. 2002). The smaller the DIC value, the better the model (Plummer 2008). By default, DIC is not displayed, you can ask for this value to compare to other model (DIC = TRUE). # out_model_bh_intra_location = model_bh_intra_location(data = data_model_bh_intra_location, variable = &quot;tkw&quot;, return.epsilon = TRUE) # Compiling model graph # Resolving undeclared variables # Allocating nodes # Graph information: # Observed stochastic nodes: 976 # Unobserved stochastic nodes: 927 # Total graph size: 8609 # # Initializing model # # |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% # |**************************************************| 100% # |**************************************************| 100% # |**************************************************| 100% load(&quot;./data_PPBstats/out_model_bh_intra_location.RData&quot;) # To save time You can get information on the environments in the dataset : out_model_bh_intra_location$vec_env_with_no_data ## NULL out_model_bh_intra_location$vec_env_with_no_controls ## [1] &quot;loc-25:2005&quot; out_model_bh_intra_location$vec_env_with_controls ## [1] &quot;loc-10:2005&quot; &quot;loc-10:2006&quot; &quot;loc-10:2007&quot; &quot;loc-11:2005&quot; &quot;loc-11:2006&quot; ## [6] &quot;loc-11:2007&quot; &quot;loc-1:2005&quot; &quot;loc-1:2006&quot; &quot;loc-1:2007&quot; &quot;loc-12:2005&quot; ## [11] &quot;loc-12:2006&quot; &quot;loc-12:2007&quot; &quot;loc-13:2005&quot; &quot;loc-13:2006&quot; &quot;loc-13:2007&quot; ## [16] &quot;loc-14:2005&quot; &quot;loc-14:2006&quot; &quot;loc-14:2007&quot; &quot;loc-15:2005&quot; &quot;loc-15:2006&quot; ## [21] &quot;loc-15:2007&quot; &quot;loc-16:2005&quot; &quot;loc-16:2006&quot; &quot;loc-16:2007&quot; &quot;loc-17:2005&quot; ## [26] &quot;loc-17:2006&quot; &quot;loc-17:2007&quot; &quot;loc-18:2005&quot; &quot;loc-18:2006&quot; &quot;loc-18:2007&quot; ## [31] &quot;loc-19:2006&quot; &quot;loc-19:2007&quot; &quot;loc-20:2006&quot; &quot;loc-20:2007&quot; &quot;loc-21:2006&quot; ## [36] &quot;loc-21:2007&quot; &quot;loc-2:2005&quot; &quot;loc-2:2006&quot; &quot;loc-2:2007&quot; &quot;loc-22:2006&quot; ## [41] &quot;loc-22:2007&quot; &quot;loc-23:2006&quot; &quot;loc-23:2007&quot; &quot;loc-3:2005&quot; &quot;loc-3:2006&quot; ## [46] &quot;loc-3:2007&quot; &quot;loc-4:2005&quot; &quot;loc-4:2006&quot; &quot;loc-4:2007&quot; &quot;loc-5:2006&quot; ## [51] &quot;loc-6:2006&quot; &quot;loc-6:2007&quot; &quot;loc-7:2006&quot; &quot;loc-7:2007&quot; &quot;loc-8:2006&quot; ## [56] &quot;loc-9:2005&quot; &quot;loc-9:2006&quot; &quot;loc-9:2007&quot; out_model_bh_intra_location$vec_env_RF ## [1] &quot;loc-1:2005&quot; &quot;loc-1:2006&quot; &quot;loc-1:2007&quot; &quot;loc-2:2005&quot; &quot;loc-2:2006&quot; ## [6] &quot;loc-2:2007&quot; &quot;loc-3:2005&quot; &quot;loc-3:2006&quot; &quot;loc-3:2007&quot; &quot;loc-4:2005&quot; ## [11] &quot;loc-4:2006&quot; &quot;loc-4:2007&quot; &quot;loc-5:2006&quot; &quot;loc-6:2006&quot; &quot;loc-6:2007&quot; ## [16] &quot;loc-7:2006&quot; &quot;loc-7:2007&quot; &quot;loc-8:2006&quot; out_model_bh_intra_location$vec_env_SF ## [1] &quot;loc-10:2005&quot; &quot;loc-10:2006&quot; &quot;loc-10:2007&quot; &quot;loc-11:2005&quot; &quot;loc-11:2006&quot; ## [6] &quot;loc-11:2007&quot; &quot;loc-12:2005&quot; &quot;loc-12:2006&quot; &quot;loc-12:2007&quot; &quot;loc-13:2005&quot; ## [11] &quot;loc-13:2006&quot; &quot;loc-13:2007&quot; &quot;loc-14:2005&quot; &quot;loc-14:2006&quot; &quot;loc-14:2007&quot; ## [16] &quot;loc-15:2005&quot; &quot;loc-15:2006&quot; &quot;loc-15:2007&quot; &quot;loc-16:2005&quot; &quot;loc-16:2006&quot; ## [21] &quot;loc-16:2007&quot; &quot;loc-17:2005&quot; &quot;loc-17:2006&quot; &quot;loc-17:2007&quot; &quot;loc-18:2005&quot; ## [26] &quot;loc-18:2006&quot; &quot;loc-18:2007&quot; &quot;loc-19:2006&quot; &quot;loc-19:2007&quot; &quot;loc-20:2006&quot; ## [31] &quot;loc-20:2007&quot; &quot;loc-21:2006&quot; &quot;loc-21:2007&quot; &quot;loc-22:2006&quot; &quot;loc-22:2007&quot; ## [36] &quot;loc-23:2006&quot; &quot;loc-23:2007&quot; &quot;loc-9:2005&quot; &quot;loc-9:2006&quot; &quot;loc-9:2007&quot; Below is an example with low nb_iterations (see section 3.1.2.2 about the number of iterations): # out_model_bh_intra_location_bis = model_bh_intra_location(data = data_model_bh_intra_location, variable = &quot;tkw&quot;, nb_iteration = 5000) # Compiling model graph # Resolving undeclared variables # Allocating nodes # Graph information: # Observed stochastic nodes: 976 # Unobserved stochastic nodes: 927 # Total graph size: 8609 # # Initializing model # # |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% # |**************************************************| 100% # |**************************************************| 100% # Warning message: # In model_bh_intra_location(data = data_model_bh_intra_location, variable = &quot;tkw&quot;, nb_iteration = 5000) : # nb_iterations is below 20 000, which seems small to get convergence in the MCMC. load(&quot;./data_PPBstats/out_model_bh_intra_location_bis.RData&quot;) # To save time 3.5.6.5 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.2.2. 3.5.6.5.1 Check the model Once the model has been run, it is necessary to check if the outputs can be taken with confidence. This step is needed before going ahead in the analysis (in fact the object used in the next functions must come from check_model). # out_check_model_bh_intra_location = check_model(out_model_bh_intra_location) # The Gelman-Rubin test is running for each parameter ... # The two MCMC for each parameter converge thanks to the Gelman-Rubin test. load(&quot;./data_PPBstats/out_check_model_bh_intra_location.RData&quot;) # To save time out_check_model_bh_intra_location is a list containing: MCMC : a data fame resulting from the concatenation of the two MCMC for each parameter. This object can be used for further analysis. There are as many columns as parameters and as many rows as iterations/thin (the thin value is 10 by default in the models). dim(out_check_model_bh_intra_location$MCMC) ## [1] 20000 945 MCMC_conv_not_ok: a data fame resulting from the concatenation of the two MCMC for each parameter for environments where some parameters did not converge for mu and beta data_env_with_no_controls : data frame with environnements without controls data_env_whose_param_did_not_converge : a list with data frame with environments where some parameters did not converge for mu and beta data_ggplot : a list containing information for ggplot: sigma_j mu_ij beta_jk sigma_j_2 epsilon_ijk When considering out_model_bh_intra_location_bis: # out_check_model_bh_intra_location_bis = check_model(out_model_bh_intra_location_bis) # The Gelman-Rubin test is running for each parameter ... # The two MCMC of the following parameters do not converge thanks to the Gelman-Rubin test : # mu[germ-20,loc-15:2006], nu, rho, sigma[loc-15:2006]. Therefore, they are not present in MCMC output. # MCMC are updated, the following environment were deleted : loc-15:2006 # data_env_whose_param_did_not_converge contains the raw data for these environments. load(&quot;./data_PPBstats/out_check_model_bh_intra_location_bis.RData&quot;) # To save time 3.5.6.5.2 Visualize outputs Once the computation is finished, you can visualize the results with p_out_check_model_bh_intra_location = plot(out_check_model_bh_intra_location) ## Distribution of sigma_j in the inverse Gamme distribution are done. ## The mu_ij posterior distributions are done. ## The beta_jk posterior distributions are done. ## The sigma_j posterior distributions are done. ## The standardised residuals distributions are done. p_out_check_model_bh_intra_location is a list with: sigma_j_gamma : mean of each sigma_j displayed on the Inverse Gamma distribution. The first graph represents all the sigma_j, the other graph represent the same information divided into several graphs (based on argument nb_parameters_per_plot). p_out_check_model_bh_intra_location$sigma_j_gamma[[1]] p_out_check_model_bh_intra_location$sigma_j_gamma[[2]] mu_ij : distribution of each mu_ij in a list with as many elements as environment. For each element of the list, there are as many graph as needed with nb_parameters_per_plot mu_ij per graph. names(p_out_check_model_bh_intra_location$mu_ij) ## [1] &quot;loc-10:2005&quot; &quot;loc-10:2006&quot; &quot;loc-10:2007&quot; &quot;loc-11:2005&quot; &quot;loc-11:2006&quot; ## [6] &quot;loc-11:2007&quot; &quot;loc-1:2005&quot; &quot;loc-1:2006&quot; &quot;loc-1:2007&quot; &quot;loc-12:2005&quot; ## [11] &quot;loc-12:2006&quot; &quot;loc-12:2007&quot; &quot;loc-13:2005&quot; &quot;loc-13:2006&quot; &quot;loc-13:2007&quot; ## [16] &quot;loc-14:2005&quot; &quot;loc-14:2006&quot; &quot;loc-14:2007&quot; &quot;loc-15:2005&quot; &quot;loc-15:2006&quot; ## [21] &quot;loc-15:2007&quot; &quot;loc-16:2005&quot; &quot;loc-16:2006&quot; &quot;loc-16:2007&quot; &quot;loc-17:2005&quot; ## [26] &quot;loc-17:2006&quot; &quot;loc-17:2007&quot; &quot;loc-18:2005&quot; &quot;loc-18:2006&quot; &quot;loc-18:2007&quot; ## [31] &quot;loc-19:2006&quot; &quot;loc-19:2007&quot; &quot;loc-20:2006&quot; &quot;loc-20:2007&quot; &quot;loc-21:2006&quot; ## [36] &quot;loc-21:2007&quot; &quot;loc-2:2005&quot; &quot;loc-2:2006&quot; &quot;loc-2:2007&quot; &quot;loc-22:2006&quot; ## [41] &quot;loc-22:2007&quot; &quot;loc-23:2006&quot; &quot;loc-23:2007&quot; &quot;loc-3:2005&quot; &quot;loc-3:2006&quot; ## [46] &quot;loc-3:2007&quot; &quot;loc-4:2005&quot; &quot;loc-4:2006&quot; &quot;loc-4:2007&quot; &quot;loc-5:2006&quot; ## [51] &quot;loc-6:2006&quot; &quot;loc-6:2007&quot; &quot;loc-7:2006&quot; &quot;loc-7:2007&quot; &quot;loc-8:2006&quot; ## [56] &quot;loc-9:2005&quot; &quot;loc-9:2006&quot; &quot;loc-9:2007&quot; names(p_out_check_model_bh_intra_location$mu_ij$`loc-10:2005`) ## [1] &quot;1&quot; p_out_check_model_bh_intra_location$mu_ij$`loc-10:2005`$`1` beta_jk : distribution of each beta_jk in a list with as many elements as environment. For each element of the list, there are as many graph as needed with nb_parameters_per_plot beta_jk per graph. names(p_out_check_model_bh_intra_location$beta_jk) ## [1] &quot;loc-1:2005&quot; &quot;loc-1:2006&quot; &quot;loc-1:2007&quot; &quot;loc-2:2005&quot; &quot;loc-2:2006&quot; ## [6] &quot;loc-2:2007&quot; &quot;loc-3:2005&quot; &quot;loc-3:2006&quot; &quot;loc-3:2007&quot; &quot;loc-4:2005&quot; ## [11] &quot;loc-4:2006&quot; &quot;loc-4:2007&quot; &quot;loc-5:2006&quot; &quot;loc-6:2006&quot; &quot;loc-6:2007&quot; ## [16] &quot;loc-7:2006&quot; &quot;loc-7:2007&quot; &quot;loc-8:2006&quot; names(p_out_check_model_bh_intra_location$beta_jk$`loc-1:2005`) ## [1] &quot;1&quot; p_out_check_model_bh_intra_location$beta_jk$`loc-1:2005`$`1` sigma_j : distribution of each sigma_j. There are as many graph as needed with nb_parameters_per_plot sigma_j per graph. names(p_out_check_model_bh_intra_location$sigma_j) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; p_out_check_model_bh_intra_location$sigma_j[[1]] epsilon_ijk : standardised residuals distribution. If the model went well it should be between -2 and 2. p_out_check_model_bh_intra_location$epsilon_ijk mcmc_not_converge_traceplot_density : a list with the plots of trace and density to check the convergence of the two MCMC only for chains that are not converging detected by the Gelman-Rubin test. If all the chains converge, it is NULL p_out_check_model_bh_intra_location$mcmc_not_converge_traceplot_density ## NULL Here all the parameters converged. When considering p_out_check_model_bh_intra_location_bis, there is no convergence because the MCMC are too small. p_out_check_model_bh_intra_location_bis = plot(out_check_model_bh_intra_location_bis) ## Distribution of sigma_j in the inverse Gamme distribution are done. ## The mu_ij posterior distributions are done. ## The beta_jk posterior distributions are done. ## The sigma_j posterior distributions are done. ## Trace and density plot for MCMC that did not converged are done. p_out_check_model_bh_intra_location_bis$mcmc_not_converge_traceplot_density$`sigma\\\\[loc-15:2006` ## $traceplot ## ## $density Just for fun, you can compare the posterior medians and the arithmetic means for the mu_ij. MCMC = out_check_model_bh_intra_location$MCMC effects = apply(MCMC, 2, median) mu_ij_estimated = effects[grep(&quot;mu&quot;,names(effects))] names(mu_ij_estimated) = sapply(names(mu_ij_estimated), function(x){ sub(&quot;\\\\]&quot;, &quot;&quot;, sub(&quot;mu\\\\[&quot;, &quot;&quot;, x)) } ) d = dplyr::filter(data_model_bh_intra_location, location != &quot;loc-24&quot;) d = dplyr::filter(d, location != &quot;loc-25&quot;) d = droplevels(d) environment = paste(as.character(d$location), as.character(d$year), sep = &quot;:&quot;) d$entry = as.factor(paste(as.character(d$germplasm), environment, sep = &quot;,&quot;)) mu_ij = tapply(d$mu_ij, d$entry, mean, na.rm = TRUE) check_data = cbind.data.frame(mu_ij, mu_ij_estimated[names(mu_ij)]) Let’s have a look on the relation between the posterior medians and the arithmetic means. It goes pretty well! p = ggplot(check_data, aes(x = mu_ij, y = mu_ij_estimated)) p + stat_smooth(method = &quot;lm&quot;) + geom_point() 3.5.6.6 Get and visualize mean comparisons The method to compute mean comparison are explained in section ??. 3.5.6.6.1 Get mean comparisons Get mean comparisons with mean_comparisons. The theory behind mean comparisons has been explained in section ??. Below is an example for \\(\\mu\\), the same can be done for \\(\\beta\\). # out_mean_comparisons_model_bh_intra_location_mu = mean_comparisons(out_check_model_bh_intra_location, parameter = &quot;mu&quot;) # Get at least X groups for loc-11:2007. It may take some time ... # Get at least X groups for loc-11:2007 is done. # Get at least X groups for loc-17:2005. It may take some time ... # Get at least X groups for loc-17:2005 is done. # Get at least X groups for loc-21:2006. It may take some time ... # Get at least X groups for loc-21:2006 is done. # Get at least X groups for loc-9:2006. It may take some time ... # Get at least X groups for loc-9:2006 is done. load(&quot;./data_PPBstats/out_mean_comparisons_model_bh_intra_location_mu.RData&quot;) # To save time out_mean_comparisons_model_bh_intra_location_mu is a list of three elements: data_mean_comparisons a list with as many elements as environment. head(names(out_mean_comparisons_model_bh_intra_location_mu$data_mean_comparisons)) ## [1] &quot;loc-1:2005&quot; &quot;loc-1:2006&quot; &quot;loc-1:2007&quot; &quot;loc-2:2005&quot; &quot;loc-2:2006&quot; ## [6] &quot;loc-2:2007&quot; Each element of the list is composed of two elements: - `mean.comparisons` ```r head(out_mean_comparisons_model_bh_intra_location_mu$data_mean_comparisons$`loc-1:2005`$mean.comparisons) ``` ``` ## parameter median groups nb_group alpha alpha.correction ## 1 mu[germ-3,loc-1:2005] 38.42457 a 10 0.05 soft.bonf ## 2 mu[germ-1,loc-1:2005] 41.73724 ab 10 0.05 soft.bonf ## 3 mu[germ-10,loc-1:2005] 45.91424 abc 10 0.05 soft.bonf ## 4 mu[germ-18,loc-1:2005] 47.76006 abcd 10 0.05 soft.bonf ## 5 mu[germ-2,loc-1:2005] 48.10288 abcde 10 0.05 soft.bonf ## 6 mu[germ-19,loc-1:2005] 49.20361 abcdef 10 0.05 soft.bonf ## entry environment location year ## 1 germ-3 loc-1:2005 loc-1 2005 ## 2 germ-1 loc-1:2005 loc-1 2005 ## 3 germ-10 loc-1:2005 loc-1 2005 ## 4 germ-18 loc-1:2005 loc-1 2005 ## 5 germ-2 loc-1:2005 loc-1 2005 ## 6 germ-19 loc-1:2005 loc-1 2005 ``` - `Mpvalue` : a square matrix with pvalue computed for each pair of parameter. ```r out_mean_comparisons_model_bh_intra_location_mu$data_mean_comparisons$`loc-1:2005`$Mpvalue[1:3, 1:3] ``` ``` ## mu[germ-3,loc-1:2005] mu[germ-1,loc-1:2005] ## mu[germ-3,loc-1:2005] 0 0.17505 ## mu[germ-1,loc-1:2005] 0 0.00000 ## mu[germ-10,loc-1:2005] 0 0.00000 ## mu[germ-10,loc-1:2005] ## mu[germ-3,loc-1:2005] 0.03940 ## mu[germ-1,loc-1:2005] 0.15185 ## mu[germ-10,loc-1:2005] 0.00000 ``` data_env_with_no_controls a list with as many elements as environment. names(out_mean_comparisons_model_bh_intra_location_mu$data_env_with_no_controls) ## [1] &quot;loc-25:2005&quot; Each list contains mean.comparisons. Note there are no groups displayed. Inded, there were no controls on the environment so no model was run. head(out_mean_comparisons_model_bh_intra_location_mu$data_env_with_no_controls$`loc-25:2005`$mean.comparisons) ## entry germplasm environment block X Y median ## 1 germ-12,loc-25:2005 germ-12 loc-25:2005 1 4 d 38.02544 ## 2 germ-18,loc-25:2005 germ-18 loc-25:2005 1 5 e 44.49495 ## 3 germ-19,loc-25:2005 germ-19 loc-25:2005 1 6 f 44.46948 ## 4 germ-1,loc-25:2005 germ-1 loc-25:2005 1 3 c 42.32750 ## 5 germ-20,loc-25:2005 germ-20 loc-25:2005 1 7 g 35.77590 ## 6 germ-21,loc-25:2005 germ-21 loc-25:2005 1 8 h 36.59313 ## parameter location year ## 1 mu[germ-12,loc-25:2005] loc-25 2005 ## 2 mu[germ-18,loc-25:2005] loc-25 2005 ## 3 mu[germ-19,loc-25:2005] loc-25 2005 ## 4 mu[germ-1,loc-25:2005] loc-25 2005 ## 5 mu[germ-20,loc-25:2005] loc-25 2005 ## 6 mu[germ-21,loc-25:2005] loc-25 2005 data_env_whose_param_did_not_converge a list with as many elements as environment. names(out_mean_comparisons_model_bh_intra_location_mu$data_env_whose_param_did_not_converge) ## NULL Here it is NULL as all parameters converge. Otherwise in each list it is mean.comparisons. Note there are no groups displayed. Inded, the model did not well so no mean comparisons were done. head(out_mean_comparisons_model_bh_intra_location_mu$data_env_with_no_controls$`loc-5:2005`$mean.comparisons) ## NULL 3.5.6.6.2 Visualize mean comparisons To see the output, use plot. On each plot, the alpha (type one error) value and the alpha correction are displayed. alpha = Imp means that no differences could be detected. For plot_type = &quot;interaction&quot; and plot_type = &quot;score&quot;, it is displayed under the form: alpha | alpha correction. The ggplot are done for each element of the list coming from mean_comparisons. For each plot_type, it is a list of three lists each with as many elements as environments. For each element of the list, there are as many graphs as needed with nb_parameters_per_plot parameters per graph. 3.5.6.6.2.1 barplot p_barplot_mu = plot(out_mean_comparisons_model_bh_intra_location_mu, plot_type = &quot;barplot&quot;) names(p_barplot_mu) ## [1] &quot;data_mean_comparisons&quot; ## [2] &quot;data_env_with_no_controls&quot; ## [3] &quot;data_env_whose_param_did_not_converge&quot; From data_mean_comparisons, only environments where all MCMC converged are represented. Letters are displayed on each bar. Parameters that do not share the same letters are different based on type I error (alpha) and alpha correction. The error I (alpha) and the alpha correction are displayed in the title. alpha = Imp means that no significant differences coumd be detected. p = p_barplot_mu$data_mean_comparisons head(names(p)) ## [1] &quot;loc-1:2005&quot; &quot;loc-1:2006&quot; &quot;loc-1:2007&quot; &quot;loc-2:2005&quot; &quot;loc-2:2006&quot; ## [6] &quot;loc-2:2007&quot; p_env = p$`loc-1:2005` names(p_env) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; p_env$`1` p_env$`2` p_env$`3` p_env$`4` For data_env_with_no_controls, only environments where there were no controls are represented. p_barplot_mu$data_env_with_no_controls ## $`loc-25:2005` ## $`loc-25:2005`$`1` For data_env_whose_param_did_not_converge, only environments where MCMC did not converge are represented. p_barplot_mu$data_env_whose_param_did_not_converge ## list() 3.5.6.6.2.2 interaction With plot_type = &quot;interaction&quot;, you can display the year effect as well as detect groups. One group is represented by one vertical line. Germplasms which share the same group are not different. Germplasms which do not share the same groupe are different (Section ??). The ggplot are done for each element of the list coming rom mean_comparisons. For each plot_type, it is a list of three elements being lists with as many elements as environment. For each element of the list, there are as many graph as needed with nb_parameters_per_plot parameters per graph. p_interaction = plot(out_mean_comparisons_model_bh_intra_location_mu, plot_type = &quot;interaction&quot;) head(names(p_interaction$data_mean_comparisons)) ## [1] &quot;loc-1&quot; &quot;loc-10&quot; &quot;loc-11&quot; &quot;loc-12&quot; &quot;loc-13&quot; &quot;loc-14&quot; p_env = p_interaction$data_mean_comparisons$`loc-1` names(p_env) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; p_env$`1` p_env$`2` p_env$`3` p_env$`4` 3.5.6.6.3 score For the score, more entries are displayed. An high score means that the entry was in a group with an high mean. A low socre means that the entry was in a group with an low mean. In the legend, the score goes from 1 (first group) to the number of groups of significativity. This plot is useful to look at year effects. p_score = plot(out_mean_comparisons_model_bh_intra_location_mu, plot_type = &quot;score&quot;) head(names(p_score)) ## [1] &quot;loc-1&quot; &quot;loc-10&quot; &quot;loc-11&quot; &quot;loc-12&quot; &quot;loc-13&quot; &quot;loc-14&quot; p_env = p_score$`loc-1` names(p_env) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; p_env$`1` p_env$`2` p_env$`3` p_env$`4` 3.5.6.7 Apply the workflow to several variables If you wish to apply the model_bh_intra_location workflow to several variables, you can use lapply with the following code : workflow_model_bh_intra_location = function(x){ out_model_bh_intra_location = model_bh_intra_location(data = data_model_bh_intra_location, variable = x, return.epsilon = TRUE) out_check_model_bh_intra_location = check_model(out_model_bh_intra_location) p_out_check_model_bh_intra_location = plot(out_check_model_bh_intra_location) out_mean_comparisons_model_bh_intra_location_mu = mean_comparisons(out_check_model_bh_intra_location, parameter = &quot;mu&quot;) p_barplot_mu = plot(out_mean_comparisons_model_bh_intra_location_mu, plot_type = &quot;barplot&quot;) p_interaction = plot(out_mean_comparisons_model_bh_intra_location_mu, plot_type = &quot;interaction&quot;) p_score = plot(out_mean_comparisons_model_bh_intra_location_mu, plot_type = &quot;score&quot;) out = list( &quot;out_model_bh_intra_location&quot; = out_model_bh_intra_location, &quot;out_check_model_bh_intra_location&quot; = out_check_model_bh_intra_location, &quot;p_out_check_model_bh_intra_location&quot; = p_out_check_model_bh_intra_location, &quot;out_mean_comparisons_model_bh_intra_location_mu&quot; = out_mean_comparisons_model_bh_intra_location_mu, &quot;p_barplot_mu&quot; = p_barplot_mu, &quot;p_interaction&quot; = p_interaction, &quot;p_score&quot; = p_score ) return(out) } ## Not run because of memory and time issues ! # vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;) # # out = lapply(vec_variables, workflow_model_bh_intra_location) # names(out) = vec_variables References "],
["family-2.html", "3.6 Family 2 of analysis : Study the response of varieties under selection over several environments", " 3.6 Family 2 of analysis : Study the response of varieties under selection over several environments Family 2 gathers analyses that estimate germplasm and location and interaction effects. This is to analyse the response over a network of locations. Estimation of environment and year effects is possible depending of the model. Specific analysis including migrant and residant can also be done. It allows to study the response of germplasm over several location or environments. The objectives is to study response of germplasm over several locations for selection. 3.6.1 Decision tree To study response of germplasm over several locations for selection, different scenario are possible (Figure 3.24) : AMMI and GGE (M6, sections 3.6.3 and 3.6.4) based on on fully replicated designs (D1, section 3.2.1), bayesian hierarchical model \\(G \\times E\\) (M7b, section 3.6.5) based on satellite-regional farms designs (D4, section 3.2.4), It can be completed by specific analysis such as migrant-residant (section ??) which corresponds to a specific objective : study migrant and residant effect, where migrant in a location refers to a germplasm that has not been grown or selected in a given location and resident in a location refers to a germplasm that has been grown or selected in a given location. Figure 3.24: Decision tree with experimental constraints, designs and methods of agronomic analysis carry out in PPBstats regarding the objective :Study the response of varieties under selection over several environments. D refers to designs and M to methods. 3.6.2 Workflow and function relations in PPBstats regarding family 2 of analysis Figure 3.25 displays the functions and their relationships. Table 3.3 describes each of the main functions. You can have more information for each function by typing ?function_name in your R session. Note that check_model(), mean_comparison(), biplot_data() and plot() are S3 method. Therefore, you should type ?check_model, ?mean_comparison, ?biplot_data or ?plot.PPBstats to have general features and then see in details for specific functions. Figure 3.25: Main functions used in the workflow of family 1. Table 3.3: Function description. function name description design_experiment Provides experimental design for the different situations corresponding to the choosen family of analysis format_data_PPBstats Check and format the data to be used in PPBstats functions model_bh_GxE Run Hierarchical Bayesian GxE model model_GxE Run AMMI or GGE model check_model Check if the model went well mean_comparisons Get mean comparisons parameter_groups Get groups of parameters based on multivariate analysis cross_validation_model_bh_GxE Run complete cross validation with Hierarchical Bayesian GxE model predict_the_past_model_bh_GxE predict values of germplasms in environments where they have not been grown based on Hierarchical Bayesian GxE model biplot_data Compute ecovalence and format PCA results regarding \\(G \\times E\\) models plot Build ggplot objects to visualize output 3.6.3 AMMI (M6a) 3.6.3.1 Theory of the model The experimental design used is fully replicated (D1). The Additive Main effects and Multiplicative Interaction (AMMI) model is based on frequentist statistics (section 3.1.2.1). The analysis can be broken down in two steps (Gauch 2006)(Gauch, Piepho, and Annicchiarico 2008)(Yan et al. 2007) : an ANOVA with the following model : \\(Y_{ijk} = \\mu + \\alpha_{i} + \\theta_{j} + rep_{k}(\\theta_{j}) + (\\alpha\\theta)_{ij} + \\varepsilon_{ijk}; \\quad \\varepsilon_{ijk} \\sim \\mathcal{N} (0,\\sigma^2)\\) With, \\(Y_{ijk}\\) the phenotypic value for replication \\(k\\), germplasm \\(i\\) and location \\(j\\), \\(\\mu\\) the general mean, \\(\\alpha_{i}\\) the effect of germplasm \\(i\\), \\(\\theta_{j}\\) the effect of location \\(j\\), \\(rep_{k}(\\theta_{j})\\) the effect of the replication \\(k\\) nested in location, \\((\\alpha\\theta)_{ij}\\) the interaction effect of germplasm \\(\\times\\) location, \\(\\varepsilon_{ijk}\\) the residuals. Or, if there are several years in the data set: \\(Y_{ijkl} = \\mu + \\alpha_{i} + \\theta_{j} + \\beta_{l} + (\\alpha\\theta)_{ij} + (\\alpha\\beta)_{il} + (\\theta\\beta)_{jl} + rep_{k}((\\theta\\beta)_{jl}) + \\varepsilon_{ijkl}; \\quad \\varepsilon_{ijkl} \\sim \\mathcal{N} (0,\\sigma^2)\\) With, \\(Y_{ijkl}\\) the phenotypic value for replication \\(k\\), germplasm \\(i\\), location \\(j\\) and year \\(l\\), \\(\\beta_{l}\\) the year \\(l\\) effect, \\((\\alpha\\beta)_{il}\\) the germplasm \\(\\times\\) year interaction effect, \\((\\theta\\beta)_{jl}\\) the location \\(\\times\\) year interaction effect, \\(rep_{k}((\\theta\\beta)_{jl})\\) the effect of the replication \\(k\\) nested in location \\(\\times\\) year, \\(\\varepsilon_{ijkl}\\) the residuals, and all other effects are the same as in the previous model. a PCA that focus on the germplasm \\(\\times\\) location interaction : \\((\\alpha\\theta)_{ij} = \\sum_{n}^{N} \\lambda_{n} \\gamma_{in} \\omega_{jn}\\)9 which can also be written : \\((\\alpha\\theta)_{ij} = \\sum_{n}^{N} (\\sqrt{\\lambda_{n}} \\gamma_{in}) (\\sqrt{\\lambda_{n}} \\omega_{jn})\\) With, \\((\\alpha\\theta)_{ij}\\) the interaction between germplasm \\(i\\) and location \\(j\\), \\(N\\) the number of dimensions (PCA componants) which has as maximum value the number of location, \\(\\lambda_{n}\\) the eigen value for componant \\(n\\), \\(\\gamma_{in}\\) the eigen vector for germplasm \\(i\\) and componant \\(n\\), \\(\\omega_{jn}\\) the eigen vector for location \\(j\\) and componant \\(n\\). The data are double centered on location and germplasm. The PCA studies the structure of the interaction matrix. The locations are the variables and the germplasms are the individuals. This PCA allows to detect germplasm that are stable (i.e. contribute less to the interaction) the germplasm that interact the most and with which location the location that have the same profile regarding interaction 3.6.3.2 Steps with PPBstats For AMMI analysis, you can follow these steps (Figure 3.2): Format the data with format_data_PPBstats() Run the model with model_GxE() and gxe_analysis = &quot;AMMI&quot; Check model outputs to know if you can continue the analysis with check_model() and vizualise it with plot() Get mean comparisons for each factor with mean_comparisons() and vizualise it with plot() Get and visualize biplot with biplot_data() and plot() Get groups of each parameters with parameters_groups() and visualise it with plot() 3.6.3.3 Format the data data(data_model_GxE) data_model_GxE = format_data_PPBstats(data_model_GxE, type = &quot;data_agro&quot;) ## data has been formated for PPBstats functions. head(data_model_GxE) ## seed_lot location long lat year germplasm block ## 1 germ-12_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-12 1 ## 2 germ-1_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-1 1 ## 3 germ-18_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-18 1 ## 4 germ-14_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-14 1 ## 5 germ-6_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-6 1 ## 6 germ-4_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-4 1 ## X Y y1 y1$date y2 y2$date y3 y3$date desease ## 1 A 1 14.32724 2017-07-15 41.85377 2017-07-15 66.05498 2017-07-15 low ## 2 A 2 23.03428 2017-07-15 37.38970 2017-07-15 63.39528 2017-07-15 low ## 3 A 3 24.91349 2017-07-15 38.38628 2017-07-15 60.52710 2017-07-15 high ## 4 A 4 24.99078 2017-07-15 39.72205 2017-07-15 60.80393 2017-07-15 low ## 5 A 5 18.95340 2017-07-15 46.60443 2017-07-15 53.71210 2017-07-15 high ## 6 B 1 21.31660 2017-07-15 49.94656 2017-07-15 60.71978 2017-07-15 medium ## vigor y1$date_julian y2$date_julian y3$date_julian ## 1 l 195 195 195 ## 2 l 195 195 195 ## 3 h 195 195 195 ## 4 l 195 195 195 ## 5 m 195 195 195 ## 6 l 195 195 195 3.6.3.4 Run the model To run model GxE on the dataset, used the function model_GxE. You can run it on one variable. out_ammi = model_GxE(data_model_GxE, variable = &quot;y1&quot;, gxe_analysis = &quot;AMMI&quot;) ## AMMI model done for y1 out_ammi is a list containing three elements : info : a list with variable and gxe_analysis out_ammi$info ## $variable ## [1] &quot;y1&quot; ## ## $gxe_analysis ## [1] &quot;AMMI&quot; ANOVA a list with five elements : model out_ammi$ANOVA$model ## ## Call: ## stats::lm(formula = variable ~ germplasm * location + block %in% ## location, data = data) ## ## Coefficients: ## (Intercept) germplasm1 germplasm2 ## 20.70849 0.50554 0.63312 ## germplasm3 germplasm4 germplasm5 ## -1.20916 0.29679 0.35626 ## germplasm6 germplasm7 germplasm8 ## 1.33065 -1.52504 -0.56769 ## germplasm9 germplasm10 germplasm11 ## -0.73263 -0.34611 0.37692 ## germplasm12 germplasm13 germplasm14 ## -2.08334 -0.72075 -0.38939 ## germplasm15 germplasm16 germplasm17 ## 1.09734 -1.19621 0.16386 ## germplasm18 germplasm19 location1 ## 0.72661 1.49549 -0.44147 ## location2 germplasm1:location1 germplasm2:location1 ## 4.88085 1.09629 -0.60915 ## germplasm3:location1 germplasm4:location1 germplasm5:location1 ## 0.81094 0.91505 0.70964 ## germplasm6:location1 germplasm7:location1 germplasm8:location1 ## 2.42945 -3.58258 -0.35926 ## germplasm9:location1 germplasm10:location1 germplasm11:location1 ## 3.36809 0.77027 1.18556 ## germplasm12:location1 germplasm13:location1 germplasm14:location1 ## -3.67906 -3.89984 0.86540 ## germplasm15:location1 germplasm16:location1 germplasm17:location1 ## 0.33758 -0.35726 0.72636 ## germplasm18:location1 germplasm19:location1 germplasm1:location2 ## -0.33219 -0.33242 -2.03698 ## germplasm2:location2 germplasm3:location2 germplasm4:location2 ## -1.15072 -2.28962 -3.06243 ## germplasm5:location2 germplasm6:location2 germplasm7:location2 ## 3.82029 -1.85852 0.06938 ## germplasm8:location2 germplasm9:location2 germplasm10:location2 ## 4.47337 -1.71149 -1.52013 ## germplasm11:location2 germplasm12:location2 germplasm13:location2 ## -0.40986 -0.43476 1.55058 ## germplasm14:location2 germplasm15:location2 germplasm16:location2 ## 1.83102 -1.18392 3.30243 ## germplasm17:location2 germplasm18:location2 germplasm19:location2 ## -2.87038 2.27662 0.89072 ## locationloc-1:block1 locationloc-2:block1 locationloc-3:block1 ## -0.93928 -0.42509 -1.23391 ## locationloc-1:block2 locationloc-2:block2 locationloc-3:block2 ## -0.22936 0.54463 1.20472 anova_model out_ammi$ANOVA$anova_model ## Analysis of Variance Table ## ## Response: variable ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## germplasm 19 190.66 10.03 0.3712 0.9921 ## location 2 2623.54 1311.77 48.5185 5.69e-16 *** ## germplasm:location 38 825.18 21.72 0.8032 0.7778 ## location:block 6 115.34 19.22 0.7110 0.6414 ## Residuals 114 3082.16 27.04 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 germplasm_effects a list of two elements : effects out_ammi$ANOVA$germplasm_effects$effects ## germ-1 germ-10 germ-11 germ-12 germ-13 germ-14 ## 0.5055402 0.6331183 -1.2091564 0.2967890 0.3562593 1.3306487 ## germ-15 germ-16 germ-17 germ-18 germ-19 germ-2 ## -1.5250386 -0.5676933 -0.7326310 -0.3461143 0.3769158 -2.0833355 ## germ-20 germ-3 germ-4 germ-5 germ-6 germ-7 ## -0.7207485 -0.3893941 1.0973419 -1.1962053 0.1638570 0.7266050 ## germ-8 germ-9 ## 1.4954919 1.7877499 intra_variance out_ammi$ANOVA$germplasm_effects$intra_variance ## germ-1 germ-10 germ-11 germ-12 germ-13 germ-14 germ-15 ## 15.965283 57.489583 20.790956 28.830542 26.605904 23.161228 17.215151 ## germ-16 germ-17 germ-18 germ-19 germ-2 germ-20 germ-3 ## 12.059959 11.686595 9.479899 28.873479 3.196085 6.935395 16.472166 ## germ-4 germ-5 germ-6 germ-7 germ-8 germ-9 ## 23.173849 17.368449 6.871368 20.497187 24.386542 14.210313 location_effects out_ammi$ANOVA$location_effects$effects ## loc-1 loc-2 loc-3 ## -0.4414718 4.8808480 -4.4393762 interaction_matrix out_ammi$ANOVA$interaction_matrix ## loc-1 loc-2 loc-3 ## germ-1 3.2888840 -6.1109476 2.8220636 ## germ-10 -1.8274574 -3.4521497 5.2796071 ## germ-11 2.4328152 -6.8688494 4.4360343 ## germ-12 2.7451353 -9.1872828 6.4421475 ## germ-13 2.1289332 11.4608593 -13.5897926 ## germ-14 7.2883513 -5.5755577 -1.7127936 ## germ-15 -10.7477266 0.2081494 10.5395772 ## germ-16 -1.0777893 13.4201231 -12.3423338 ## germ-17 10.1042791 -5.1344588 -4.9698203 ## germ-18 2.3107988 -4.5603999 2.2496011 ## germ-19 3.5566803 -1.2295908 -2.3270895 ## germ-2 -11.0371806 -1.3042889 12.3414695 ## germ-20 -11.6995299 4.6517539 7.0477760 ## germ-3 2.5961932 5.4930572 -8.0892504 ## germ-4 1.0127320 -3.5517623 2.5390302 ## germ-5 -1.0717718 9.9072942 -8.8355224 ## germ-6 2.1790898 -8.6111402 6.4320504 ## germ-7 -0.9965810 6.8298624 -5.8332814 ## germ-8 -0.9972688 2.6721465 -1.6748777 ## germ-9 -0.1885867 0.9431820 -0.7545954 PCA : PCA object from FactoMineR out_ammi$PCA ## **Results for the Principal Component Analysis (PCA)** ## The analysis was performed on 20 individuals, described by 3 variables ## *The results are available in the following objects: ## ## name description ## 1 &quot;$eig&quot; &quot;eigenvalues&quot; ## 2 &quot;$var&quot; &quot;results for the variables&quot; ## 3 &quot;$var$coord&quot; &quot;coord. for the variables&quot; ## 4 &quot;$var$cor&quot; &quot;correlations variables - dimensions&quot; ## 5 &quot;$var$cos2&quot; &quot;cos2 for the variables&quot; ## 6 &quot;$var$contrib&quot; &quot;contributions of the variables&quot; ## 7 &quot;$ind&quot; &quot;results for the individuals&quot; ## 8 &quot;$ind$coord&quot; &quot;coord. for the individuals&quot; ## 9 &quot;$ind$cos2&quot; &quot;cos2 for the individuals&quot; ## 10 &quot;$ind$contrib&quot; &quot;contributions of the individuals&quot; ## 11 &quot;$call&quot; &quot;summary statistics&quot; ## 12 &quot;$call$centre&quot; &quot;mean of the variables&quot; ## 13 &quot;$call$ecart.type&quot; &quot;standard error of the variables&quot; ## 14 &quot;$call$row.w&quot; &quot;weights for the individuals&quot; ## 15 &quot;$call$col.w&quot; &quot;weights for the variables&quot; 3.6.3.5 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.1.2. 3.6.3.5.1 Check the model Once the model is run, it is necessary to check if the outputs can be taken with confidence. This step is needed before going ahead in the analysis (in fact, object used in the next functions must come from check_model()). out_check_ammi = check_model(out_ammi) out_check_ammi is a list containing four elements : model_GxE the output from the model data_ggplot a list containing information for ggplot: data_ggplot_residuals a list containing : data_ggplot_normality data_ggplot_skewness_test data_ggplot_kurtosis_test data_ggplot_shapiro_test data_ggplot_qqplot data_ggplot_variability_repartition_pie data_ggplot_var_intra 3.6.3.5.2 Visualize outputs Once the computation is done, you can visualize the results with plot() p_out_check_ammi = plot(out_check_ammi) p_out_check_ammi is a list with: residuals histogram : histogram with the distribution of the residuals p_out_check_ammi$residuals$histogram ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qqplot p_out_check_ammi$residuals$qqplot points p_out_check_ammi$residuals$points variability_repartition : pie with repartition of SumSq for each factor p_out_check_ammi$variability_repartition variance_intra_germplasm : repartition of the residuals for each germplasm (see Details for more information) With the hypothesis than the micro-environmental variation is equaly distributed on all the individuals (i.e. all the plants), the distribution of each germplasm represent the intra-germplasm variance. This has to been seen with caution: If germplasm have no intra-germplasm variance (i.e. pure line or hybrides) then the distribution of each germplasm represent only the micro-environmental variation. If germplasm have intra-germplasm variance (i.e. population such as landraces for example) then the distribution of each germplasm represent the micro-environmental variation plus the intra-germplasm variance. p_out_check_ammi$variance_intra_germplasm pca_composante_variance : variance caught by each dimension of the PCA run on the interaction matrix p_out_check_ammi$pca_composante_variance 3.6.3.6 Get and visualize mean comparisons The method to compute mean comparison are explained in section 3.1.2.1.3. 3.6.3.6.1 Get mean comparisons Get mean comparisons with mean_comparisons(). out_mean_comparisons_ammi = mean_comparisons(out_check_ammi, p.adj = &quot;bonferroni&quot;) out_mean_comparisons_ammi is a list of three elements: info : a list with variable and gxe_analysis data_ggplot_LSDbarplot_germplasm data_ggplot_LSDbarplot_location data_ggplot_LSDbarplot_year 3.6.3.6.2 Visualize mean comparisons p_out_mean_comparisons_ammi = plot(out_mean_comparisons_ammi) p_out_mean_comparisons_ammi is a list of three elements with barplots : For each element of the list, there are as many graph as needed with nb_parameters_per_plot parameters per graph. Letters are displayed on each bar. Parameters that do not share the same letters are different regarding type I error (alpha) and alpha correction. The error I (alpha) and the alpha correction are displayed in the title. germplasm : mean comparison for germplasm pg = p_out_mean_comparisons_ammi$germplasm names(pg) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; pg$`1` location : mean comparison for location pl = p_out_mean_comparisons_ammi$location names(pl) ## [1] &quot;1&quot; pl$`1` year : mean comparison for year Here there are no more than 2 years in the data set so it is NULL p_out_mean_comparisons_ammi$year ## NULL 3.6.3.7 Get and visualize biplot The biplot represents information about the percentages of total variation explained by the two axes. It has to be linked to the total variation caught by the interaction. If the total variation is small, then the biplot is useless. If the total variation is high enought, then the biplot is useful if the two first dimension represented catch enought variation (the more the better). 3.6.3.7.1 Get biplot out_biplot_ammi = biplot_data(out_check_ammi) 3.6.3.7.2 Visualize biplot p_out_biplot_ammi = plot(out_biplot_ammi) p_out_biplot_ammi is a list of three elements : ecovalence Ecovalence from Wricke (1962) give part of interaction variance taken by germplasm and location. This parameter provides indications on the contribution of each variety to the interaction term and therefore on its stability over the different farms with respect to the productivity potential of each of them. It is generally described as a dynamic stability indicator (Becker and Leon 1988). A low ecovalence means low interaction, i.e. more stability. Ecovalance of germplasm \\(i\\) is \\(W_{i}=\\sum_{i}^{n} (\\eta_{i}\\nu_{j})^{2}\\) Ecovalance of location \\(j\\) is \\(W_{j}=\\sum_{j}^{n} (\\eta_{i}\\nu_{j})^{2}\\). Ecovalances are represented in fonction of mean effects by germplasm and location. p_out_biplot_ammi$ecovalence interaction which displays the interaction matrix p_out_biplot_ammi$interaction biplot being a list of four elements : p_out_biplot_ammi$biplot$simple_biplot Regarding the other elements of the list, it returns NULL as these visualisation is only done for gxe_analysis = &quot;GGE&quot;. p_out_biplot_ammi$biplot$which_won_where ## NULL p_out_biplot_ammi$biplot$mean_vs_stability ## NULL p_out_biplot_ammi$biplot$discrimitiveness_vs_representativeness ## NULL 3.6.3.8 Get and vizualise groups of parameters 3.6.3.8.1 Get groups of parameters In order to cluster locations or germplasms, you may use mulivariate analysis on a matrix with several variables in columns and parameter in rows. This is done with parameter_groups() which do a PCA on this matrix. Clusters are done based on HCPC method as explained here Lets’ have an example with three variables. First run the models out_ammi_2 = model_GxE(data_model_GxE, variable = &quot;y2&quot;, gxe_analysis = &quot;AMMI&quot;) ## AMMI model done for y2 out_ammi_3 = model_GxE(data_model_GxE, variable = &quot;y3&quot;, gxe_analysis = &quot;AMMI&quot;) ## AMMI model done for y3 Then check the models out_check_ammi_2 = check_model(out_ammi_2) out_check_ammi_3 = check_model(out_ammi_3) Then run the function for germplasm. It can also be done on location or intra germplasm variance out_parameter_groups = parameter_groups( list(&quot;y1&quot; = out_check_ammi, &quot;y2&quot; = out_check_ammi_2, &quot;y3&quot; = out_check_ammi_3), &quot;germplasm&quot; ) out_parameter_groups is list of two elements: obj.pca : the PCA object from FactoMineR::PCA() clust, a list of two elements: res.hcpc : the HCPC object from FactoMineR::HCPC() clust : the dataframe with cluster assigned to each individual 3.6.3.8.2 Visualize groups of parameters Visualize outputs with plot p_germplasm_group = plot(out_parameter_groups) p_germplasm_group is list of two elements : pca : a list with three elements on the PCA on the group of parameters : composante_variance : variance caught by each dimension of the PCA p_germplasm_group$pca$composante_variance ind : graph of individuals p_germplasm_group$pca$ind var : graph of variables p_germplasm_group$pca$var clust : output from factextra::fviz_cluster(), a list of number of cluster + 1 element cl = p_germplasm_group$clust names(cl) ## [1] &quot;cluster_all&quot; &quot;cluster_1&quot; &quot;cluster_2&quot; &quot;cluster_3&quot; cl$cluster_all cl$cluster_1 ## Warning: Removed 3 rows containing non-finite values (stat_mean). ## Warning: Removed 3 rows containing missing values (geom_point). ## Warning: Removed 3 rows containing missing values (geom_text_repel). 3.6.3.9 post hoc analysis to visualize variation repartition for several variables list_out_check_model = list(out_check_ammi, out_check_ammi_2, out_check_ammi_3) names(list_out_check_model) = c(&quot;ammi_1&quot;, &quot;ammi_2&quot;, &quot;ammi_3&quot;) post_hoc_variation(list_out_check_model) 3.6.3.10 Apply the workflow to several variables If you wish to apply the AMMI workflow to several variables, you can use lapply() with the following code : workflow_gxe = function(x, gxe){ out_gxe = model_GxE(data_model_GxE, variable = x, gxe_analysis = gxe) out_check_gxe = check_model(out_gxe) p_out_check_gxe = plot(out_check_gxe) out_mean_comparisons_gxe = mean_comparisons(out_check_gxe, p.adj = &quot;bonferroni&quot;) p_out_mean_comparisons_gxe = plot(out_mean_comparisons_gxe) out_biplot_gxe = biplot_data(out_check_gxe) p_out_biplot_gxe = plot(out_biplot_gxe) out = list( &quot;out_gxe&quot; = out_gxe, &quot;out_check_gxe&quot; = out_check_gxe, &quot;p_out_check_gxe&quot; = p_out_check_gxe, &quot;out_mean_comparisons_gxe&quot; = out_mean_comparisons_gxe, &quot;p_out_mean_comparisons_gxe&quot; = p_out_mean_comparisons_gxe, &quot;out_biplot_gxe&quot; = out_biplot_gxe, &quot;p_out_biplot_gxe&quot; = p_out_biplot_gxe ) return(out) } vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;) out = lapply(vec_variables, workflow_gxe, &quot;AMMI&quot;) ## AMMI model done for y1 ## AMMI model done for y2 ## AMMI model done for y3 names(out) = vec_variables out_parameter_groups = parameter_groups( list(&quot;y1&quot; = out$y1$out_check_gxe, &quot;y2&quot; = out$y2$out_check_gxe, &quot;y3&quot; = out$y3$out_check_gxe), &quot;germplasm&quot; ) p_germplasm_group = plot(out_parameter_groups) 3.6.4 GGE (M6b) 3.6.4.1 Theory of the model The experimental design used is fully replicated (D1). The GGE model is the same as the AMMI model except that the PCA is done on a matrix centered on the locations: germplasm and interaction effects are merged10 (Gauch 2006)(Gauch, Piepho, and Annicchiarico 2008)(Yan et al. 2007). The model is based on frequentist statistics (section 3.1.2.1). The GGE model can be written as followed: \\(Y_{ijk} = \\mu + \\theta_{j} + rep_{k}(\\theta_{j}) + \\sum_{n}^{N} \\lambda_{n} \\gamma_{in} \\omega_{jn} + \\varepsilon_{ijk}; \\quad \\varepsilon_{ijk} \\sim \\mathcal{N} (0,\\sigma^2)\\) with, \\(Y_{ijk}\\) the phenotypic value for replication \\(k\\), germplasm \\(i\\) and location \\(j\\), \\(\\mu\\) the general mean, \\(\\theta_{j}\\) the effect of location \\(j\\), \\(rep_{k}(\\theta_{j})\\) the effect of replication \\(k\\) nested in location, \\(N\\) the number of dimension (PCA componant) which has as maximum value the number of location, \\(\\lambda_{n}\\) the eigen value for componant \\(n\\), \\(\\gamma_{in}\\) the eigen vector for germplasm \\(i\\) for componant \\(n\\), \\(\\omega_{jn}\\) the eigen vector for location \\(j\\) for componant \\(n\\). \\(\\varepsilon_{ijk}\\) the residuals. or, if there is year effect: \\(Y_{ijkl} = \\mu + \\theta_{j} + rep_{k}(\\theta_{j}\\beta_{l}) +\\sum_{n}^{N} \\lambda_{n} \\gamma_{in} \\omega_{jn} + \\beta_{l} + \\beta_{l}\\alpha_{i} + \\beta_{l}\\theta_{j} + \\varepsilon_{ijk}; \\quad \\varepsilon_{ijk} \\sim \\mathcal{N} (0,\\sigma^2)\\) With, \\(Y_{ijkl}\\) the phenotypic value for replication \\(k\\), germplasm \\(i\\), location \\(j\\) and year \\(l\\), \\(\\beta_{l}\\) the year \\(l\\) effect, \\(\\beta_{l}\\alpha_{i}\\) the year \\(\\times\\) germplasm interaction effect, \\(\\beta_{l}\\theta_{j}\\) the year \\(\\times\\) location interaction effect, \\(\\varepsilon_{ijk}\\) the residuals, and all other effects are the same as in the previous model. 3.6.4.2 Steps with PPBstats For GGE analysis, everything is exactly the same than for AMMI analysis except you should settle gxe_analysis = &quot;GGE&quot; in model_GxE. You can follow these steps (Figure 3.2): Format the data with format_data_PPBstats() Run the model with model_GxE() and gxe_analysis = &quot;GGE&quot; Check model outputs with graphs to know if you can continue the analysis with check_model() Get mean comparisons for each factor with mean_comparisons() and vizualise it with plot() Get and visualize biplot with biplot_data() and plot() Get groups of each parameters with parameters_groups() and visualise it with plot() We will not details everything as it the same than AMMI in the code. Of course the calculation is different on the interaction matrix so you’ll get different results. The workflow is therefore : 3.6.4.3 Format the data data(data_model_GxE) data_model_GxE = format_data_PPBstats(data_model_GxE, type = &quot;data_agro&quot;) ## data has been formated for PPBstats functions. head(data_model_GxE) ## seed_lot location long lat year germplasm block ## 1 germ-12_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-12 1 ## 2 germ-1_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-1 1 ## 3 germ-18_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-18 1 ## 4 germ-14_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-14 1 ## 5 germ-6_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-6 1 ## 6 germ-4_loc-1_2005_0001 loc-1 0.616363 44.20314 2005 germ-4 1 ## X Y y1 y1$date y2 y2$date y3 y3$date desease ## 1 A 1 14.32724 2017-07-15 41.85377 2017-07-15 66.05498 2017-07-15 low ## 2 A 2 23.03428 2017-07-15 37.38970 2017-07-15 63.39528 2017-07-15 low ## 3 A 3 24.91349 2017-07-15 38.38628 2017-07-15 60.52710 2017-07-15 high ## 4 A 4 24.99078 2017-07-15 39.72205 2017-07-15 60.80393 2017-07-15 low ## 5 A 5 18.95340 2017-07-15 46.60443 2017-07-15 53.71210 2017-07-15 high ## 6 B 1 21.31660 2017-07-15 49.94656 2017-07-15 60.71978 2017-07-15 medium ## vigor y1$date_julian y2$date_julian y3$date_julian ## 1 l 195 195 195 ## 2 l 195 195 195 ## 3 h 195 195 195 ## 4 l 195 195 195 ## 5 m 195 195 195 ## 6 l 195 195 195 3.6.4.4 Run the model out_gge = model_GxE(data_model_GxE, variable = &quot;y1&quot;, gxe_analysis = &quot;GGE&quot;) ## GGE model done for y1 3.6.4.5 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.1.2. 3.6.4.5.1 Check the model out_check_gge = check_model(out_gge) 3.6.4.5.2 Visualize outputs p_out_check_gge = plot(out_check_gge) 3.6.4.6 Get and visualize mean comparisons The method to compute mean comparison are explained in section 3.1.2.1.3. 3.6.4.6.1 Get mean comparisons out_mean_comparisons_gge = mean_comparisons(out_check_gge, p.adj = &quot;bonferroni&quot;) 3.6.4.6.2 Visualize mean comparisons p_out_mean_comparisons_gge = plot(out_mean_comparisons_gge) 3.6.4.7 Get and visualize biplot 3.6.4.7.1 Get biplot out_biplot_gge = biplot_data(out_check_gge) 3.6.4.7.2 Visualize biplot p_out_biplot_gge = plot(out_biplot_gge) Compared to AMMI analysis, in the output of p_out_biplot_gge, which_won_where, mean_vs_stability and discrimitiveness_vs_representativeness are displayed. The description of these following graphs are greatly inspired from Ceccarelli (2012). biplot = p_out_biplot_gge$biplot The which won where graph This graph allow to detect location where germplasm (and the interaction) behave better : ‘which won where’ (Gauch, Piepho, and Annicchiarico 2008,@yan_gge_2007). The germplasms which have the largest value in a sector “win” in the location present in that sector. The information is summarized in the legend of the plot. See ?plot.PPBstats for more details on this plot. biplot$which_won_where The mean vs stability graph. mean A red circle define the average location. An high score mean a greater mean performance of an entry. Entries with a score above zero means entries with above-average means. Entries with a score below zero means entries with below-average means. Note that the distance from the biplot origin to the average location circle (represented with an arrow), is a measure of the relative importance of the germplasm main effect versus the entry by location interaction. The longer the arrow is, the more important is germplasm effect and the more meaningful is the selection based on mean performance. biplot$mean_vs_stability$mean_performance stability This information is related to the ecovalence graph. The score is equal to the length of the projection. A high score represents a low stability (i.e. an high entry by location interaction). biplot$mean_vs_stability$stability_performance The discrimitiveness vs representativeness graph. It is interessting to assess the ability of the locations to discriminate the germplasms and their ability to represent the target locations. The closer a given location is next to the averge location (represented by a red circle), the more desirable it is judged on both discrimination and representativeness. discrimitiveness The higher the value, the highest the discrimitiveness for locations. biplot$discrimitiveness_vs_representativeness$discrimitiveness representativeness The highest the value, the less representative the location. biplot$discrimitiveness_vs_representativeness$representativeness discrimitiveness vs representativeness The location combining better score (i. e.discrimination and representativeness) are the ones that could be used to test germplasms as they are more representative of all the locations. This has to be done severals year to get robust results. The highest the score, the more representative the location. biplot$discrimitiveness_vs_representativeness$discrimitiveness_vs_representativeness 3.6.4.8 Get and vizualise groups of parameters 3.6.4.8.1 Get groups of parameters # First run the models gge_2 = model_GxE(data_model_GxE, variable = &quot;y2&quot;, gxe_analysis = &quot;GGE&quot;) ## GGE model done for y2 gge_3 = model_GxE(data_model_GxE, variable = &quot;y3&quot;, gxe_analysis = &quot;GGE&quot;) ## GGE model done for y3 # Then check the models out_check_gge_2 = check_model(gge_2) out_check_gge_3 = check_model(gge_3) # Then run the function for germplasm. It can also be done on location or intra germplasm variance out_parameter_groups = parameter_groups( list(&quot;y1&quot; = out_check_gge, &quot;y2&quot; = out_check_gge_2, &quot;y3&quot; = out_check_gge_3), &quot;germplasm&quot; ) 3.6.4.8.2 Visualize groups of parameters p_germplasm_group = plot(out_parameter_groups) 3.6.4.9 Apply the workflow to several variables If you wish to apply the AMMI workflow to several variables, you can use the function workflow_gxe() presented in section @ref{workflow-gxe} with the following code : vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;) out = lapply(vec_variables, workflow_gxe, &quot;GGE&quot;) ## GGE model done for y1 ## GGE model done for y2 ## GGE model done for y3 names(out) = vec_variables out_parameter_groups = parameter_groups( list(&quot;y1&quot; = out$y1$out_check_gxe, &quot;y2&quot; = out$y2$out_check_gxe, &quot;y3&quot; = out$y3$out_check_gxe), &quot;germplasm&quot; ) p_germplasm_group = plot(out_parameter_groups) 3.6.5 Hierarchical Bayesian \\(G \\times E\\) model to analyse \\(G \\times E\\) interaction in the network of farms (M7b) At the network level, there is a large number of germplasm \\(\\times\\) environment combinations that are missing, leading to a poor estimation of germplasm, environment and interaction effects. Hence, model_bh_GxE should be implemented. For model_bh_GxE, it gives nice results with at least around 75 environments and 120 germplasms present in at least two environments (95% of missing \\(G \\times E\\) combinations) (Rivière et al. 2016). It is based on bayesian statistics (section 3.1.2.2). 3.6.5.1 Theory of the model The experimental design used is satellite and regional farms (D4). The model is describe in Rivière et al. (2016). The phenotypic value \\(Y_{ij}\\) for a given variable \\(Y\\), germplasm \\(i\\) and environment \\(j\\), is modeled as : \\(Y_{ij} = \\alpha_{i} + \\theta_{j} + \\eta_{i}\\theta_{j} + \\varepsilon_{ij} ; \\quad \\varepsilon_{ij} \\sim \\mathcal{N} (0,\\sigma^2_{e})\\) for \\(i = 1,\\ldots, I\\) and \\(j = 1,\\ldots, J\\), where \\(I\\) is the number of germplasms, \\(J\\) is the number of environments, \\(\\alpha_{i}\\) is the main effect of germplasm \\(i\\), \\(\\theta_{j}\\) is the main effect of environnment \\(j\\), \\(\\varepsilon_{ij}\\) is the residual and \\(\\mathcal{N} (0,\\sigma^2_{e})\\) is the normal distribution with mean 0 and variance \\(\\sigma^2_{e}\\). The interaction between germplasm \\(i\\) and environment \\(j\\) was divided into a multiplicative term \\(\\eta_{i}\\theta_{j}\\) and a remaining term that contributed to the residual \\(\\varepsilon_{ij}\\). This model is further written as : \\(Y_{ij} = \\alpha_{i} + \\beta_{i} \\theta_{j} + \\varepsilon_{ij}; \\quad \\varepsilon_{ij} \\sim \\mathcal{N} (0,\\sigma_{\\varepsilon})\\), Where \\(\\beta_{i} = (1 + \\eta_{i})\\) is the sensitivity of germplasm \\(i\\) to environments. This model is known as the Finlay Wilkinson model or as joint regression (Finlay and Wilkinson 1963). Germplasms’ sensitivity quantifies the stability of germplasms’ performances over environments. The average sensitivity is equal to 1 so that a gemplasm with \\(\\beta_{i} &gt; 1\\) (\\(\\beta_{i} &lt; 1\\)) is more (less) sensitive to environments than a germplasm with the average sensitivity (Nabugoomu, Kempton, and Talbot 1999). Given the high disequilibrium of the data and the large amount of data, this model is implemented with a hierarchical Bayesian approach. We use hierarchical priors for \\(\\alpha_i\\), \\(\\beta_i\\) and \\(\\theta_j\\) and a vague prior for \\(\\sigma_{\\varepsilon}\\). \\(\\alpha_{i} \\sim \\mathcal{N} (\\mu,\\sigma^2_{\\alpha}), \\quad \\beta_{i} \\sim \\mathcal{N} (1,\\sigma^2_{\\beta}), \\quad \\theta_{j} \\sim \\mathcal{N} (0,\\sigma^2_{\\theta}), \\quad \\sigma^{-2}_{\\varepsilon} \\sim \\mathcal{G}amma (10^{-6},10^{-6})\\), where \\(\\mu\\), \\(\\sigma^2_{\\alpha}\\), \\(\\sigma^2_{\\beta}\\) and \\(\\sigma^2_{\\theta}\\) are unknown parameters. The mean of \\(\\beta_i\\) is set to 1 (Nabugoomu, Kempton, and Talbot 1999). Then, we place weakly-informative priors on the hyperparmeters \\(\\mu\\), \\(\\sigma^2_{\\alpha}\\), \\(\\sigma^2_{\\beta}\\) and \\(\\sigma^2_{\\theta}\\): \\(\\mu \\sim \\mathcal{N} (\\nu,\\nu^2), \\quad \\sigma_{\\alpha} \\sim \\mathcal{U}niforme (0,\\nu), \\quad \\sigma_{\\beta} \\sim \\mathcal{U}niforme (0,1), \\quad \\sigma_{\\theta} \\sim \\mathcal{U}niforme (0,\\nu)\\), where \\(\\nu\\) is the arithmetic mean of the data : \\(\\nu = \\sum_{ij} {Y_{ij}/n}\\) with \\(n\\) the number of observations. Uniform priors are used for \\(\\sigma^2_{\\alpha}\\), \\(\\sigma^2_{\\beta}\\) and \\(\\sigma^2_{\\theta}\\) to reduce the influence of these priors on posterior results (Gelman and Rubin 1992). The support of these priors take account of the prior knowledge that \\(\\sigma^2_{\\alpha}\\), \\(\\sigma^2_{\\beta}\\) and \\(\\sigma^2_{\\theta}\\) is expected to be respectively smaller than \\(\\nu\\), 1 and \\(\\nu\\). Initial values for each chain are taken randomly except for \\(\\mu\\), \\(\\sigma_{\\alpha}\\) and \\(\\sigma_{\\theta}\\) whose initial values are equal to their posterior median from additive model (i.e. model with \\(\\forall i, \\beta_{i}=1\\)). The main parameter of interest are the germplasm main effects (\\(\\alpha_{i}, i = 1,\\ldots, I\\)), the environment main effects (\\(\\theta_{j}, j = 1,\\ldots, J\\)) and the germplasm sensitivities (\\(\\beta_{i}, i = 1,\\ldots, I\\)). For \\(\\alpha_i\\), the average posterior response of each germplasm over the environments of the network is calculated as: \\(\\gamma_i = \\alpha_i + \\beta_{i} \\bar{\\theta}\\), where \\(\\bar{\\theta} = \\sum_{}^{J} \\theta_j/J\\). To simplify, the \\(\\alpha_i\\) notation is kept instead of \\(\\gamma_i\\) (i.e. \\(\\alpha_i = \\gamma_i\\)). But keep in mind it has been corrected. 3.6.5.2 Steps with PPBstats For model_bh_GxE, you can follow these steps (Figure 3.2): Format the data with format_data_PPBstats() Run the model with model_bh_GxE() Check model outputs with graphs to know if you can continue the analysis with check_model() Perform cross validation studies with cross_validation_model_bh_GxE() in order to assess the quality of the model Get mean comparisons for each factor with mean_comparisons() and vizualise it with plot() Get groups of parameters for \\(\\alpha\\), \\(\\beta\\) and \\(\\theta\\) with parameters_groups() and visualise it with plot() Predict the past with predict_the_past_model_bh_GxE() and vizualise it with plot() 3.6.5.3 Format the data The values for \\(\\alpha_i\\), \\(\\beta_i\\), \\(\\theta_j\\) are the real value taken to create the dataset for y1. This dataset is representative of data you can get in a PPB programme. data(data_model_bh_GxE) data_model_bh_GxE = format_data_PPBstats(data_model_bh_GxE, type = &quot;data_agro&quot;) ## Warning in format_data_PPBstats.data_agro(data): Column &quot;long&quot; is needed to ## get map and not present in data. ## Warning in format_data_PPBstats.data_agro(data): Column &quot;lat&quot; is needed to ## get map and not present in data. ## data has been formated for PPBstats functions. head(data_model_bh_GxE) ## seed_lot location year germplasm block X Y y1 ## 1 germ-1_loc-23_2005_0001 loc-23 2005 germ-1 1 1 1 7.926204 ## 2 germ-1_loc-36_2005_0001 loc-36 2005 germ-1 1 2 2 9.772076 ## 3 germ-1_loc-10_2009_0001 loc-10 2009 germ-1 1 3 3 9.199745 ## 4 germ-1_loc-21_2009_0001 loc-21 2009 germ-1 1 4 4 10.131745 ## 5 germ-1_loc-32_2007_0001 loc-32 2007 germ-1 1 5 5 14.329280 ## 6 germ-1_loc-22_2005_0001 loc-22 2005 germ-1 1 6 6 8.709140 ## y1$date alpha_i-1 beta_i-1 theta_j-1 y2 y2$date y3 ## 1 2017-07-29 10.25349 2.170004 -0.7776704 18.28223 2017-07-15 31.57931 ## 2 2017-07-10 10.25349 2.170004 -0.7531355 18.41129 2017-07-22 31.44957 ## 3 2017-07-15 10.25349 2.170004 0.1163468 18.94209 2017-07-21 33.19169 ## 4 2017-07-02 10.25349 2.170004 0.2755013 24.86338 2017-07-06 29.34573 ## 5 2017-07-06 10.25349 2.170004 1.8495949 16.09421 2017-07-15 32.36811 ## 6 2017-07-21 10.25349 2.170004 -0.5750281 17.93222 2017-07-29 37.85269 ## y3$date y1$date_julian y2$date_julian y3$date_julian ## 1 2017-07-21 209 195 201 ## 2 2017-07-29 190 202 209 ## 3 2017-07-15 195 201 195 ## 4 2017-07-10 182 186 190 ## 5 2017-07-06 186 195 186 ## 6 2017-07-29 201 209 209 3.6.5.4 Run the model To run model_bh_GxE on the dataset, use the function model_bh_GxE(). You can run it on one variable. Here it is on thousand kernel weight (tkw) By default, model_bh_GxE returns posteriors for \\(\\alpha_i\\) (return.alpha = TRUE), \\(\\sigma_{\\alpha}\\) (return.sigma_alpha = TRUE), \\(\\beta_i\\) (return.beta = TRUE), \\(\\sigma_{\\beta}\\) (return.sigma_beta = TRUE), \\(\\theta_j\\) (return.theta = TRUE), \\(\\sigma_{\\theta}\\) (return.sigma_theta = TRUE) and \\(\\sigma_{\\epsilon}\\) (return.sigma_epsilon = TRUE). You can also get \\(\\epsilon_{ij}\\) with return.epsilon = TRUE. By default, DIC is not display, you may want this value to compare to other model (DIC = TRUE). DIC criterion is a generalization of the AIC criterion that can be used for hierarchical models (Spiegelhalter et al. 2002). The smaller the DIC value, the better the model (Plummer 2008). # out_model_bh_GxE = model_bh_GxE(data = data_model_bh_GxE, variable = &quot;y1&quot;, return.epsilon = TRUE) # Run additive model ... # Compiling model graph # Resolving undeclared variables # Allocating nodes # Graph information: # Observed stochastic nodes: 2379 # Unobserved stochastic nodes: 228 # Total graph size: 9834 # # Initializing model # # |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% # |**************************************************| 100% # |**************************************************| 100% # Run FWH model ... # Compiling model graph # Resolving undeclared variables # Allocating nodes # Graph information: # Observed stochastic nodes: 2379 # Unobserved stochastic nodes: 386 # Total graph size: 14913 # # Initializing model # # |++++++++++++++++++++++++++++++++++++++++++++++++++| 100% # |**************************************************| 100% # |**************************************************| 100% # |**************************************************| 100% # load(&quot;./data_PPBstats/out_model_bh_GxE.RData&quot;) It may be useful to see which germplasm were not use in the analysis because they were in only one environment. out_model_bh_GxE$germplasm.not.used ## NULL 3.6.5.5 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.2.2. 3.6.5.5.1 Check the model Once the model is run, it is necessary to check if the outputs can be taken with confidence. This step is needed before going ahead in the analysis (in fact, the MCMC object used in the next functions must come from check_model()!). # out_check_model_bh_GxE = check_model(out_model_bh_GxE) # The Gelman-Rubin test is running for each parameter ... # The two MCMC for each parameter converge thanks to the Gelman-Rubin test. load(&quot;./data_PPBstats/out_check_model_bh_GxE.RData&quot;) out_check_model_bh_GxE is a list containing three elements: MCMC : a data fame resulting from the concatenation of the two MCMC for each parameter. This object can be used for further analysis. There are as many columns than parameters and as many rows than iterations/thin (the thin value is 10 by default in the models). dim(out_check_model_bh_GxE$MCMC) ## [1] 20000 385 MCMC_conv_not_ok : a data fame resulting from the concatenation of the two MCMC for each parameter for environment where some parameters did not converge for mu and beta model2.presence.absence.matrix : a matrix germplasm x environment with the number of occurence in the data used for the model (i.e. with at least two germplasm by environments.) data_ggplot a list containing information for ggplot: alpha beta theta epsilon 3.6.5.5.2 Visualize outputs Once the computation is done, you can visualize the results with plot p_out_check_model_bh_GxE = plot(out_check_model_bh_GxE) ## The beta_i posterior distributions are done. ## The theta_j posterior distributions are done. ## The standardised residuals distributions are done. p_out_check_model_bh_GxE is a list with 4 elements: alpha_i : distribution of each alpha_i. There are as many graph as needed with nb_parameters_per_plot alpha_i per graph. p_a = p_out_check_model_bh_GxE$alpha_i names(p_a) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; ## [15] &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; p_a$`1` beta_i : distribution of each beta_i. There are as many graph as needed with nb_parameters_per_plot beta_i per graph. p_a = p_out_check_model_bh_GxE$beta_i names(p_a) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; ## [15] &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; p_a$`1` theta_j : distribution of each theta_j. There are as many graph as needed with nb_parameters_per_plot theta_j per graph. p_a = p_out_check_model_bh_GxE$theta_j names(p_a) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; p_a$`1` epsilon_ij : standardised residuals distribution. If the model went well it should be between -2 and 2. p_out_check_model_bh_GxE$epsilon_ij mcmc_not_converge_traceplot_density : a list with the plots of trace and density to check the convergence of the two MCMC only for chains that are not converging thanks to the Gelman-Rubin test. If all the chains converge, it is NULL p_out_check_model_bh_GxE$mcmc_not_converge_traceplot_density ## NULL Just for fun, you compare the posterior medians and the arithmetic means for the \\(\\alpha_i\\)’s. MCMC = out_check_model_bh_GxE$MCMC effects = apply(MCMC, 2, median) alpha_i_estimated = effects[grep(&quot;alpha\\\\[&quot;,names(effects))] names(alpha_i_estimated) = sapply(names(alpha_i_estimated), function(x){ sub(&quot;\\\\]&quot;, &quot;&quot;, sub(&quot;alpha\\\\[&quot;, &quot;&quot;, x)) } ) alpha_i = tapply(data_model_bh_GxE$alpha_i, data_model_bh_GxE$germplasm, mean, na.rm = TRUE) check_data = cbind.data.frame(alpha_i = alpha_i, alpha_i_estimated = alpha_i_estimated[names(alpha_i)]) Let’s have a look at the relation between both values. p = ggplot(check_data, aes(x = alpha_i, y = alpha_i_estimated)) p + stat_smooth(method = &quot;lm&quot;) + geom_point() 3.6.5.6 Perform cross validation studies This step is useful to assess the quality of the model. This step is higly computing consuming as model_bh_GxE is run as many time as there is value of \\(Y_{ij}\\) (i.e. number of rows of the data set). The complete cross validation is done with cross_validation_model_bh_GxE(): each Value of \\(Y_{ij}\\) is estimated by the entire data set without this value. The convergence is not check for each validation. If the parameters in the FWH converge, then it is assumed that the FWH in the cross validation converge as well. The model is run on dataset where germplasms are in three environments at least so the smallest data set where the cross valisation is run has germplasms present in two environments at least. You may parallelise to gain time with the mc.cores argument of the function. The number of iterations is set to 100 000 but you can change it with the nb_iterations argument. # out_cross_validation_model_bh_GxE = cross_validation_model_bh_GxE(data_model_bh_GxE, &quot;y1&quot;) # Note that it takes lots of time to run !!! load(&quot;./data_PPBstats/out_cross_validation_model_bh_GxE.RData&quot;) # to save lots of time head(out_cross_validation_model_bh_GxE) ## observed.value estimated.value ## 1 9.255871 8.439743 ## 2 11.730423 7.420068 ## 3 8.366394 10.902201 ## 4 9.897532 9.721544 ## 5 10.185193 9.643359 ## 6 9.373700 9.144640 The outputs are visualized with plot p_out_cv = plot(out_cross_validation_model_bh_GxE) p_out_cv is a list of two elements: plot : plot estimated.value = f(observed.value). The probability mean = 0 is display. The percentage of confidence is calculated with a t-test: \\(t = \\frac{m - 0}{s/\\sqrt{N}}\\) with, \\(N\\) the number of observations in the data set, \\(m = \\frac{1}{N} \\sum\\limits_{n=1}^N Y_{n} - \\hat{Y_{n}}\\), the average bias \\(s = \\sqrt{\\frac{1}{N-1} \\sum\\limits_{n=1}^N (Y_{n} - \\hat{Y_{n}})^2}\\), the standard deviation of the bias \\(t\\) follows a Student distribution with \\(N-1\\) degree of freedom. The percentage of confidence (i.e. the probability \\(H0\\): the bias is equal to zero) comes from this distribution. p_out_cv$plot ## Warning: Removed 1 rows containing non-finite values (stat_smooth). ## Warning: Removed 1 rows containing missing values (geom_point). regression : output of the model observed.value = a x estimated.value + b p_out_cv$regression ## ## Call: ## stats::lm(formula = observed.value ~ estimated.value, data = x) ## ## Coefficients: ## (Intercept) estimated.value ## 6.8258 0.3313 3.6.5.7 Get and visualize mean comparisons The method to compute mean comparison are explained in section ??. 3.6.5.7.1 Get mean comparisons For mean comparisons of parameters, it is the same method that presented in Section @ref{mean-comp}. It can be done for \\(\\alpha_i\\), \\(\\beta_i\\) and \\(\\theta_j\\). # model_bh_GxE_alpha = mean_comparisons(out_check_model_bh_GxE, parameter = &quot;alpha&quot;) # model_bh_GxE_beta = mean_comparisons(out_check_model_bh_GxE, parameter = &quot;beta&quot;, precision = 0.05) # model_bh_GxE_theta = mean_comparisons(out_check_model_bh_GxE, parameter = &quot;theta&quot;, precision = 0.05) load(&quot;./data_PPBstats/model_bh_GxE_alpha.RData&quot;) load(&quot;./data_PPBstats/model_bh_GxE_beta.RData&quot;) load(&quot;./data_PPBstats/model_bh_GxE_theta.RData&quot;) 3.6.5.7.2 Vizualise mean comparisons To see the output, use plot. There are as many graph as needed with nb_parameters_per_plot parameters per graph. For plot_type = &quot;barplot&quot;, Letters are displayed on each bar. Parameters that do not share the same letters are different regarding type I error (alpha) and alpha correction. The error I (alpha) and the alpha correction are displayed in the title. alpha = Imp means that no differences were possible to find. For plot_type = &quot;biplot-alpha-beta&quot;, the biplot with \\(\\alpha_i\\) on the x axis and \\(\\beta_i\\) on the y axis. p_a = plot(model_bh_GxE_alpha, plot_type = &quot;barplot&quot;) names(p_a$alpha) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; ## [15] &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; p_a$alpha$`1` p_b = plot(model_bh_GxE_beta, plot_type = &quot;barplot&quot;) names(p_b$beta) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; ## [15] &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; p_b$beta$`1` It is interessting to compare genetic effect versus sensibility to interaction. A germplasm with an high genetic effect and a low sensitivity to interaction (i.e. close to 0) may be a good candidate to sown. p_ab = plot(model_bh_GxE_alpha, model_bh_GxE_beta, plot_type = &quot;biplot-alpha-beta&quot;) p_ab$`1` p_t = plot(model_bh_GxE_theta, plot_type = &quot;barplot&quot;) names(p_t$theta) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; p_t$theta$`9` 3.6.5.8 Get and vizualise groups of parameters 3.6.5.8.1 Get groups of parameters In order to cluster environments or germplasms, you may use mulivariate analysis on a matrix with several variables in columns and parameter in rows. This is done with parameter_groups which do a PCA on this matrix. Clusters are done based on HCPC method as explained here http://www.sthda.com/english/wiki/hcpc-hierarchical-clustering-on-principal-components-hybrid-approach-2-2-unsupervised-machine-learning Lets’ have an example with three variables. First run the models # out_model_bh_GxE_y1 = model_bh_GxE(data_model_bh_GxE, variable = &quot;y1&quot;) # out_model_bh_GxE_y2 = model_bh_GxE(data_model_bh_GxE, variable = &quot;y2&quot;) # out_model_bh_GxE_y3 = model_bh_GxE(data_model_bh_GxE, variable = &quot;y3&quot;) load(&quot;./data_PPBstats/out_model_bh_GxE_y1.RData&quot;) load(&quot;./data_PPBstats/out_model_bh_GxE_y2.RData&quot;) load(&quot;./data_PPBstats/out_model_bh_GxE_y3.RData&quot;) Then check the models # c_mbhgxe_y1 = check_model(out_model_bh_GxE_y1) # The Gelman-Rubin test is running for each parameter ... # The two MCMC for each parameter converge thanks to the Gelman-Rubin test. # c_mbhgxe_y2 = check_model(out_model_bh_GxE_y2) # The Gelman-Rubin test is running for each parameter ... # The two MCMC for each parameter converge thanks to the Gelman-Rubin test. # c_mbhgxe_y3 = check_model(out_model_bh_GxE_y3) # The Gelman-Rubin test is running for each parameter ... # The two MCMC for each parameter converge thanks to the Gelman-Rubin test. load(&quot;./data_PPBstats/c_mbhgxe_y1.RData&quot;) load(&quot;./data_PPBstats/c_mbhgxe_y2.RData&quot;) load(&quot;./data_PPBstats/c_mbhgxe_y3.RData&quot;) Then run the function on alpha. It can also be done on beta or theta. out_parameter_groups = parameter_groups( list(&quot;y1&quot; = c_mbhgxe_y1, &quot;y2&quot; = c_mbhgxe_y2, &quot;y3&quot; = c_mbhgxe_y3), &quot;alpha&quot; ) Note that you can highlight some individual with the argument ind_to_highlight. out_parameter_groups is list of two elements: -obj.pca : the PCA object from FactoMineR::PCA clust, a list of two elements: res.hcpc : the HCPC object from FactoMineR::HCPC clust : the dataframe with cluster assigned to each individual 3.6.5.8.2 Visualize groups of parameters Visualize outputs with plot ppg = plot(out_parameter_groups) ppg is list of two elements: pca : a list with three elements on the PCA on the group of parameters : composante_variance : variance caught by each dimension of the PCA ppg$pca$composante_variance ind : graph of individuals ppg$pca$ind var : graph of variables ppg$pca$var clust : output from factextra::fviz_cluster(), a list of number of cluster + 1 element cl = ppg$clust names(cl) ## [1] &quot;cluster_all&quot; &quot;cluster_1&quot; &quot;cluster_2&quot; &quot;cluster_3&quot; cl$cluster_all cl$cluster_1 ## Warning: Removed 3 rows containing non-finite values (stat_mean). ## Warning: Removed 3 rows containing missing values (geom_point). ## Warning: Removed 3 rows containing missing values (geom_text_repel). A farmer may find a germplasm that behaves well according to informations from model_1 (Section 3.5.6) in a farm that shares its cluster. 3.6.5.9 Predict the past In order to choose a new germplasm to test on his farm, a farmer may choose a germplasm according to the value it would have obtained on his farm. For example for &quot;loc-6:year-5&quot; ptp = predict_the_past_model_bh_GxE(out_check_model_bh_GxE, env = &quot;loc-1:2005&quot;) ptp can be handle exacly as out_model_1 for mean comparisons m_ptp = mean_comparisons(ptp) and visualize the output, for plot_type = &quot;barplot&quot;, there is two colors regarding estimated and predicted results. p = plot(m_ptp, plot_type = &quot;barplot&quot;) p$data_mean_comparisons$`loc-1:2005`$`1` For plot_type = &quot;score&quot; and plot_type = &quot;interaction&quot;, predicted and estimated are mention between brakets after germplasm name. p = plot(m_ptp, plot_type = &quot;score&quot;) p$`loc-1`$`1` p = plot(m_ptp, plot_type = &quot;interaction&quot;) p$data_mean_comparisons$`loc-1`$`1` ## geom_path: Each group consists of only one observation. Do you need to ## adjust the group aesthetic? 3.6.5.10 Apply the workflow to several variables If you wish to apply the model_2 workflow to several variables, you can use lapply with the following code : workflow_model_bh_GxE = function(x){ out_model_bh_GxE = model_bh_GxE(data = data_model_bh_GxE, variable = x, return.epsilon = TRUE) out_check_model_bh_GxE = check_model(out_model_bh_GxE) p_out_check_model_bh_GxE = plot(out_check_model_bh_GxE) out_cross_validation_model_bh_GxE = cross_validation_model_bh_GxE(data_model_bh_GxE, x, nb_iterations = 10) p_out_cv = plot(out_cross_validation_model_bh_GxE) model_bh_GxE_alpha = mean_comparisons(out_check_model_bh_GxE, parameter = &quot;alpha&quot;) model_bh_GxE_beta = mean_comparisons(out_check_model_bh_GxE, parameter = &quot;beta&quot;, precision = 0.05) model_bh_GxE_theta = mean_comparisons(out_check_model_bh_GxE, parameter = &quot;theta&quot;, precision = 0.05) p_a = plot(model_bh_GxE_alpha, plot_type = &quot;barplot&quot;) p_b = plot(model_bh_GxE_beta, plot_type = &quot;barplot&quot;) p_ab = plot(model_bh_GxE_alpha, model_bh_GxE_beta, plot_type = &quot;biplot-alpha-beta&quot;) p_t = plot(model_bh_GxE_theta, plot_type = &quot;barplot&quot;) out = list( out_model_bh_GxE = out_model_bh_GxE, out_check_model_bh_GxE = out_check_model_bh_GxE, p_out_check_model_bh_GxE = p_out_check_model_bh_GxE, out_cross_validation_model_bh_GxE = out_cross_validation_model_bh_GxE, p_out_cv = p_out_cv, model_bh_GxE_alpha = model_bh_GxE_alpha, model_bh_GxE_beta = model_bh_GxE_beta, model_bh_GxE_theta = model_bh_GxE_theta, p_a = p_a, p_b = p_b, p_ab = p_ab, p_t = p_t ) return(out) } ## Not run because of memory and time issues ! # vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;) # # out = lapply(vec_variables, workflow_model_bh_GxE) # names(out) = vec_variables # # out_parameter_groups = parameter_groups( # list(&quot;y1&quot; = out$y1$out_check_model_bh_GxE, # &quot;y2&quot; = out$y2$out_check_model_bh_GxE, &quot; # y3&quot; = out$y3$out_check_model_bh_GxE), # &quot;germplasm&quot; ) # # ppg = plot(out_parameter_groups) # # predict the past is not done here as it is more specific question # References "],
["family-3.html", "3.7 Family 3 of analysis : effects from family 1 and 2 in a network of farms", " 3.7 Family 3 of analysis : effects from family 1 and 2 in a network of farms 3.7.1 model 3 !!! TO DO !!! The model is based on bayesian statistics (section 3.1.2.2). The tests to check the model are explained in section 3.1.2.2.2. The method to compute mean comparison are explained in section 3.1.2.2.3. "],
["family-4.html", "3.8 Family 4 of analysis : specific research questions on one farm or more", " 3.8 Family 4 of analysis : specific research questions on one farm or more In this section, several models are proposed for specific research questions: Study response to selection (section 3.8.1) based on models from Family 1 of analysis presented in section 3.5 Study local adaptation with two models: home away (section 3.8.2.2) and local foreign (section 3.8.2.3) based on fully-replicated design (D1) (section 3.2.1) Study intra germplasm variance with a dedicated model (section 3.8.3) 3.8.1 Study reponse to selection For a given trait, selection differential corresponds to the difference between mean of the selected spikes and mean of the bulk (i.e. spikes that have not been selected). Response to selection correponds to the difference between mean of spikes coming from the selected spikes and the spikes coming from the bulk (Figure 3.26). Selection differential (\\(S\\)) and response to selection (\\(R\\)) are linked with the realized heritability (\\(h^2_r\\)): \\(R = h^2_r \\times S\\). Figure 3.26: Seletion differential (S) in 2014-2015 and response to selection (R) in 2015-2016. Circles and arrows in gray represent the seed-lots that have been sown in 2015 after harvest in 2015.(Rivière 2015) 3.8.1.1 Workflow and function relations in PPBstats regarding response to selection analysis Figure 3.27 displays the functions and their relationships. Table 3.4 describes each of the main functions. You can have more information for each function by typing ?function_name in your R session. Figure 3.27: Main functions used in the workflow to study response to selection. Table 3.4: Function description. function name description design_experiment Provides experimental design for the different situations corresponding to the choosen family of analysis format_data_PPBstats Check and format the data to be used in PPBstats functions plot Build ggplot objects to visualize output 3.8.1.2 Steps with PPBstats To study response to selection, you can follow three steps (Figure 3.27): Format the data with format_data_PPBstats() Describe the data with plot() Get mean comparison from family 1’s model as explained in section 3.5 by running the model get mean comparisons use plot() 3.8.1.3 Format data In this section, the data set used is coming from data_model_GxE (section 3.6.3) with three dedicated columns: group which represents differential selection (S) or reponse to selection (R) version which represents bouquet or vrac. expe_id: an id with S couple and R couple (i.e. four rows) OR S couple (i.e. two rows) OR R couple (i.e. two rows) expe_id is useful for example if there are several selection in one germplasm or if there are several origin for a given germplasm. 3.8.1.4 Describe and get mean comparison from family 1’s model For all model, stars on a pair of entries corresponds to the pvalue: pvalue stars \\(&lt; 0.001\\) *** \\([0.001 , 0.05]\\) ** \\([0.05 , 0.01]\\) * \\(&gt; 0.01\\) . 3.8.1.4.1 Classic anova model To Do !!! #data(data_agro_SR_1) #data_agro_SR_1 = format_data_PPBstats(data_agro_SR_1, type = &quot;data_agro_SR&quot;) 3.8.1.4.2 Spatial analysis model To Do !!! #data(data_agro_SR_2) #data_agro_SR_2 = format_data_PPBstats(data_agro_SR_2, type = &quot;data_agro_SR&quot;) 3.8.1.4.3 Mixed model for incomplete block design To Do !!! #data(data_agro_SR_3) #data_agro_SR_3 = format_data_PPBstats(data_agro_SR_3, type = &quot;data_agro_SR&quot;) 3.8.1.4.4 Hierarchical Bayesian intra-location model data(data_agro_SR_4) data_agro_SR_4 = format_data_PPBstats(data_agro_SR_4, type = &quot;data_agro_SR&quot;) ## Warning in format_data_PPBstats.data_agro(data): Column &quot;long&quot; is needed to ## get map and not present in data. ## Warning in format_data_PPBstats.data_agro(data): Column &quot;lat&quot; is needed to ## get map and not present in data. ## data has been formated for PPBstats functions. head(data_agro_SR_4) ## seed_lot location year germplasm block X Y expe_id group ## 1 germ-25_loc-1_2005_0001 loc-1 2005 germ-25 1 1 a id_1 S ## 2 germ-26_loc-1_2005_0001 loc-1 2005 germ-26 1 2 b id_1 S ## 3 germ-27_loc-1_2005_0001 loc-1 2005 germ-27 1 3 c id_1 R ## 4 germ-28_loc-1_2005_0001 loc-1 2005 germ-28 1 4 d id_1 R ## 5 germ-25_loc-1_2005_0001 loc-1 2005 germ-25 2 5 e id_2 S ## 6 germ-26_loc-1_2005_0001 loc-1 2005 germ-26 2 6 f id_2 S ## version tkw tkw$date tkw$date_julian ## 1 bouquet 72.09900 2017-07-22 202 ## 2 vrac 61.05274 2017-07-22 202 ## 3 bouquet 62.99350 2017-07-22 202 ## 4 vrac 65.10909 2017-07-22 202 ## 5 bouquet 77.01361 2017-07-22 202 ## 6 vrac 64.10541 2017-07-22 202 First, describe the data. p = plot(data_agro_SR_4, vec_variables = &quot;tkw&quot;, plot_type = &quot;barplot&quot;) ## Regarding post_hoc analysis, 2 couples S and R are displayed. 5 S without corresponding R or R without corresponding S are not displayed. The plot has two lists: - one for each id where each element of the list is an expe_id. - one on post hoc analysis with all couple S (election differential) and R (response to selection) where each element of the list refer to germplasm, location or year p$tkw$analysis_for_each_id$id_1 ## Warning: Removed 4 rows containing missing values (geom_errorbar). p$tkw$post_hoc_analysis$germplasm In addition, the realized heritability (\\(h^2_r\\): \\(R = h^2_r \\times S\\)) can be displayed. p = plot(data_agro_SR_4, vec_variables = &quot;tkw&quot;, plot_type = &quot;barplot&quot;, heritability = TRUE) ## Regarding post_hoc analysis, 2 couples S and R are displayed. 5 S without corresponding R or R without corresponding S are not displayed. p$tkw$analysis_for_each_id$id_1 ## Warning: Removed 4 rows containing missing values (geom_errorbar). p$tkw$post_hoc_analysis$germplasm In order to add significance differences from the Hierarchical Bayesian intra-location model presented in section 3.5.6, the argument mean_comparisons must be filled with the output of mean_comparisons of the model. The pvalue is computed as describe in Section 3.1.2.2.3 if the parameters have been estimated with the model. load(&quot;./data_PPBstats/out_mean_comparisons_model_bh_intra_location_mu.RData&quot;) # To save time p = plot(data_agro_SR_4, mean_comparison = out_mean_comparisons_model_bh_intra_location_mu, vec_variables = &quot;tkw&quot;, plot_type = &quot;barplot&quot;) ## Regarding post_hoc analysis, 2 couples S and R are displayed. 5 S without corresponding R or R without corresponding S are not displayed. p$tkw$analysis_for_each_id$id_1 ## Warning: Removed 4 rows containing missing values (geom_errorbar). For environments where MCMC did not converge or without environments, it is a @ref(t.test) which is perform when there are more than 1 obervation for a given seed lot. p$tkw$analysis_for_each_id$id_1 ## Warning: Removed 4 rows containing missing values (geom_errorbar). By setting heritability = TRUE, the realized heritability is displayed. 3.8.2 Study local adaptation 3.8.2.1 Workflow and function relations in PPBstats regarding local adaptation analysis Figure 3.28 displays the functions and their relationships. Table 3.5 describes each of the main functions. You can have more information for each function by typing ?function_name in your R session. Note that check_model(), mean_comparison() and plot() are S3 method. Therefore, you should type ?check_model, ?mean_comparison or ?plot.PPBstats to have general features and then see in details for specific functions. Figure 3.28: Main functions used in the workflow to study local adaptation. Table 3.5: Function description. function name description design_experiment Provides experimental design for the different situations corresponding to the choosen family of analysis format_data_PPBstats Check and format the data to be used in PPBstats functions HA_to_LF Transform home away data to local foreign data LF_to_HA Transform local foreign data to home away data model_home_away Run home away model model_local_foreign Run local foreign model check_model Check if the model went well mean_comparisons Get mean comparisons plot Build ggplot objects to visualize output 3.8.2.2 Home away Home away analysis allows to study local adaptation. Away in a location refers to a germplasm that has not been grown or selected in a given location. Home in a location refers to a germplasm that has been grown or selected in a given location. The following model take into account germplasm and location effects in order to better study version (home or away) effect (Blanquart et al. 2013). The model is based on frequentist statistics (section 3.1.2.1). \\(Y_{ijkm} = \\mu + \\alpha_i + \\theta_j + \\omega_{k_{ij}} + (\\omega \\times \\alpha)_{k_{ij}j} + rep(\\theta)_{mj} + \\varepsilon_{ijkm}; \\quad \\varepsilon_{ijkm} \\sim \\mathcal{N} (0,\\sigma^2)\\) with \\(Y_{ijkm}\\) the phenotypic value for replication \\(m\\), germplasm \\(i\\) and location \\(j\\), and version \\(k\\), \\(\\mu\\) the general mean, \\(\\alpha_i\\) the effect of germplasm \\(i\\), \\(\\theta_j\\) the effect of location \\(j\\), \\(\\omega_{k_{ij}}\\) the effect of version, home or away for a germplasm \\(i\\) in location \\(j\\), \\((\\omega \\times \\theta)_{k_{ij}j}\\) the interaction effect of version \\(\\times\\) location, \\(rep(\\theta)_{mj}\\) the effect of the replication \\(m\\) nested in location, \\(\\varepsilon_{ijkm}\\) the residuals. The comparisons of all germplasm in all location in sympatric or allopatric situation (measured by version effect \\(\\omega_{k_{ij}}\\)) give a glocal measure of local adaptation (Blanquart et al. 2013). Interaction effect \\((\\omega \\times \\alpha)_{k_{ij}j}\\) give information on specific adaptation to each location. If there are more than one year, then the model can be written : \\(Y_{ijklm} = \\mu + \\alpha_i + \\theta_j + \\beta_l + \\omega_{k_{ij}} + (\\theta \\times \\beta)_{jl} + (\\omega \\times \\alpha)_{k_{ij}j} + rep(\\theta \\times \\beta)_{mjl} + (\\omega \\times \\alpha \\times \\beta)_{k_{ij}jl} + \\varepsilon_{ijklm}; \\quad \\varepsilon_{ijklm} \\sim \\mathcal{N} (0,\\sigma^2)\\) with \\(Y_{ijklm}\\) the phenotypic value for replication \\(m\\), germplasm \\(i\\) and location \\(j\\), year \\(l\\) and version \\(k\\), \\(\\mu\\) the general mean, \\(\\alpha_i\\) the effect of germplasm \\(i\\), \\(\\theta_j\\) the effect of location \\(j\\), \\(\\beta_l\\) the effect of year \\(l\\), \\(\\omega_{k_{ij}}\\) the effect of version, home or away for a germplasm \\(i\\) in location \\(j\\), \\((\\theta \\times \\beta)_{jl}\\) the interaction effect of location \\(\\times\\) year, \\((\\omega \\times \\theta)_{k_{ij}j}\\) the interaction effect of version \\(\\times\\) location, \\(rep(\\theta \\times \\beta)_{mjl}\\) the effect of the replication \\(m\\) nested in location \\(\\times\\) year, \\((\\omega \\times \\theta \\times \\beta)_{k_{ij}jl}\\) the interaction effect of version \\(\\times\\) location \\(\\times\\) year, \\(\\varepsilon_{ijklm}\\) the residuals. Interaction \\((\\omega \\times \\theta \\times \\beta)_{k_{ij}jl}\\) give information on specific adaptation to each location for a given year. A type III anova is done here as the data are not orthogonal. 3.8.2.2.1 Steps with PPBstats For home away analysis, you can follow these steps (Figure 3.28): Format the data with format_data_PPBstats() describe the data with plot() Run the model with model_home_away() Check model outputs with graphs to know if you can continue the analysis with check_model() and vizualise it with plot() Get mean comparisons for each factor with mean_comparisons() and vizualise it with plot() 3.8.2.2.2 Format data data(&quot;data_agro_HA&quot;) data_agro_HA = format_data_PPBstats(data_agro_HA, type = &quot;data_agro_HA&quot;) ## Warning in format_data_PPBstats.data_agro(data): Column &quot;long&quot; is needed to ## get map and not present in data. ## Warning in format_data_PPBstats.data_agro(data): Column &quot;lat&quot; is needed to ## get map and not present in data. ## data has been formated for PPBstats functions. head(data_agro_HA) ## seed_lot location year germplasm block X Y origin version ## 1 germ-1_loc-1_2005_0001 loc-1 2005 germ-1 1 A 2 loc-1 home ## 2 germ-1_loc-1_2005_0001 loc-1 2005 germ-1 2 C 6 loc-1 home ## 3 germ-1_loc-1_2005_0001 loc-1 2005 germ-1 3 B 13 loc-1 home ## 4 germ-2_loc-1_2005_0001 loc-1 2005 germ-2 1 D 5 loc-2 away ## 5 germ-2_loc-1_2005_0001 loc-1 2005 germ-2 2 B 9 loc-2 away ## 6 germ-2_loc-1_2005_0001 loc-1 2005 germ-2 3 C 14 loc-2 away ## y1 y1$date y2 y2$date y3 y3$date ## 1 23.03428 2017-07-15 37.38970 2017-07-15 63.39528 2017-07-15 ## 2 17.23622 2017-07-15 42.90576 2017-07-15 66.87962 2017-07-15 ## 3 25.33605 2017-07-15 31.87826 2017-07-15 60.63063 2017-07-15 ## 4 12.48506 2017-07-15 46.09260 2017-07-15 55.18082 2017-07-15 ## 5 13.37886 2017-07-15 46.51270 2017-07-15 51.88016 2017-07-15 ## 6 17.64994 2017-07-15 39.96316 2017-07-15 53.13201 2017-07-15 ## y1$date_julian y2$date_julian y3$date_julian ## 1 195 195 195 ## 2 195 195 195 ## 3 195 195 195 ## 4 195 195 195 ## 5 195 195 195 ## 6 195 195 195 Where version represents away or home and group represents the location where the germplasm come from. 3.8.2.2.3 Describe the data p = plot(data_agro_HA, vec_variables = &quot;y1&quot;, plot_type = &quot;barplot&quot;) p is a list with as many element as variable. For each variable, there are three elements : A single plot with version for all germplasm merged p$y1$home_away_merged A single plot with version for each germplasm p$y1$home_away_merged_per_germplasm A list of plots for each germplasm with all version separated p$y1$home_away_per_germplasm$`germ-1`$version p$y1$home_away_per_germplasm$`germ-1`$origin If you have several year in the data, you can set argument f_gris = &quot;year&quot; in order to have plot for each year. In the example below t is not really relevent beaause there is only one year in the data set! p = plot(data_agro_HA, vec_variables = &quot;y1&quot;, plot_type = &quot;barplot&quot;, f_grid = &quot;year&quot;) p$y1$home_away_merged_per_germplasm 3.8.2.2.4 Run the model To run HOME AWAY model on the dataset, use the function model_home_away. You can run it on one variable. out_ha = model_home_away(data_agro_HA, &quot;y1&quot;) out_ha is a list containing three elements : info : a list with variable out_ha$info ## $variable ## [1] &quot;y1&quot; ANOVA a list with five elements : model out_ha$ANOVA$model ## ## Call: ## stats::lm(formula = variable ~ location + germplasm + version + ## version:germplasm + location/block, data = data) ## ## Coefficients: ## (Intercept) locationloc-2 ## 15.3748 8.7827 ## locationloc-3 germplasmgerm-2 ## 4.2256 -0.6989 ## germplasmgerm-3 versionhome ## 4.2563 6.0237 ## germplasmgerm-2:versionhome germplasmgerm-3:versionhome ## -5.6698 -15.4536 ## locationloc-1:block2 locationloc-2:block2 ## 0.5964 -1.8569 ## locationloc-3:block2 locationloc-1:block3 ## -0.4242 0.8148 ## locationloc-2:block3 locationloc-3:block3 ## -0.3666 -3.3060 anova_model out_ha$ANOVA$anova_model ## Anova Table (Type III tests) ## ## Response: variable ## Sum Sq Df F value Pr(&gt;F) ## (Intercept) 327.30 1 17.4142 0.001093 ** ## location 86.82 2 2.3096 0.138584 ## germplasm 64.74 2 1.7222 0.217027 ## version 43.54 1 2.3167 0.151940 ## germplasm:version 122.23 2 3.2516 0.071605 . ## location:block 26.28 6 0.2331 0.958038 ## Residuals 244.33 13 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 3.8.2.2.5 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.1.2. 3.8.2.2.5.1 Check the model Once the model is run, it is necessary to check if the outputs can be taken with confidence. This step is needed before going ahead in the analysis (in fact, object used in the next functions must come from check_model()). out_check_ha = check_model(out_ha) out_check_ha is a list containing four elements : model_home_away the output from the model data_ggplot a list containing information for ggplot: data_ggplot_residuals a list containing : data_ggplot_normality data_ggplot_skewness_test data_ggplot_kurtosis_test data_ggplot_shapiro_test data_ggplot_qqplot data_ggplot_variability_repartition_pie data_ggplot_var_intra 3.8.2.2.5.2 Visualize outputs Once the computation is done, you can visualize the results with plot() p_out_check_ha = plot(out_check_ha) p_out_check_ha is a list with: residuals histogram : histogram with the distribution of the residuals p_out_check_ha$residuals$histogram ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qqplot p_out_check_ha$residuals$qqplot points p_out_check_ha$residuals$points variability_repartition : pie with repartition of SumSq for each factor p_out_check_ha$variability_repartition variance_intra_germplasm : repartition of the residuals for each germplasm (see Details for more information) With the hypothesis than the micro-environmental variation is equaly distributed on all the individuals (i.e. all the plants), the distribution of each germplasm represent the intra-germplasm variance. This has to been seen with caution: If germplasm have no intra-germplasm variance (i.e. pure line or hybrides) then the distribution of each germplasm represent only the micro-environmental variation. If germplasm have intra-germplasm variance (i.e. population such as landraces for example) then the distribution of each germplasm represent the micro-environmental variation plus the intra-germplasm variance. p_out_check_ha$variance_intra_germplasm 3.8.2.2.6 Get and visualize mean comparisons The method to compute mean comparison are explained in section 3.1.2.1.3. Here, the computation is based on emmeans. 3.8.2.2.6.1 Get mean comparisons Get mean comparisons with mean_comparisons(). out_mean_comparisons_ha = mean_comparisons(out_check_ha, p.adj = &quot;tukey&quot;) ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. out_mean_comparisons_ha is a list of five elements: info : a list with variable data_ggplot_LSDbarplot_version:germplasm data_ggplot_LSDbarplot_germplasm data_ggplot_LSDbarplot_location data_ggplot_LSDbarplot_year in case there is year in the model 3.8.2.2.6.2 Visualize mean comparisons p_out_mean_comparisons_ha = plot(out_mean_comparisons_ha) p_out_mean_comparisons_ha is a list of three elements with barplots : For each element of the list, there are as many graph as needed with nb_parameters_per_plot parameters per graph. Letters are displayed on each bar. Parameters that do not share the same letters are different regarding type I error (alpha) and alpha correction. The error I (alpha) and the alpha correction are displayed in the title. When comparing version for each germplasm, differences are displayed with stars. The stars corresponds to the pvalue: pvalue stars \\(&lt; 0.001\\) *** \\([0.001 , 0.05]\\) ** \\([0.05 , 0.01]\\) * \\(&gt; 0.01\\) . version:germplasm : mean comparison for version for each germplasm pvg = p_out_mean_comparisons_ha$&quot;version:germplasm&quot; pvg germplasm : mean comparison for germplasm pg = p_out_mean_comparisons_ha$germplasm pg$`1` location : mean comparison for location pl = p_out_mean_comparisons_ha$location pl$`1` year : mean comparison for year in case there is year in the model. 3.8.2.2.7 post hoc analysis to visualize variation repartition for several variables First run the models out_ha_2 = model_home_away(data_agro_HA, &quot;y2&quot;) out_ha_3 = model_home_away(data_agro_HA, &quot;y3&quot;) Then check the models out_check_ha_2 = check_model(out_ha_2) out_check_ha_3 = check_model(out_ha_3) list_out_check_model = list(&quot;ha_1&quot; = out_check_ha, &quot;ha_2&quot; = out_check_ha_2, &quot;ha_3&quot; = out_check_ha_3) post_hoc_variation(list_out_check_model) 3.8.2.2.8 Apply the workflow to several variables If you wish to apply the AMMI workflow to several variables, you can use lapply() with the following code : workflow_home_away = function(x, data){ out_home_away = model_home_away(data, variable = x) out_check_home_away = check_model(out_home_away) p_out_check_home_away = plot(out_check_home_away) out_mean_comparisons_home_away = mean_comparisons(out_check_home_away, p.adj = &quot;bonferroni&quot;) p_out_mean_comparisons_home_away = plot(out_mean_comparisons_home_away) out = list( &quot;out_home_away&quot; = out_home_away, &quot;out_check_home_away&quot; = out_check_home_away, &quot;p_out_check_home_away&quot; = p_out_check_home_away, &quot;out_mean_comparisons_home_away&quot; = out_mean_comparisons_home_away, &quot;p_out_mean_comparisons_home_away&quot; = p_out_mean_comparisons_home_away ) return(out) } vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;) out = lapply(vec_variables, workflow_home_away, data_agro_HA) ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. names(out) = vec_variables list_out_check_model = list(&quot;ha_1&quot; = out$y1$out_check_home_away, &quot;ha_2&quot; = out$y2$out_check_home_away, &quot;ha_3&quot; = out$y3$out_check_home_away) p_post_hoc_variation = post_hoc_variation(list_out_check_model) 3.8.2.3 Local foreign Another way to study local adaptation of germplasm to their location from origin is to compare germplasm behavior on their original location with their behavior on other locations : if the first is greater than the second then the germplasm is more adapted to its original location rather than to the other locations. Local in a location refers to a germplasm that has been grown or selected in a given location. Foreign in a location refers to a germplasm that has not been grown or selected in a given location. The following model take into account germplasm and location effects in order to better study version (local or foreign) effect (Blanquart et al. 2013): \\(Y_{ijkm} = \\mu + \\alpha_i + \\theta_j + \\omega_{k_{ij}} + (\\omega \\times \\theta)_{k_{ij}j} + rep(\\theta)_{mj} + \\varepsilon_{ijkm}; \\quad \\varepsilon_{ijkm} \\sim \\mathcal{N} (0,\\sigma^2)\\) with \\(Y_{ijkm}\\) the phenotypic value for replication \\(m\\), germplasm \\(i\\) and location \\(j\\), and version \\(k\\), \\(\\mu\\) the general mean, \\(\\alpha_i\\) the effect of germplasm \\(i\\), \\(\\theta_j\\) the effect of location \\(j\\), \\(\\omega_{k_{ij}}\\) the effect of version, local or foreign for a germplasm \\(i\\) in location \\(j\\), \\((\\omega \\times \\alpha)_{k_{ij}j}\\) the interaction effect of version \\(\\times\\) germplasm, \\(rep(\\theta)_{mj}\\) the effect of the replication \\(m\\) nested in location, \\(\\varepsilon_{ijkm}\\) the residuals. As for home away model, version effect \\(\\omega_{k_{ij}}\\)) give a glocal measure of local adaptation of germplasm to their location of origin (Blanquart et al. 2013). Interaction effect \\((\\omega \\times \\theta)_{k_{ij}j}\\) give information on specific adaptation to each germplasm. If there are more than one year, then the model can be written : \\(Y_{ijklm} = \\mu + \\alpha_i + \\theta_j + \\beta_l + \\omega_{k_{ij}} + (\\theta \\times \\beta)_{jl} + (\\omega \\times \\alpha)_{k_{ij}i} + rep(\\theta \\times \\beta)_{mjl} + (\\omega \\times \\alpha \\times \\beta)_{k_{ij}il} + \\varepsilon_{ijklm}; \\quad \\varepsilon_{ijklm} \\sim \\mathcal{N} (0,\\sigma^2)\\) with \\(Y_{ijklm}\\) the phenotypic value for replication \\(m\\), germplasm \\(i\\) and location \\(j\\), year \\(l\\) and version \\(k\\), \\(\\mu\\) the general mean, \\(\\alpha_i\\) the effect of germplasm \\(i\\), \\(\\theta_j\\) the effect of location \\(j\\), \\(\\beta_l\\) the effect of year \\(l\\), \\(\\omega_{k_{ij}}\\) the effect of version, home or away for a germplasm \\(i\\) in location \\(j\\), ()_{jl} the interaction effect of location \\(\\times\\) year, (){k{ij}i} the interaction effect of version \\(\\times\\) germplasm, rep()_{mjl} the effect of the replication \\(m\\) nested in location \\(\\times\\) year, (){k{ij}il} the interaction effect of version \\(\\times\\) germplasm \\(\\times\\) year, _{ijklm} the residuals. Interaction \\((\\omega \\times \\theta \\times \\beta)_{k_{ij}jl}\\) give information on specific adaptation to each germplasm for a given year. A type III anova is done here as the data are not orthogonal. 3.8.2.3.1 Steps with PPBstats For local foreign analysis, you can follow these steps (Figure 3.28): Format the data with format_data_PPBstats() describe the data with plot() Run the model with model_local_foreign() Check model outputs with graphs to know if you can continue the analysis with check_model() and vizualise it with plot() Get mean comparisons for each factor with mean_comparisons() and vizualise it with plot() 3.8.2.3.2 Format data data(&quot;data_agro_LF&quot;) data_agro_LF = format_data_PPBstats(data_agro_LF, type = &quot;data_agro_LF&quot;) ## Warning in format_data_PPBstats.data_agro(data): Column &quot;long&quot; is needed to ## get map and not present in data. ## Warning in format_data_PPBstats.data_agro(data): Column &quot;lat&quot; is needed to ## get map and not present in data. ## data has been formated for PPBstats functions. head(data_agro_LF) ## seed_lot location year germplasm block X Y origin version ## 1 germ-1_loc-1_2005_0001 loc-1 2005 germ-1 1 A 2 loc-1 local ## 2 germ-1_loc-1_2005_0001 loc-1 2005 germ-1 2 C 6 loc-1 local ## 3 germ-1_loc-1_2005_0001 loc-1 2005 germ-1 3 B 13 loc-1 local ## 4 germ-2_loc-1_2005_0001 loc-1 2005 germ-2 1 D 5 loc-2 foreign ## 5 germ-2_loc-1_2005_0001 loc-1 2005 germ-2 2 B 9 loc-2 foreign ## 6 germ-2_loc-1_2005_0001 loc-1 2005 germ-2 3 C 14 loc-2 foreign ## y1 y1$date y2 y2$date y3 y3$date ## 1 23.03428 2017-07-15 37.38970 2017-07-15 63.39528 2017-07-15 ## 2 17.23622 2017-07-15 42.90576 2017-07-15 66.87962 2017-07-15 ## 3 25.33605 2017-07-15 31.87826 2017-07-15 60.63063 2017-07-15 ## 4 12.48506 2017-07-15 46.09260 2017-07-15 55.18082 2017-07-15 ## 5 13.37886 2017-07-15 46.51270 2017-07-15 51.88016 2017-07-15 ## 6 17.64994 2017-07-15 39.96316 2017-07-15 53.13201 2017-07-15 ## y1$date_julian y2$date_julian y3$date_julian ## 1 195 195 195 ## 2 195 195 195 ## 3 195 195 195 ## 4 195 195 195 ## 5 195 195 195 ## 6 195 195 195 3.8.2.3.3 Describe the data p = plot(data_agro_LF, vec_variables = &quot;y1&quot;, plot_type = &quot;barplot&quot;) p is a list with as many element as variable. For each variable, there are three elements : A single plot with version for all location merged p$y1$local_foreign_merged - A single plot with version for each location p$y1$local_foreign_merged_per_location - plot for each location with all version separated p$y1$local_foreign_per_location$`loc-1`$version p$y1$local_foreign_per_location$`loc-1`$origin If you have several year in the data, you can set argument f_gris = &quot;year&quot; in order to have plot for each year. In the example below t is not really relevent beaause there is only one year in the data set! p = plot(data_agro_LF, vec_variables = &quot;y1&quot;, plot_type = &quot;barplot&quot;, f_grid = &quot;year&quot;) p$y1$local_foreign_merged_per_location 3.8.2.3.4 Run the model To run LOCAL FOREIGN model on the dataset, use the function model_local_foreign. You can run it on one variable. out_lf = model_local_foreign(data_agro_LF, &quot;y1&quot;) out_lf is a list containing three elements : info : a list with variable out_lf$info ## $variable ## [1] &quot;y1&quot; ANOVA a list with five elements : model out_lf$ANOVA$model ## ## Call: ## stats::lm(formula = variable ~ location + germplasm + version + ## version:location + location/block, data = data) ## ## Coefficients: ## (Intercept) locationloc-2 ## 15.3748 8.7827 ## locationloc-3 germplasmgerm-2 ## 4.2256 -0.6989 ## germplasmgerm-3 versionlocal ## 4.2563 6.0237 ## locationloc-2:versionlocal locationloc-3:versionlocal ## -5.6698 -15.4536 ## locationloc-1:block2 locationloc-2:block2 ## 0.5964 -1.8569 ## locationloc-3:block2 locationloc-1:block3 ## -0.4242 0.8148 ## locationloc-2:block3 locationloc-3:block3 ## -0.3666 -3.3060 anova_model out_lf$ANOVA$anova_model ## Anova Table (Type III tests) ## ## Response: variable ## Sum Sq Df F value Pr(&gt;F) ## (Intercept) 327.30 1 17.4142 0.001093 ** ## location 86.82 2 2.3096 0.138584 ## germplasm 64.74 2 1.7222 0.217027 ## version 43.54 1 2.3167 0.151940 ## location:version 122.23 2 3.2516 0.071605 . ## location:block 26.28 6 0.2331 0.958038 ## Residuals 244.33 13 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 3.8.2.3.5 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.1.2. 3.8.2.3.5.1 Check the model Once the model is run, it is necessary to check if the outputs can be taken with confidence. This step is needed before going ahead in the analysis (in fact, object used in the next functions must come from check_model()). out_check_lf = check_model(out_lf) out_check_lf is a list containing four elements : model_local_foreign the output from the model data_ggplot a list containing information for ggplot: data_ggplot_residuals a list containing : data_ggplot_normality data_ggplot_skewness_test data_ggplot_kurtosis_test data_ggplot_shapiro_test data_ggplot_qqplot data_ggplot_variability_repartition_pie data_ggplot_var_intra 3.8.2.3.5.2 Visualize outputs Once the computation is done, you can visualize the results with plot() p_out_check_lf = plot(out_check_lf) p_out_check_lf is a list with: residuals histogram : histogram with the distribution of the residuals p_out_check_lf$residuals$histogram ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qqplot p_out_check_lf$residuals$qqplot points p_out_check_lf$residuals$points variability_repartition : pie with repartition of SumSq for each factor p_out_check_lf$variability_repartition variance_intra_germplasm : repartition of the residuals for each germplasm (see Details for more information) With the hypothesis than the micro-environmental variation is equaly distributed on all the individuals (i.e. all the plants), the distribution of each germplasm represent the intra-germplasm variance. This has to been seen with caution: If germplasm have no intra-germplasm variance (i.e. pure line or hybrides) then the distribution of each germplasm represent only the micro-environmental variation. If germplasm have intra-germplasm variance (i.e. population such as landraces for example) then the distribution of each germplasm represent the micro-environmental variation plus the intra-germplasm variance. p_out_check_lf$variance_intra_germplasm 3.8.2.3.6 Get and visualize mean comparisons The method to compute mean comparison are explained in section 3.1.2.1.3. Here, the computation is based on emmeans. 3.8.2.3.6.1 Get mean comparisons Get mean comparisons with mean_comparisons(). out_mean_comparisons_lf = mean_comparisons(out_check_lf, p.adj = &quot;tukey&quot;) ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. out_mean_comparisons_lf is a list of five elements: info : a list with variable data_ggplot_LSDbarplot_version:germplasm data_ggplot_LSDbarplot_germplasm data_ggplot_LSDbarplot_location data_ggplot_LSDbarplot_year in case there is year in the model 3.8.2.3.6.2 Visualize mean comparisons p_out_mean_comparisons_lf = plot(out_mean_comparisons_lf) p_out_mean_comparisons_lf is a list of three elements with barplots : For each element of the list, there are as many graph as needed with nb_parameters_per_plot parameters per graph. Letters are displayed on each bar. Parameters that do not share the same letters are different regarding type I error (alpha) and alpha correction. The error I (alpha) and the alpha correction are displayed in the title. When comparing version for each germplasm, differences are displayed with stars. The stars corresponds to the pvalue: pvalue stars \\(&lt; 0.001\\) *** \\([0.001 , 0.05]\\) ** \\([0.05 , 0.01]\\) * \\(&gt; 0.01\\) . version:germplasm : mean comparison for version for each location pvg = p_out_mean_comparisons_lf$&quot;version:location&quot; pvg germplasm : mean comparison for germplasm pg = p_out_mean_comparisons_lf$germplasm pg$`1` location : mean comparison for location pl = p_out_mean_comparisons_lf$location pl$`1` year : mean comparison for year in case there is year in the model. 3.8.2.3.7 post hoc analysis to visualize variation repartition for several variables First run the models out_lf_2 = model_local_foreign(data_agro_LF, &quot;y2&quot;) out_lf_3 = model_local_foreign(data_agro_LF, &quot;y3&quot;) Then check the models out_check_lf_2 = check_model(out_lf_2) out_check_lf_3 = check_model(out_lf_3) list_out_check_model = list(&quot;lf_1&quot; = out_check_lf, &quot;lf_2&quot; = out_check_lf_2, &quot;lf_3&quot; = out_check_lf_3) post_hoc_variation(list_out_check_model) 3.8.2.3.8 Apply the workflow to several variables If you wish to apply the AMMI workflow to several variables, you can use lapply() with the following code : workflow_local_foreign = function(x, data){ out_local_foreign = model_local_foreign(data, variable = x) out_check_local_foreign = check_model(out_local_foreign) p_out_check_local_foreign = plot(out_check_local_foreign) out_mean_comparisons_local_foreign = mean_comparisons(out_check_local_foreign, p.adj = &quot;bonferroni&quot;) p_out_mean_comparisons_local_foreign = plot(out_mean_comparisons_local_foreign) out = list( &quot;out_local_foreign&quot; = out_local_foreign, &quot;out_check_local_foreign&quot; = out_check_local_foreign, &quot;p_out_check_local_foreign&quot; = p_out_check_local_foreign, &quot;out_mean_comparisons_local_foreign&quot; = out_mean_comparisons_local_foreign, &quot;p_out_mean_comparisons_local_foreign&quot; = p_out_mean_comparisons_local_foreign ) return(out) } vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;) out = lapply(vec_variables, workflow_local_foreign, data_agro_LF) ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## NOTE: Results may be misleading due to involvement in interactions ## NOTE: A nesting structure was detected in the fitted model: ## block %in% location ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. ## Warning: &#39;CLD&#39; will be deprecated. Its use is discouraged. ## See &#39;? CLD&#39; for an explanation. Use &#39;pwpp&#39; or &#39;multcomp::cld&#39; instead. names(out) = vec_variables list_out_check_model = list(&quot;lf_1&quot; = out$y1$out_check_local_foreign, &quot;lf_2&quot; = out$y2$out_check_local_foreign, &quot;lf_3&quot; = out$y3$out_check_local_foreign) p_post_hoc_variation = post_hoc_variation(list_out_check_model) 3.8.3 Study variance within germplasm 3.8.3.1 Theory of the model The model is based on bayesian statistics (section 3.1.2.2). The phenotypic value \\(Y_{ijkl}\\) for a given variable \\(Y\\), germplasm \\(i\\), environment \\(j\\), plot \\(k\\) and individual \\(l\\) is modeled as : \\(Y_{ijkl} = \\mu_{ijk} + \\varepsilon_{ijkl} ; \\quad \\varepsilon_{ijkl} \\sim \\mathcal{N} (0,\\sigma^2_{ij})\\), Where \\(Y_{ijkl}\\) is the phenotypic value for germplasm \\(i\\), environment \\(j\\), plot \\(k\\) and individual \\(l\\); \\(\\mu_{ijk}\\) is the mean of population \\(i\\) in environnement \\(j\\) and plot \\(k\\) (nested in environment \\(j\\)); \\(\\varepsilon_{ijkl}\\) is what is not explained by the model in germplasm \\(i\\), environment \\(j\\), plot \\(k\\) and individual \\(l\\). \\(\\varepsilon_{ijkl}\\) is taken from a normal distribution, centered on 0 with variance \\(\\sigma^2_{ij}\\) With priors : \\(\\sigma^2_{ij} \\sim 1/Gamma(10^{-6},10^{-6})\\) and \\(\\mu_{ijk} \\sim N(\\mu_{.j.},10^{6})\\) \\(\\sigma^2_{ij}\\) correspond to the intra-germplasm variance. No specific experimental design is needed as long as there are several individuals measured for a given germplasm. 3.8.3.2 Steps with PPBstats For variance intra analysis, you can follow these steps (Figure (fig:main-workflow)) : Format the data with format_data_PPBstats() Run the model with model_bh_intra_location() Check model outputs with graphs to know if you can continue the analysis with check_model() Get mean comparisons for each factor with mean_comparisons() and vizualise it with plot() 3.8.3.3 Format the data data(data_model_bh_variance_intra) data_model_bh_variance_intra = format_data_PPBstats(data_model_bh_variance_intra, type = &quot;data_agro&quot;) ## Warning in format_data_PPBstats.data_agro(data): Column &quot;long&quot; is needed to ## get map and not present in data. ## Warning in format_data_PPBstats.data_agro(data): Column &quot;lat&quot; is needed to ## get map and not present in data. ## data has been formated for PPBstats functions. 3.8.3.4 Run the model To run the model , used the function model_bh_intra_location. You can run it on one variable. #out_vi = model_bh_intra_location(data_model_bh_variance_intra, variable = &quot;spike_weight&quot;, nb_iterations = 100) 3.8.3.5 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.2.2. 3.8.3.5.1 Check the model Once the model is run, it is necessary to check if the outputs can be taken with confidence. This step is needed before going ahead in the analysis (in fact, object used in the next functions must come from check_model). #out_check_vi = check_model(out_vi) 3.8.3.5.2 Visualize outputs Once the computation is done, you can visualize the results with plot #p_out_check_vi = plot(out_check_vi) 3.8.3.6 Get and visualize mean comparisons The method to compute mean comparison are explained in section ??. 3.8.3.6.1 Get mean comparisons Get mean comparisons with mean_comparisons. #out_mean_comparisons_vi = mean_comparisons(out_check_vi, parameter = &quot;mu&quot;, p.adj = &quot;soft.bonf&quot;) 3.8.3.6.2 Visualize outputs Once the computation is done, you can visualize the results with plot #p_out_mc_vi = plot(out_mean_comparisons_vi) 3.8.3.7 Apply the workflow to several variables If you wish to apply the variance_intra workflow to several variables, you can use lapply with the following code : workflow_model_variance_intra = function(x){ out_vi = model_bh_intra_location(data_variance_intra, variable = x) out_check_vi = check_model(out_vi) p_out_check_vi = plot(out_check_vi) out_mean_comparisons_vi = mean_comparisons(out_check_vi, p.adj = &quot;bonferroni&quot;) p_out_mean_comparisons_vi = plot(out_mean_comparisons_vi) out = list( &quot;out_vi&quot; = out_vi, &quot;out_check_vi&quot; = out_check_vi, &quot;p_out_check_vi&quot; = p_out_check_vi, &quot;out_mean_comparisons_vi&quot; = out_mean_comparisons_vi, &quot;p_out_mean_comparisons_vi&quot; = p_out_mean_comparisons_vi ) return(out) } ## Not run because of memory and time issues ! # vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;) # # out = lapply(vec_variables, workflow_model_variance_intra) # names(out) = vec_variables References "],
["family-5.html", "3.9 Family 5 of analysis : multivariate analysis", " 3.9 Family 5 of analysis : multivariate analysis Multivariate analysis can answer to multiple objective. One of them can be to study diversity structure and identify parents to cross based on either good complementarity or similarity for some traits 3.9.1 Decision tree To study diversity structure and identify parents to cross based on either good complementarity or similarity for some traits, different scenario are possible (Figure 3.29). It can be completed by analysis of molecular data and genetic distance trees (M3, section 5). Figure 3.29: Decision tree with experimental constraints, designs and methods of agronomic analysis carry out in PPBstats regarding the objective :Study diversity structure and identify parents to cross based on either good complementarity or similarity for some traits. D refers to designs and M to methods. 3.9.2 Workflow and function relations in PPBstats regarding family 2 of analysis Figure 3.30 displays the functions and their relationships. Table 3.6 describes each of the main functions. You can have more information for each function by typing ?function_name in your R session. Figure 3.30: Main functions used in the workflow of family 5. Table 3.6: Function description. function name description design_experiment Provides experimental design for the different situations corresponding to the choosen family of analysis format_data_PPBstats Check and format the data to be used in PPBstats functions ggcorrplot Visualize correlation with ggcorrplot fonction from package ggcorrplot multivariate Run multivariate analysis with functions from FactoMineR factoextra Check outputs and results with the factoextra package 3.9.3 Steps with PPBstats For variance intra analysis, you can follow these steps (Figure 3.2) : Format the data with format_data_PPBstats() Look at correlation between variables with ggcorrplot::ggcorrplot()11 Run the analysis with multivariate() Check outputs and results with functions from factoextra12 3.9.4 Format the data data(&quot;data_model_GxE&quot;) data_model_GxE = format_data_PPBstats(data_model_GxE, type = &quot;data_agro&quot;) ## data has been formated for PPBstats functions. 3.9.5 Look at correlation library(ggcorrplot) vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;) corr = round(cor(data_model_GxE[,vec_variables]), 1) p.mat = cor_pmat(data_model_GxE[,vec_variables]) # Barring the no significant coefficient ggcorrplot(corr, hc.order = TRUE, type = &quot;lower&quot;, p.mat = p.mat) More details on the use of ggcorrplot() can be found here. 3.9.6 Run the analysis vec_variables = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;) res.pca = mutlivariate(data_model_GxE, vec_variables, PCA) 3.9.7 Check outputs and results Look at the results thanks to the factoextra package: fviz_eig(res.pca) fviz_pca_ind(res.pca, label=&quot;none&quot;, habillage=&quot;location&quot;, addEllipses=TRUE, ellipse.level=0.95) http://www.sthda.com/english/wiki/ggcorrplot-visualization-of-a-correlation-matrix-using-ggplot2↩ https://github.com/kassambara/factoextra↩ "],
["organoleptic.html", "Chapter 4 Sensory analysis", " Chapter 4 Sensory analysis In section 4.1, you will chose your objective in order to compare different varieties evaluated for selection in different locations, the analyses and the experimental design based on a decision tree, and see how to implement it based on the workflow and function relations from formated data. Then, thanks to PPBstats, you will describe the data and run statistical analysis (sections 4.3, 4.4, 4.5). "],
["intro-organo.html", "4.1 Introduction", " 4.1 Introduction First, chose your objective (4.1.1), then the analyses and the experimental design based on a decision tree. Finally see how to implement it based on the workflow and function relations (4.1.3) from formated data (4.1.4). 4.1.1 Analysis according to the objectives In order to compare different germplasms on each location for selection, three main objectives dealing with PPB programmes organoleptic analyses can be : Understand and check consumers preferences. This can be done through hedonic analysis (section 4.3). Characterize products sensory properties. This can be done through napping analysis (section 4.4). Rank product according to few sensory descriptors. This can be done through rank analysis (section 4.5). 4.1.2 Decision tree For each analysis, a decision tree is proposed (Figure 4.1) based on the objective, the number of products and the number of tasters. For all analysis, no training is needed for tasters. Figure 4.1: Decision tree with experimental constraints, designs and methods of sensory analysis carry out in PPBstats regarding the objective : Compare different varieties evaluated for selection in different locations. D refers to designs and M to methods. Once you have chosen your objective, analysis and experimental design, you can taste and measure … (section 4.2). 4.1.3 Workflow and function relations in PPBstats regarding organoleptic analysis After designing the experiment and describing the data, each family of analysis is implemented by several analysis with the same workflow : Format the data Run the model Check the model and visualize outputs Compare means, format data for biplot and visualize outputs Figure 4.2 displays the functions and their relationships. Table 4.1 describes each of the main functions. You can have more information for each function by typing ?function_name in your R session. Note that check_model(), mean_comparison(), biplot_data() and plot() are S3 method. Therefore, you should type ?check_model, ?mean_comparison, ?biplot_data or ?plot.PPBstats to have general features and then see in details for specific functions. Figure 4.2: Main functions used in the workflow. Table 4.1: Function description. function name description design_experiment Provides experimental design for the different situations corresponding to the choosen family of analysis format_data_PPBstats Check and format the data to be used in PPBstats functions describe_data Describe the data set in order to choose the appropriate analysis to carry out hedonic Run hedonic analysis napping Run napping anaysis rank Run rank analysis check_model Check if the model went well mean_comparisons Get mean comparisons biplot_data Format multivariate results plot Build ggplot objects to visualize output 4.1.4 Data format For organoleptic analysis data must have a specific format. Each format is displayed in the corresponding analysis section. "],
["taste.html", "4.2 Taste and measure …", " 4.2 Taste and measure … !!! TO DO !!! "],
["hedonic.html", "4.3 Hedonic analysis (M9b)", " 4.3 Hedonic analysis (M9b) 4.3.1 Method description The hedonic evaluation test involves asking consumers to : to rate their preference from 1 (I dislike extremely) to 9 (I like very much) for three to four sensory attributes specific to the test product. The overall preference is ascertained at the beginning of the questionnaire in order not to influence the consumer and be closer to typical conditions of consumption. give additional information such as sex, age and organic consumption frequency in order to characterise the population sample. give additional sensory descriptors to describe products are asked after evaluation of each product. 4.3.1.1 Determine differences of appreciation for each samples Regarding samples, the objectives of the hedonic tests are to determine differences of appreciation for a given attribute between the set of samples bsed on the note given by the juges and determine appreciation of samples based on descriptors given by the juges Differences of sample regarding the note given by the juges. The data distribution determines the type of tests that should be used to analyze the data set. If the distribution is Normal, one-way analysis of variance (ANOVA) can be performed: \\(Y_{ij} = \\alpha_i + \\beta_j + \\varepsilon_{ij}; \\quad \\varepsilon_{ijkl} \\sim \\mathcal{N} (0,\\sigma^2)\\) with \\(Y_{ij}\\) the note from 1 to 9 given by a person to a sample, \\(\\alpha_i\\) the person (i.e. assessor) that taste the sample, \\(\\beta_j\\) the germplasm tasted, \\(\\varepsilon_{ijkl}\\) the residuals. Then, multiple comparison of mean on germplasm are performed. The aim is to obtain a final ranking based on consumers’ preferences. If the data set doesn’t follow a Normal distribution, a Friedman test on the rank should be used to indicate if the varieties are perceived differently by assessors. Appreciation of sample regarding the descriptors given by the juges. To do so, Correspondance Analysis (CA) is done on the data with descriptors. 4.3.1.2 Juges profiles Another objective of the analysis is to determine juges profiles based on the note given and the additional information such as sex, age and organic consumption frequency, etc. It is done with a Hierarchical Clustering on Principle Components (HCPC) that can be implement to identify groups of juges preferences after a Principal Component Analysis (PCA). 4.3.2 Steps with PPBstats For hedonic analysis, you can follow these steps (Figure 4.2): Format the data with format_data_PPBstats() Describe the data with plot() Run the model with model_hedonic() Check model outputs with graphs to know if you can continue the analysis with check_model() Get mean comparisons on the note given by the juges for each factor with mean_comparisons() and vizualise it with plot() Format data for CA and HCPC analysis with biplot_data() and visualise it with plot() 4.3.3 Format the data data(data_hedonic) head(data_hedonic) ## sample germplasm location juges note descriptors Age Sexe ## 1 832 germ-1 loc-1 1 7 douce; juteuse 21 F ## 2 412 germ-1 loc-1 1 8 juteuse; sucree 21 F ## 3 465 germ-2 loc-1 1 5 acide 21 F ## 4 108 germ-3 loc-1 1 7 sucree 21 F ## 5 967 germ-4 loc-1 1 8 sucree 21 F ## 6 619 germ-5 loc-1 1 6 peau epaisse; juteuse 21 F ## Bio.Non.Bio Circuit Departement ## 1 1 1;2;3 30 ## 2 1 1;2;3 30 ## 3 1 1;2;3 30 ## 4 1 1;2;3 30 ## 5 1 1;2;3 30 ## 6 1 1;2;3 30 The data frame has the following columns: sample, germplasm, location, juges, note, descriptors. The descriptors must be separated by “;”. Any other column can be added as supplementary variables. Then, you must format your data with format_data_PPBstats() and type = &quot;data_organo_hedonic&quot;. Argument threshold can be set in order to keep only descriptors that have been cited several time. For exemple with threshold = 2, only descriptors cited at least twice are kept. data_hedonic = format_data_PPBstats(data_hedonic, type = &quot;data_organo_hedonic&quot;, threshold = 2) ## Warning in format_data_PPBstats.data_organo_hedonic(data, threshold): The following samples are not kept because they have been already tasted (i.e. germplasm and location combinaison already exist): ## sample 412 by juge 1 on row 2 ## Warning in format_data_PPBstats.data_organo_hedonic(data, threshold): The ## following row in data have been remove because there are no descriptors :9 ## The following descriptors have been remove because there were less or equal to 2 occurences : aciduee, acidulee, classique, classique, classique , cremeuse, croquante, epicee, equilibree, farineuse, ferme, fondante, legere, molle, parfumee, salee, sucree ## data has been formated for PPBstats functions. names(data_hedonic) ## [1] &quot;data&quot; &quot;var_sup&quot; &quot;descriptors&quot; data_hedonic is a list of four elements : data the data formated to run the anova and the multivariate analysis regarding sample head(data_hedonic$data$data_sample) ## sample germplasm location juges note Age Sexe Bio.Non.Bio Circuit ## 1 loc-1:germ-1 germ-1 loc-1 1 7 21 F 1 1;2;3 ## 2 loc-1:germ-2 germ-2 loc-1 1 5 21 F 1 1;2;3 ## 3 loc-1:germ-3 germ-3 loc-1 1 7 21 F 1 1;2;3 ## 4 loc-1:germ-4 germ-4 loc-1 1 8 21 F 1 1;2;3 ## 5 loc-1:germ-5 germ-5 loc-1 1 6 21 F 1 1;2;3 ## 6 loc-1:germ-6 germ-6 loc-1 2 7 30 F 1 ## Departement acide acidulee charnue douce douce equilibree ## 1 30 0.00000000 0 0 0.03703704 0 0 ## 2 30 0.02941176 0 0 0.00000000 0 0 ## 3 30 0.00000000 0 0 0.00000000 0 0 ## 4 30 0.00000000 0 0 0.00000000 0 0 ## 5 30 0.00000000 0 0 0.00000000 0 0 ## 6 11 0.00000000 0 0 0.00000000 0 0 ## farineuse ferme fraiche fruitee goutue goutue juteuse juteuse neutre ## 1 0 0 0 0 0 0 0 0.3333333 0 ## 2 0 0 0 0 0 0 0 0.0000000 0 ## 3 0 0 0 0 0 0 0 0.0000000 0 ## 4 0 0 0 0 0 0 0 0.0000000 0 ## 5 0 0 0 0 0 0 0 0.3333333 0 ## 6 0 0 0 0 0 0 0 0.0000000 0 ## parfumee peau epaisse peau epaisse sucree sucree tendre ## 1 0 0 0.00000000 0.00000000 0 0 ## 2 0 0 0.00000000 0.00000000 0 0 ## 3 0 0 0.00000000 0.02272727 0 0 ## 4 0 0 0.00000000 0.02272727 0 0 ## 5 0 0 0.02040816 0.00000000 0 0 ## 6 0 0 0.00000000 0.02272727 0 0 - sample_mean which gathers for each sample a mean for note and descriptors head(data_hedonic$data$data_sample_mean) ## sample germplasm location note acide acidulee ## 1 loc-1:germ-1 germ-1 loc-1 6.125000 0.003586801 0.001742160 ## 2 loc-1:germ-2 germ-2 loc-1 6.050000 0.004304161 0.005226481 ## 3 loc-1:germ-3 germ-3 loc-1 6.769231 0.002205882 0.001785714 ## 4 loc-1:germ-4 germ-4 loc-1 6.871795 0.004411765 0.008928571 ## 5 loc-1:germ-5 germ-5 loc-1 5.692308 0.006617647 0.000000000 ## 6 loc-1:germ-6 germ-6 loc-1 6.128205 0.003676471 0.007142857 ## charnue douce douce equilibree farineuse ferme ## 1 0.004065041 0.008130081 0.000000000 0.000000000 0.003048780 0.000 ## 2 0.012195122 0.004516712 0.004065041 0.016260163 0.006097561 0.000 ## 3 0.004166667 0.001851852 0.008333333 0.008333333 0.000000000 0.010 ## 4 0.000000000 0.000000000 0.008333333 0.000000000 0.006250000 0.010 ## 5 0.000000000 0.004629630 0.004166667 0.000000000 0.006250000 0.000 ## 6 0.004166667 0.005555556 0.000000000 0.000000000 0.003125000 0.005 ## fraiche fruitee goutue goutue juteuse juteuse ## 1 0.00000 0.00000 0.001742160 0.009756098 0.004065041 0.008130081 ## 2 0.00000 0.00000 0.003484321 0.000000000 0.004065041 0.000000000 ## 3 0.00625 0.01875 0.003571429 0.005000000 0.005555556 0.000000000 ## 4 0.00625 0.00625 0.003571429 0.005000000 0.002777778 0.008333333 ## 5 0.00000 0.00000 0.010714286 0.000000000 0.005555556 0.008333333 ## 6 0.01250 0.00000 0.001785714 0.005000000 0.002777778 0.000000000 ## neutre parfumee peau epaisse peau epaisse sucree ## 1 0.006968641 0.005420054 0.004065041 0.003982081 0.004434590 ## 2 0.005226481 0.002710027 0.004065041 0.003484321 0.004988914 ## 3 0.004464286 0.005555556 0.008333333 0.003571429 0.005113636 ## 4 0.001785714 0.008333333 0.000000000 0.003571429 0.005113636 ## 5 0.002678571 0.000000000 0.008333333 0.005612245 0.001704545 ## 6 0.003571429 0.002777778 0.000000000 0.004591837 0.003409091 ## sucree tendre ## 1 0.004065041 0.000000000 ## 2 0.000000000 0.000000000 ## 3 0.008333333 0.008333333 ## 4 0.004166667 0.000000000 ## 5 0.004166667 0.008333333 ## 6 0.004166667 0.008333333 - juges which gathers for each juge a mean for note head(data_hedonic$data$data_juges) ## juges loc-1:germ-1 loc-1:germ-2 loc-1:germ-3 loc-1:germ-4 loc-1:germ-5 ## 1 1 7 5 7 8 6 ## 2 2 7 8 NA 6 NA ## 3 4 6 4 NA NA 3 ## 4 5 6 NA 5 7 6 ## 5 6 6 5 7 6 3 ## 6 7 NA 5 7 6 2 ## loc-1:germ-6 Age Sexe Bio.Non.Bio Circuit Departement ## 1 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 7 30 F 1 11 ## 3 7 12 F 1 1 &lt;NA&gt; ## 4 4 &lt;NA&gt; &lt;NA&gt; ## 5 7 49 H 1 1 &lt;NA&gt; ## 6 6 37 F 1 2 11 var_sup the supplementary variables used in the multivariate analysis data_hedonic$var_sup ## [1] &quot;Age&quot; &quot;Sexe&quot; &quot;Bio.Non.Bio&quot; &quot;Circuit&quot; &quot;Departement&quot; descriptors the vector of descriptors cited knowing the threshold applyed when formated the data. data_hedonic$descriptors ## [1] &quot;acide&quot; &quot;acidulee&quot; &quot;charnue&quot; &quot;douce&quot; ## [5] &quot; douce&quot; &quot;equilibree&quot; &quot;farineuse&quot; &quot;ferme&quot; ## [9] &quot;fraiche&quot; &quot;fruitee&quot; &quot;goutue&quot; &quot; goutue&quot; ## [13] &quot;juteuse&quot; &quot; juteuse&quot; &quot;neutre&quot; &quot;parfumee&quot; ## [17] &quot; peau epaisse&quot; &quot;peau epaisse&quot; &quot;sucree&quot; &quot; sucree&quot; ## [21] &quot;tendre&quot; 4.3.4 Describe the data First, you can describe the data regarding the note given p_note = plot(data_hedonic, plot_type = &quot;boxplot&quot;, x_axis = &quot;germplasm&quot;, in_col = &quot;location&quot;, vec_variables = &quot;note&quot; ) ## Warning in reshape_data_split_x_axis_in_col(d, variable, labels_on, ## x_axis, : 6 rows have been deleted for note because of only NA on the row ## for these variables. p_note ## $note ## $note$`germplasm-1|location-1` ## ## $note$`germplasm-2|location-1` As well as the descriptors for each germplasm for example: descriptors = data_hedonic$descriptors p_des = plot(data_hedonic, plot_type = &quot;radar&quot;, in_col = &quot;germplasm&quot;, vec_variables = descriptors ) p_des ## $`all-variables` 4.3.5 Run the model To run the model on the dataset, used the function model_hedonic. out_hedonic = model_hedonic(data_hedonic) ## Warning in PCA(data_juges_hcpc, quanti.sup = id_quanti.sup, quali.sup = ## id_quali.sup, : Missing values are imputed by the mean of the variable: you ## should use the imputePCA function of the missMDA package out_hedonic is a list with three elements: model : the result of the anova run on note out_hedonic$model ## ## Call: ## stats::lm(formula = note ~ juges + germplasm, data = data_sample) ## ## Coefficients: ## (Intercept) juges2 juges4 juges5 ## 6.31772 0.34588 -1.35400 -1.04203 ## juges6 juges7 juges8 juges9 ## -0.93390 -1.45714 -2.35549 0.39943 ## juges10 juges11 juges12 juges13 ## 0.75797 0.56610 -3.26724 0.39943 ## juges14 juges15 juges16 juges17 ## -1.19356 -1.35250 1.60000 0.39943 ## juges19 juges20 juges23 juges24 ## 1.20006 -1.20183 -4.60341 1.14451 ## juges25 juges26 juges27 juges28 ## 0.90629 -1.35400 -0.42967 -1.70036 ## juges31 juges32 juges33 juges34 ## -0.43390 -0.10400 2.27689 1.14451 ## juges35 juges36 juges37 juges38 ## 0.55797 -1.26724 -0.10057 -0.42057 ## juges39 juges41 juges42 juges43 ## -1.60341 0.52540 0.64750 1.46789 ## juges44 juges45 juges46 juges47 ## -0.66903 -1.19878 -1.20183 -0.46056 ## juges49 juges50 juges51 juges52 ## -0.60057 -0.52690 0.93973 -1.70183 ## juges53 juges54 juges56 juges57 ## 0.89520 -1.43390 2.11465 -1.58120 ## juges58 juges59 juges62 juges63 ## -2.39327 -1.76724 -0.97311 0.56610 ## juges64 juges65 juges66 juges68 ## 0.14451 1.11465 -1.74361 0.52689 ## juges69 juges70 juges71 juges72 ## 1.14451 -0.43390 -1.09371 0.65909 ## juges73 juges74 germplasmgerm-2 germplasmgerm-3 ## 0.56610 -1.13931 0.07555 0.56763 ## germplasmgerm-4 germplasmgerm-5 germplasmgerm-6 ## 0.98436 -0.21612 0.28569 anova(out_hedonic$model) ## Analysis of Variance Table ## ## Response: note ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## juges 61 325.98 5.3439 2.3286 1.071e-05 *** ## germplasm 5 32.83 6.5657 2.8610 0.01657 * ## Residuals 169 387.84 2.2949 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 CA : the result of the correspondance analysis run on the data set with the supplementary variables with FactoMineR::CA out_hedonic$CA ## **Results of the Correspondence Analysis (CA)** ## The row variable has 6 categories; the column variable has 21 categories ## The chi square of independence between the two variables is equal to 0.3704251 (p-value = 1 ). ## *The results are available in the following objects: ## ## name description ## 1 &quot;$eig&quot; &quot;eigenvalues&quot; ## 2 &quot;$col&quot; &quot;results for the columns&quot; ## 3 &quot;$col$coord&quot; &quot;coord. for the columns&quot; ## 4 &quot;$col$cos2&quot; &quot;cos2 for the columns&quot; ## 5 &quot;$col$contrib&quot; &quot;contributions of the columns&quot; ## 6 &quot;$row&quot; &quot;results for the rows&quot; ## 7 &quot;$row$coord&quot; &quot;coord. for the rows&quot; ## 8 &quot;$row$cos2&quot; &quot;cos2 for the rows&quot; ## 9 &quot;$row$contrib&quot; &quot;contributions of the rows&quot; ## 10 &quot;$quanti.sup$coord&quot; &quot;coord. for supplementary continuous var.&quot; ## 11 &quot;$quanti.sup$cos2&quot; &quot;cos2 for supplementary continuous var.&quot; ## 12 &quot;$quali.sup$coord&quot; &quot;coord. for supplementary categorical var.&quot; ## 13 &quot;$quali.sup$cos2&quot; &quot;cos2 for supplementary categorical var.&quot; ## 14 &quot;$call&quot; &quot;summary called parameters&quot; ## 15 &quot;$call$marge.col&quot; &quot;weights of the columns&quot; ## 16 &quot;$call$marge.row&quot; &quot;weights of the rows&quot; HCPC : the result of the correspondane analysis run on the data set with the supplementary variables with FactoMineR::PCA follow by FactoMineR::HCPC. It is a list of three elements: out_hedonic$HCPC$res.pca ## **Results for the Principal Component Analysis (PCA)** ## The analysis was performed on 63 individuals, described by 11 variables ## *The results are available in the following objects: ## ## name ## 1 &quot;$eig&quot; ## 2 &quot;$var&quot; ## 3 &quot;$var$coord&quot; ## 4 &quot;$var$cor&quot; ## 5 &quot;$var$cos2&quot; ## 6 &quot;$var$contrib&quot; ## 7 &quot;$ind&quot; ## 8 &quot;$ind$coord&quot; ## 9 &quot;$ind$cos2&quot; ## 10 &quot;$ind$contrib&quot; ## 11 &quot;$quali.sup&quot; ## 12 &quot;$quali.sup$coord&quot; ## 13 &quot;$quali.sup$v.test&quot; ## 14 &quot;$call&quot; ## 15 &quot;$call$centre&quot; ## 16 &quot;$call$ecart.type&quot; ## 17 &quot;$call$row.w&quot; ## 18 &quot;$call$col.w&quot; ## description ## 1 &quot;eigenvalues&quot; ## 2 &quot;results for the variables&quot; ## 3 &quot;coord. for the variables&quot; ## 4 &quot;correlations variables - dimensions&quot; ## 5 &quot;cos2 for the variables&quot; ## 6 &quot;contributions of the variables&quot; ## 7 &quot;results for the individuals&quot; ## 8 &quot;coord. for the individuals&quot; ## 9 &quot;cos2 for the individuals&quot; ## 10 &quot;contributions of the individuals&quot; ## 11 &quot;results for the supplementary categorical variables&quot; ## 12 &quot;coord. for the supplementary categories&quot; ## 13 &quot;v-test of the supplementary categories&quot; ## 14 &quot;summary statistics&quot; ## 15 &quot;mean of the variables&quot; ## 16 &quot;standard error of the variables&quot; ## 17 &quot;weights for the individuals&quot; ## 18 &quot;weights for the variables&quot; out_hedonic$HCPC$res.hcpc ## **Results for the Hierarchical Clustering on Principal Components** ## name ## 1 &quot;$data.clust&quot; ## 2 &quot;$desc.var&quot; ## 3 &quot;$desc.var$quanti.var&quot; ## 4 &quot;$desc.var$quanti&quot; ## 5 &quot;$desc.var$test.chi2&quot; ## 6 &quot;$desc.axes$category&quot; ## 7 &quot;$desc.axes&quot; ## 8 &quot;$desc.axes$quanti.var&quot; ## 9 &quot;$desc.axes$quanti&quot; ## 10 &quot;$desc.ind&quot; ## 11 &quot;$desc.ind$para&quot; ## 12 &quot;$desc.ind$dist&quot; ## 13 &quot;$call&quot; ## 14 &quot;$call$t&quot; ## description ## 1 &quot;dataset with the cluster of the individuals&quot; ## 2 &quot;description of the clusters by the variables&quot; ## 3 &quot;description of the cluster var. by the continuous var.&quot; ## 4 &quot;description of the clusters by the continuous var.&quot; ## 5 &quot;description of the cluster var. by the categorical var.&quot; ## 6 &quot;description of the clusters by the categories.&quot; ## 7 &quot;description of the clusters by the dimensions&quot; ## 8 &quot;description of the cluster var. by the axes&quot; ## 9 &quot;description of the clusters by the axes&quot; ## 10 &quot;description of the clusters by the individuals&quot; ## 11 &quot;parangons of each clusters&quot; ## 12 &quot;specific individuals&quot; ## 13 &quot;summary statistics&quot; ## 14 &quot;description of the tree&quot; head(out_hedonic$HCPC$clust) ## loc-1:germ-1 loc-1:germ-2 loc-1:germ-3 loc-1:germ-4 loc-1:germ-5 ## 1 7.000 5.00 7.000000 8.000000 6.000000 ## 2 7.000 8.00 6.769231 6.000000 5.692308 ## 4 6.000 4.00 6.769231 6.871795 3.000000 ## 5 6.000 6.05 5.000000 7.000000 6.000000 ## 6 6.000 5.00 7.000000 6.000000 3.000000 ## 7 6.125 5.00 7.000000 6.000000 2.000000 ## loc-1:germ-6 Age Sexe Bio.Non.Bio Circuit Departement clust ## 1 6.128205 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; cluster 6 ## 2 7.000000 30 F 1 11 cluster 5 ## 4 7.000000 12 F 1 1 &lt;NA&gt; cluster 4 ## 5 4.000000 &lt;NA&gt; &lt;NA&gt; cluster 3 ## 6 7.000000 49 H 1 1 &lt;NA&gt; cluster 4 ## 7 6.000000 37 F 1 2 11 cluster 4 4.3.6 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.1.2. 4.3.6.1 Check the model out_check_hedonic = check_model(out_hedonic) out_check_hedonic is list with two elements: hedonic which it the same objet as out_hedonic data_ggplot a list containing information for ggplot: data_ggplot_residuals a list containing : data_ggplot_normality data_ggplot_skewness_test data_ggplot_kurtosis_test data_ggplot_shapiro_test data_ggplot_qqplot data_ggplot_variability_repartition_pie data_ggplot_var_intra 4.3.6.2 Visualize outputs Once the computation is done, you can visualize the results with plot() p_out_check_hedonic = plot(out_check_hedonic) p_out_check_hedonic is a list with: residuals of the ANOVA model histogram : histogram with the distribution of the residuals p_out_check_hedonic$residuals$histogram ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qqplot p_out_check_hedonic$residuals$qqplot points p_out_check_hedonic$residuals$points variability_repartition : pie with repartition of SumSq for each factor of the ANOVA model p_out_check_hedonic$variability_repartition variance_intra_germplasm : repartition of the residuals for each germplasm which represent the person assessor variation plus the intra-germplasm variance of the ANOVA model. p_out_check_hedonic$variance_intra_germplasm CA_composante_variance : variance caught by each dimension of the CA p_out_check_hedonic$CA_composante_variance HCPC_composante_variance : variance caught by each dimension of the PCA previous to the HCPC p_out_check_hedonic$PCA_composante_variance 4.3.7 Get and visualize mean comparisons on note The method to compute mean comparison are explained in section 3.1.2.1.3. 4.3.7.1 Get mean comparisons on note Get mean comparisons with mean_comparisons(). out_mean_comparisons_hedonic = mean_comparisons(out_check_hedonic) out_mean_comparisons_hedonic is a list of one element for futher ggplot : data_ggplot_LSDbarplot_germplasm 4.3.7.2 Visualize mean comparisons on note p_out_mean_comparisons_hedonic = plot(out_mean_comparisons_hedonic) p_out_mean_comparisons_hedonic is a list of on elements with barplots : For each element of the list, there are as many graph as needed with nb_parameters_per_plot parameters per graph. Letters are displayed on each bar. Parameters that do not share the same letters are different regarding type I error (alpha) and alpha correction. The error I (alpha) and the alpha correction are displayed in the title. germplasm : mean comparison for germplasm pg = p_out_mean_comparisons_hedonic$germplasm names(pg) ## [1] &quot;1&quot; pg$`1` 4.3.8 Get and visualize biplot regarding samples (CA) and juges (HCPC) The biplot represents information about the percentages of total variation explained by the two axes. It has to be linked to the total variation caught by the interaction. If the total variation is small, then the biplot is useless. If the total variation is high enought, then the biplot is useful if the two first dimension represented catch enought variation (the more the better). 4.3.8.1 Get biplot Get biplot regading samples (CA) and juges (HCPC) out_biplot_hedonic = biplot_data(out_check_hedonic) 4.3.8.2 Visualize biplot p_out_biplot_hedonic = plot(out_biplot_hedonic) p_out_biplot_hedonic is a list of two elements with the CA biplot where descriptors are represented by a triangle in red and samples are represented by text in blue and point in color refering to the sample. p_out_biplot_hedonic$ca_biplot the HCPC biplot is a list of two elements : one with the variable ans the additionnal variables and the other with the groups of juges detected by the HCPC. p_out_biplot_hedonic$hcpc_biplot ## $var ## ## $cluster "],
["napping.html", "4.4 Napping analysis (M9a)", " 4.4 Napping analysis (M9a) 4.4.1 Method description The Napping allows you to look for sensory differences between products. Differences are on global sensory characteristics and should be complemented with a verbalisation task to ease the understanding of the differences. It offers greater flexibility, as no trained panel is needed. Two tasks are done in a Napping: The sorting task: each taster is asked to position the whole set of products on a sheet of blank paper (a tablecloth) according to their similarities/dissimilarities. Thus, two products are close if they are perceived as similar or, on the contrary, distant from each other if they are perceived as different. Each taster uses his/her own criteria. The verbalisation task: After performing the napping task, the panellists are asked to describe the products by writing one or two sensory descriptors that characterize each group of products on the map. Panels should be composed from 12 to 25 tasters according to the judge’s experience with the product and to the objective of the experiment. For example ten farmers-bakers should be enough to have reliable results as they are used to eat and taste bread. In case of consumers, a panel of twenty could be more adapted. No more than ten products should be evaluate simultaneously. A random, three-digit code should be assigned to each sample. Samples are presented simultaneously and the assessors can taste as much as they need. Napping data lead to a quantitative table. The rows are the products. This table presents the number of panellists (\\(i\\)) sets (one set for each panellist) of two columns corresponding to the horizontal and vertical coordinate (\\(X\\), \\(Y\\)). Two columns correspond to each subject (i.e. person that taste) \\(j\\): the X-coordinate (\\(X_j\\)) and the Y-coordinate (\\(Y_j\\)) for each product. Sensory descriptors are coded through a “products x words” frequency table. First a contingency table counting the number that each descriptor has been used to describe each product is created. Then this contingency table is transformed in frequencies so that the “word frequency” is a qualitative variables with the number of words cited as modalities. To analyse this kind of data, a Multiple Factor Analysis (MFA) should be performed. Each subject constitute a group of two un-standardised variables. The MFA led to a synthesis of the panellist’s tablecloth. Two products are close if all judges consider them close on the napping. The more the two first components of MFA explain the original variability, the more the judges are in agreement. The frequency table crossing products and word frequency is considered as a set of supplementary variables: they do not intervene in the axes construction but their correlation with the factors of MFA are calculated and represented as in usual PCA. 4.4.2 Steps with PPBstats For hedonic analysis, you can follow these steps (Figure 4.2): Format the data with format_data_PPBstats() Describe the data with plot() Run the model with model_napping() Check model outputs with graphs to know if you can continue the analysis with check_model() Format data for multivariate analysis with biplot_data and visualise it with plot() 4.4.3 Format the data data(data_napping) head(data_napping) ## juges X Y descriptors germplasm location ## 1 L1J1 7.61970 15.2778 peau_epaisse;sansinteret;;; germ-2 loc-4 ## 2 L1J1 24.15010 15.4831 agreable;equilibree;parfumee;; germ-8 loc-4 ## 3 L1J1 24.38950 15.1427 agreable;equilibree;parfumee;; germ-10 loc-4 ## 4 L1J1 7.73941 15.1076 peau_epaisse;sansinteret;;; germ-7 loc-4 ## 5 L1J1 24.50820 14.8881 agreable;equilibree;parfumee;; germ-5 loc-4 ## 6 L1J1 7.73648 14.8546 peau_epaisse;sansinteret;;; germ-6 loc-4 The data frame has the following columns: juges, X, Y, descriptors, germplasm, location. The descriptors must be separated by “;”. Any other column can be added as supplementary variables. Then, you must format your data with format_data_PPBstats() and type = &quot;data_organo_napping&quot;. Argument threshold can be set in order to keep only descriptors that have been cited several time. For exemple with threshold = 2, on ly descriptors cited at least twice are kept. data_napping = format_data_PPBstats(data_napping, type = &quot;data_organo_napping&quot;, threshold = 2) ## The following descriptors have been remove because there were less or equal to 2 occurences : arôme_tomate, arôme_vegetal, mauvaise, sansjus ## data has been formated for PPBstats functions. names(data_napping) ## [1] &quot;data&quot; &quot;descriptors&quot; data_napping is a list of three elements : - data the data formated to run the anova and the multivariate analysis head(data_napping$data) ## germplasm location X1-juge-L1J1 Y1-juge-L1J1 X2-juge-L1J2 ## loc-4:germ-2 germ-2 loc-4 7.61970 15.2778 11.37260 ## loc-4:germ-8 germ-8 loc-4 24.15010 15.4831 10.89340 ## loc-4:germ-10 germ-10 loc-4 24.38950 15.1427 18.53270 ## loc-4:germ-7 germ-7 loc-4 7.73941 15.1076 3.82513 ## loc-4:germ-5 germ-5 loc-4 24.50820 14.8881 15.39790 ## loc-4:germ-6 germ-6 loc-4 7.73648 14.8546 17.55090 ## Y2-juge-L1J2 X3-juge-L1J3 Y3-juge-L1J3 X4-juge-L1J4 ## loc-4:germ-2 18.94060 26.76360 4.09963 24.80630 ## loc-4:germ-8 11.46420 17.34150 8.82138 22.01280 ## loc-4:germ-10 3.91870 26.89530 3.75490 24.26340 ## loc-4:germ-7 5.53018 6.34316 8.18904 3.61136 ## loc-4:germ-5 12.44060 26.89560 3.62606 24.47550 ## loc-4:germ-6 17.54730 10.59180 7.70753 4.11214 ## Y4-juge-L1J4 X5-juge-L1J5 Y5-juge-L1J5 X6-juge-L1J6 ## loc-4:germ-2 16.02890 20.16100 15.64430 11.01970 ## loc-4:germ-8 8.93096 8.49433 13.38500 22.13920 ## loc-4:germ-10 13.48410 18.43640 14.65120 24.61340 ## loc-4:germ-7 3.97247 8.19899 7.59655 4.24403 ## loc-4:germ-5 13.29670 24.14130 17.18980 11.27140 ## loc-4:germ-6 4.01245 4.04596 2.31195 3.97323 ## Y6-juge-L1J6 X7-juge-L1J7 Y7-juge-L1J7 acide acidulee ## loc-4:germ-2 8.67583 27.3515 18.71840 0 0.000 ## loc-4:germ-8 15.23870 11.9787 8.51911 0 0.125 ## loc-4:germ-10 6.72938 24.9678 17.57220 0 0.125 ## loc-4:germ-7 14.28710 16.7013 14.81300 0 0.125 ## loc-4:germ-5 9.42970 25.7311 15.94830 0 0.000 ## loc-4:germ-6 7.97040 11.8953 9.95286 0 0.125 ## agreable aqueuse aromatique douce equilibree fade ## loc-4:germ-2 0.00 0.0000000 0.3 0.000 0.0000000 0.00000000 ## loc-4:germ-8 0.25 0.6666667 0.0 0.125 0.3333333 0.07692308 ## loc-4:germ-10 0.25 0.0000000 0.2 0.250 0.1666667 0.00000000 ## loc-4:germ-7 0.00 0.0000000 0.1 0.250 0.0000000 0.23076923 ## loc-4:germ-5 0.25 0.0000000 0.2 0.125 0.3333333 0.07692308 ## loc-4:germ-6 0.00 0.3333333 0.1 0.125 0.0000000 0.15384615 ## farineuse fibreuse fondante fruitee gouteuse juteuse ## loc-4:germ-2 0.0000000 0.0000000 0.18181818 0.0000000 0.25000000 0.250 ## loc-4:germ-8 0.0000000 0.0000000 0.27272727 0.3333333 0.00000000 0.125 ## loc-4:germ-10 0.1428571 0.0000000 0.09090909 0.0000000 0.25000000 0.125 ## loc-4:germ-7 0.2857143 0.6666667 0.00000000 0.3333333 0.08333333 0.000 ## loc-4:germ-5 0.0000000 0.0000000 0.09090909 0.3333333 0.25000000 0.250 ## loc-4:germ-6 0.1428571 0.3333333 0.00000000 0.0000000 0.00000000 0.125 ## parfumee peau_epaisse raffraichissante sansinteret ## loc-4:germ-2 0.00 0.11764706 0.3333333 0.1666667 ## loc-4:germ-8 0.25 0.11764706 0.0000000 0.0000000 ## loc-4:germ-10 0.25 0.05882353 0.3333333 0.0000000 ## loc-4:germ-7 0.00 0.05882353 0.0000000 0.3333333 ## loc-4:germ-5 0.25 0.11764706 0.3333333 0.0000000 ## loc-4:germ-6 0.00 0.23529412 0.0000000 0.1666667 ## sucree sample ## loc-4:germ-2 0.23529412 loc-4:germ-2 ## loc-4:germ-8 0.05882353 loc-4:germ-8 ## loc-4:germ-10 0.23529412 loc-4:germ-10 ## loc-4:germ-7 0.11764706 loc-4:germ-7 ## loc-4:germ-5 0.23529412 loc-4:germ-5 ## loc-4:germ-6 0.00000000 loc-4:germ-6 descriptors the vector of descriptors cited knowing the threhold applyed when formated the data. data_napping$descriptors ## [1] &quot;acide&quot; &quot;acidulee&quot; &quot;agreable&quot; ## [4] &quot;aqueuse&quot; &quot;aromatique&quot; &quot;douce&quot; ## [7] &quot;equilibree&quot; &quot;fade&quot; &quot;farineuse&quot; ## [10] &quot;fibreuse&quot; &quot;fondante&quot; &quot;fruitee&quot; ## [13] &quot;gouteuse&quot; &quot;juteuse&quot; &quot;parfumee&quot; ## [16] &quot;peau_epaisse&quot; &quot;raffraichissante&quot; &quot;sansinteret&quot; ## [19] &quot;sucree&quot; 4.4.4 Describe the data First, you can describe the data regarding the descriptors for each germplasm for example. descriptors = data_napping$descriptors p_des = plot(data_napping, plot_type = &quot;radar&quot;, vec_variables = descriptors, in_col = &quot;sample&quot;) # in_col = germplasm or location p_des ## $`all-variables` 4.4.5 Run the model To run the model on the dataset, used the function model_napping. out_napping = model_napping(data_napping) out_napping is a list with the MFA object coming from FactoMineR::MFA and the data. 4.4.6 Check and visualize model outputs The tests to check the model are explained in section 3.1.2.1.2. 4.4.6.1 Check the model out_check_napping = check_model(out_napping) out_check_nappingis the same objet as out_napping 4.4.6.2 Visualize outputs Once the computation is done, you can visualize the results with plot p_out_check_napping = plot(out_check_napping) p_out_check_napping is a plot representing the variance caught by each dimension of the MFA p_out_check_napping 4.4.7 Get and visualize biplot The biplot represents information about the percentages of total variation explained by the two axes. It has to be linked to the total variation caught by the interaction. If the total variation is small, then the biplot is useless. If the total variation is high enought, then the biplot is useful if the two first dimension represented catch enought variation (the more the better). 4.4.7.1 Get biplot out_biplot_napping = biplot_data(out_check_napping) 4.4.7.2 Visualize biplot out_biplot_napping is the same objet as out_check_napping p_out_biplot_napping = plot(out_biplot_napping) p_out_biplot_napping is a list of three elements: partial_axes p_out_biplot_napping$var - ind p_out_biplot_napping$ind_germplasm - var p_out_biplot_napping$ind_location "],
["rank.html", "4.5 Rank analysis (M9c)", " 4.5 Rank analysis (M9c) 4.5.1 Method description A panel of assessors compares several products simultaneously and ranks them according to the perceived magnitude of a given sensory characteristic (e.g. acidity, fibrousness). This method has the advantage of being easy to implement. The jury ideally comprises 12 semi-naive assessors (consumers initiated to sensory analyses) according to the ISO 8587 standard13, although it is possible to highlight significant differences with a smaller number of assessors. Key Characteristics: Products are presented simultaneously This requires that the whole set of samples to be tested is available at the same time. Some vegetable species show marked differences in precocity (e.g. broccoli), and therefore care should be taken to ensure that samples of the same precocity are compared. The assessors can taste as much as they need. When they answer, assessors cannot put any two products at the same rank, i.e. all ranks assigned must be unique. It is advised not to exceed 6 samples per session. Null hypothesis (H0): all varieties have exactly the same responses (rank means are equal) Friedman’s test (non parametric test on k independent samples) leads to the rejection or acceptance of this hypothesis, based on α value (&lt;0.05). 4.5.2 Steps with PPBstats 4.5.3 Format the data 4.5.4 Run the model ISO 8587:2006 is a standard from International Organisation for Standardisation which describes a method for sensory evaluation with the aim of placing a series of test samples in rank order.↩ "],
["molecular.html", "Chapter 5 Molecular analysis (M3)", " Chapter 5 Molecular analysis (M3) Please, feel free to contribute to this part of analysis, see here for more informations. "],
["com.html", "Chapter 6 Communicate results to farmers", " Chapter 6 Communicate results to farmers Within a PPB programme, it is important to give results back to the farmers in order to discuss and accompagny them in their selection. This can be done through the creation of a report with results coming from the analysis as described in section 6.1. The results coming from the analysis must be taken with caution by a group or farmers as it can influence collective organisation as described in section 6.2. "],
["com-technic.html", "6.1 Technical aspects", " 6.1 Technical aspects The workflow to create the report follow three steps: run the analysis and create a list with all results create a .Rmd template that will be shared by all locations run rmarkdown::render() in order to generate report for each location 6.1.1 Run the analysis 6.1.1.1 Format data data(&quot;data_model_GxE&quot;) data_model_GxE = format_data_PPBstats(data_model_GxE, type = &quot;data_agro&quot;) ## data has been formated for PPBstats functions. 6.1.1.2 Descriptive plots for each location vec_locations = levels(data_model_GxE$location) list_hist_locations = lapply( vec_locations, function(x){ p = plot( data_model_GxE, plot_type = &quot;histogramm&quot;, vec_variables = c(&quot;y1&quot;) ) p$y1 } ) names(list_hist_locations) = vec_locations Note that it is important that each element of the list refers to data of a given location in order to catch the right information in the next step when generating the report. 6.1.1.3 GGE model for all locations The function workflow_gxe() is coming from section 3.6.3. vec_variables = c(&quot;y1&quot;) res_gge = lapply(vec_variables, workflow_gxe, &quot;GGE&quot;) ## GGE model done for y1 names(res_gge) = vec_variables 6.1.1.4 Create a list with all results res = list(&quot;hist_locations&quot; = list_hist_locations, &quot;res_gge&quot; = res_gge ) 6.1.2 Create a .Rmd template Your template call two objects: params which is list with parameter of the report res which is a list with all results coming from the analysis Below is an example of a minimal template: --- title: &quot;`r params$title`&quot; date: &quot;`r format(Sys.time(), &#39;%d %B %Y&#39;)`&quot; author: Flower Seed output: html_document: toc: TRUE toc_float: TRUE --- ```{r global_options,include=FALSE} knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE) ``` # Introduction Here is a beautiful report with all results of the year ! # Description of data on the location ```{r} p = res$hist_locations[[location]] if(is.null(p)){print(&quot;No data for y1&quot;)}else {p} ``` # GGE analysis for the three locations The germplasm effects are the following: ```{r} res$res_gge$y1$p_out_mean_comparisons_gxe$germplasm ``` The which won where plot is the following: ```{r} res$res_gge$y1$p_out_biplot_gxe$biplot$which_won_where ``` 6.1.3 Generate a report for each location To generate the report, you need the R package rmarkdown installed. In the following example, the output is .html. You can choose .pdf or .docx. See ?rmarkdown::render for more information. library(rmarkdown) vec_locations = names(res$hist_locations) for (location in vec_locations){ # For each location, render a report params = list(&quot;title&quot; = paste(&quot;Agronomic analyses for&quot;, location)) rmarkdown::render(&quot;./template.Rmd&quot;, output_file = paste(&quot;report_&quot;, location, &quot;_&quot;, &quot;.html&quot;, sep = &quot;&quot;), output_dir = &quot;.&quot; ) } The report generated can be visualized for loc-1, loc-2 and loc-3. More examples of worklows with script, template and outputs can be found here. "],
["com-rules.html", "6.2 Organisational aspects on collective work", " 6.2 Organisational aspects on collective work Data analysis can influense the organisation of a group. It can have advantages and disadvantages. One advantage is that the results are discussed by all actors in the group bring information to the group and provide support for discussions between research teams and practicioners collectives On the other hand, the analyzes are necessarily reductionist. Be careful to discuss the results with all the actors in the group to avoid analyzes disconnected to the context. Be careful also not to constrain too much or standardize the practices to meet statistical standards. The decision of the farmer to select is based on different elements for example his experience on his farm informal exchanges with farmers, researchers, technicians, … information analysed with statistics What is the place of these elements in the decision to select a variety or a bouquet of spikes ? It seems important to discuss these issues when sharing results among farmers, researchers and facilitators. "],
["acknowledgement.html", "Acknowledgement", " Acknowledgement This work has been first funded by the European Community’s Seventh Framework Programme (FP7/9 2007–2013) under the grant agreement n245058-Solibam (Strategies for Organic and Low-input Integrated Breeding and Management). It has been completed by funding from European Union’s Horizon 2020 research and innovation programme under grant agreement No 633571 (DIVERSIFOOD project 2010-2014), by INRA (AgriBio4, 2015-2019), Fondation de France (2018-2020), CASDAR Covalience AAP n°5714 (2018-2021). Thanks to Hadley Wickham for his web site http://r-pkgs.had.co.nz/ that help us a lot in the creation of this package. Thanks to Jonathan Locqueville and Maxime Garnault that work during their internship on a first version of the AMMI code. Thanks to Salvatore Ceccarelli, Carlota Vaz Patto, Pedro Mendes Moreira, João Mendes Moreira for their useful comments and references on data analysis and software. "],
["references.html", "References", " References "]
]
